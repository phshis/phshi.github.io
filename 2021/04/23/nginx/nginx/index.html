<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nginx详解 | Phshi's blog</title><meta name="keywords" content="nginx"><meta name="author" content="Phshi"><meta name="copyright" content="Phshi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="nginx详解">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx详解">
<meta property="og:url" content="https://github.com/phshis/phshi.github.io.git/2021/04/23/nginx/nginx/">
<meta property="og:site_name" content="Phshi&#39;s blog">
<meta property="og:description" content="nginx详解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx-info-canva.jpg">
<meta property="article:published_time" content="2021-04-23T15:41:28.000Z">
<meta property="article:modified_time" content="2021-04-23T15:41:28.000Z">
<meta property="article:author" content="Phshi">
<meta property="article:tag" content="nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx-info-canva.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/phshis/phshi.github.io.git/2021/04/23/nginx/nginx/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Phshi","link":"链接: ","source":"来源: Phshi's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-23 23:41:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><style type="text/css">.card-announcement .social-button{margin: .6rem 0 0 0; text-align: center;}.card-announcement .social-button a{display: block; margin: 0.2rem 0;background-color: var(--btn-bg); color: var(--btn-color); line-height: 1.6rem; transition: all .3s; position: relative; z-index: 1;}</style><link rel="alternate" href="/atom.xml" title="Phshi's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fas fa-cubes"></i><span> 微博</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/phshi/phshi_picture/raw/master/img/nginx-info.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Phshi's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fas fa-cubes"></i><span> 微博</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nginx详解<a class="post-edit-link" href="https://github.com/jerryc127/butterfly.js.org/edit/main/source/_posts/nginx/nginx.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-23T15:41:28.000Z" title="发表于 2021-04-23 23:41:28">2021-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-23T15:41:28.000Z" title="更新于 2021-04-23 23:41:28">2021-04-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/nginx/">nginx</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/nginx/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nginx详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p>
<p><strong>Nginx 特点</strong></p>
<ul>
<li>高并发、高性能；</li>
<li>模块化架构使得它的扩展性非常好；</li>
<li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li>
<li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li>
<li>热部署、平滑升级；</li>
<li>完全开源，生态繁荣；</li>
</ul>
<h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p>
<ol>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li><code>API</code> 服务， <code>OpenResty</code> ；</li>
</ol>
<p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和 <code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p>
<p>用一张图表示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx1.png" alt="图片"></p>
<p><strong>Nginx 安装</strong></p>
<p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p>
<p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>

<p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Nginx配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf # nginx 主配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.default</span><br><span class="line"></span><br><span class="line"># 可执行程序文件</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;nginx-upgrade</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line"></span><br><span class="line"># nginx库文件</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service # 用于配置系统守护进程</span><br><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules # Nginx模块目录</span><br><span class="line"></span><br><span class="line"># 帮助文档</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;CHANGES</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README.dynamic</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line"></span><br><span class="line"># 静态资源目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;404.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 存放Nginx日志文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>主要关注的文件夹有两个：</p>
<p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p>
<p><strong>Nginx 常用命令</strong></p>
<p><code>systemctl</code> 系统命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 开机配置</span><br><span class="line">systemctl enable nginx # 开机自动启动</span><br><span class="line">systemctl disable nginx # 关闭开机自动启动</span><br><span class="line"></span><br><span class="line"># 启动Nginx</span><br><span class="line">systemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span><br><span class="line"></span><br><span class="line"># 停止Nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line"># 重启Nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line"># 重新加载Nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"># 查看 Nginx 运行状态</span><br><span class="line">systemctl status nginx</span><br><span class="line"></span><br><span class="line"># 查看Nginx进程</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"># 杀死Nginx进程</span><br><span class="line">kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span><br></pre></td></tr></table></figure>

<p><code>Nginx</code> 应用程序命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen # 重启 Nginx</span><br><span class="line">nginx -s stop # 快速关闭</span><br><span class="line">nginx -s quit # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T # 查看当前 Nginx 最终的配置</span><br><span class="line">nginx -t # 检查配置是否有问题</span><br></pre></td></tr></table></figure>

<h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># main段配置信息</span><br><span class="line">user  nginx; # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  auto; # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; # Nginx 的错误日志存放目录</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid; # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll; # 使用epoll的I&#x2F;O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024; # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123;</span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on; # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on; # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types; # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application&#x2F;octet-stream; # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # 加载子配置项</span><br><span class="line">    </span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">     listen       80; # 配置监听的端口</span><br><span class="line">     server_name  localhost; # 配置的域名</span><br><span class="line">      </span><br><span class="line">     # location段配置信息</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; # 网站根目录</span><br><span class="line">      index  index.html index.htm; # 默认首页文件</span><br><span class="line">      deny 172.168.22.11; # 禁止访问的ip地址，可以为all</span><br><span class="line">      allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     error_page 500 502 503 504 &#x2F;50x.html; # 默认50x对应的访问页面</span><br><span class="line">     error_page 400 404 error.html; # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 全局配置，对全局生效；</li>
<li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li>
<li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li>
<li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li>
<li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx2.png" alt="图片"></p>
<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user USERNAME [GROUP]</span><br><span class="line"></span><br><span class="line">user nginx lion; # 用户是nginx;组是lion</span><br></pre></td></tr></table></figure>



<p><strong>pid</strong></p>
<p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid &#x2F;opt&#x2F;nginx&#x2F;logs&#x2F;nginx.pid # master主进程的的pid存放在nginx.pid的文件</span><br></pre></td></tr></table></figure>

<h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。</span><br></pre></td></tr></table></figure>



<p><strong>worker_rlimit_core</strong></p>
<p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_core 50M; # 存放大小限制</span><br><span class="line">working_directory &#x2F;opt&#x2F;nginx&#x2F;tmp; # 存放目录</span><br></pre></td></tr></table></figure>

<h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4; # 指定具体子进程数量</span><br><span class="line">worker_processes auto; # 与当前cpu物理核心数一致</span><br></pre></td></tr></table></figure>

<h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程</span><br></pre></td></tr></table></figure>



<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx3.png" alt="图片"></p>
<p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用 <code>Nginx</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_priority -10; # 120-10&#x3D;110，110就是最终的优先级</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p>
<p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p>
<h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_shutdown_timeout 5s;</span><br></pre></td></tr></table></figure>

<h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure>

<p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemon off; # 默认是on，后台运行模式</span><br></pre></td></tr></table></figure>

<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use method; # 不推荐配置它，让nginx自己选择</span><br><span class="line"></span><br><span class="line">method 可选值为：select、poll、kqueue、epoll、&#x2F;dev&#x2F;poll、eventport</span><br></pre></td></tr></table></figure>

<h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_connections 1024 # 每个子进程的最大连接数为1024</span><br></pre></td></tr></table></figure>

<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex on # 默认是off关闭的，这里推荐打开</span><br></pre></td></tr></table></figure>

<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name name1 name2 name3</span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">server_name www.nginx.com;</span><br></pre></td></tr></table></figure>

<p>域名匹配的四种写法：</p>
<ul>
<li>精确匹配：<code>server_name www.nginx.com</code> ;</li>
<li>左侧通配：<code>server_name *.nginx.com</code> ;</li>
<li>右侧统配：<code>server_name www.nginx.*</code> ;</li>
<li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li>
</ul>
<p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p>
<p><code>server_name</code> 配置实例：</p>
<p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span><br><span class="line">121.42.11.34 www.nginx-test.com</span><br><span class="line">121.42.11.34 mail.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.org</span><br><span class="line">121.42.11.34 doc.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.cn</span><br><span class="line">121.42.11.34 fe.nginx-test.club</span><br></pre></td></tr></table></figure>

<p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p>
<p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 这里只列举了http端中的sever端配置</span><br><span class="line"></span><br><span class="line"># 左匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name *.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;left-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正则匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name ~^.*\.nginx-test\..*$;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;reg-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 右匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.*;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;right-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 完全匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;all-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、访问分析</p>
<ul>
<li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li>
<li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li>
</ul>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root path</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F;image &#123;</span><br><span class="line"> root &#x2F;opt&#x2F;nginx&#x2F;static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure>

<p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line"> alias &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure>

<p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配规则：</p>
<ul>
<li><code>=</code> 精确匹配；</li>
<li><code>~</code> 正则匹配，区分大小写；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>^~</code> 匹配到即停止搜索；</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.nginx-test.com;</span><br><span class="line">  </span><br><span class="line">  # 只有当访问 www.nginx-test.com&#x2F;match_all&#x2F; 时才会匹配到&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;match_all&#x2F;index.html</span><br><span class="line">  location &#x3D; &#x2F;match_all&#x2F; &#123;</span><br><span class="line">      root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      index index.html</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;1.jpg 等路径时会去 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images&#x2F;1.jpg 找对应的资源</span><br><span class="line">  location ~ \.(jpeg|jpg|png|svg)$ &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;bbs&#x2F; 时会匹配上 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;bbs&#x2F;index.html</span><br><span class="line">  location ^~ &#x2F;bbs&#x2F; &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>location 中的反斜线</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test&#x2F; &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li>
<li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404; # 直接返回状态码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 302 &#x2F;bbs ; # 返回状态码 + 重定向地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return https:&#x2F;&#x2F;www.baidu.com ; # 返回重定向地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：rewrite 正则表达式 要替换的内容 [flag];</span><br><span class="line"></span><br><span class="line">上下文：server、location、if</span><br><span class="line"></span><br><span class="line">示例：rewirte &#x2F;images&#x2F;(.*\.jpg)$ &#x2F;pic&#x2F;$1; # $1是前面括号(.*\.jpg)的反向引用</span><br></pre></td></tr></table></figure>

<p><code>flag</code> 可选值的含义：</p>
<ul>
<li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li>
<li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li>
<li><code>redirect</code> 返回302临时重定向；</li>
<li><code>permanent</code> 返回301永久重定向；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion.club; # 要在本地hosts文件进行配置</span><br><span class="line">  root html;</span><br><span class="line">  location &#x2F;search &#123;</span><br><span class="line">   rewrite ^&#x2F;(.*) https:&#x2F;&#x2F;www.baidu.com redirect;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;images &#123;</span><br><span class="line">   rewrite &#x2F;images&#x2F;(.*) &#x2F;pics&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;pics &#123;</span><br><span class="line">   rewrite &#x2F;pics&#x2F;(.*) &#x2F;photos&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;photos &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个配置我们来分析：</p>
<ul>
<li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li>
<li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的 <code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li>
</ul>
<h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：if (condition) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">上下文：server、location</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">if($http_user_agent ~ Chrome)&#123;</span><br><span class="line">  rewrite &#x2F;(.*)&#x2F;browser&#x2F;$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>condition</code> 判断条件：</p>
<ul>
<li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li>
<li><code>=</code> 或 <code>!=</code> 相等或不等；</li>
<li><code>~</code> 正则匹配；</li>
<li><code>! ~</code> 非正则匹配；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li>
<li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li>
<li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root html;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   if ( $uri &#x3D; &quot;&#x2F;images&#x2F;&quot; )&#123;</span><br><span class="line">     rewrite (.*) &#x2F;pics&#x2F; break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p>
<p><strong>autoindex</strong></p>
<p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p><code>autoindex.conf</code> 配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion-test.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;download&#x2F; &#123;</span><br><span class="line">    root &#x2F;opt&#x2F;source;</span><br><span class="line">    </span><br><span class="line">    autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx4.png" alt="图片"></p>
<p><strong>变量</strong></p>
<p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx5.png" alt="图片"></p>
<p>实例演示 <code>var.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"> listen 8081;</span><br><span class="line"> server_name var.lion-test.club;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  return 200 &quot;</span><br><span class="line">remote_addr: $remote_addr</span><br><span class="line">remote_port: $remote_port</span><br><span class="line">server_addr: $server_addr</span><br><span class="line">server_port: $server_port</span><br><span class="line">server_protocol: $server_protocol</span><br><span class="line">binary_remote_addr: $binary_remote_addr</span><br><span class="line">connection: $connection</span><br><span class="line">uri: $uri</span><br><span class="line">request_uri: $request_uri</span><br><span class="line">scheme: $scheme</span><br><span class="line">request_method: $request_method</span><br><span class="line">request_length: $request_length</span><br><span class="line">args: $args</span><br><span class="line">arg_pid: $arg_pid</span><br><span class="line">is_args: $is_args</span><br><span class="line">query_string: $query_string</span><br><span class="line">host: $host</span><br><span class="line">http_user_agent: $http_user_agent</span><br><span class="line">http_referer: $http_referer</span><br><span class="line">http_via: $http_via</span><br><span class="line">request_time: $request_time</span><br><span class="line">https: $https</span><br><span class="line">request_filename: $request_filename</span><br><span class="line">document_root: $document_root</span><br><span class="line">&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code> 中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">remote_addr: 27.16.220.84</span><br><span class="line">remote_port: 56838</span><br><span class="line">server_addr: 172.17.0.2</span><br><span class="line">server_port: 8081</span><br><span class="line">server_protocol: HTTP&#x2F;1.1</span><br><span class="line">binary_remote_addr: 茉</span><br><span class="line">connection: 126</span><br><span class="line">uri: &#x2F;test&#x2F;</span><br><span class="line">request_uri: &#x2F;test&#x2F;?pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">scheme: http</span><br><span class="line">request_method: GET</span><br><span class="line">request_length: 518</span><br><span class="line">args: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">arg_pid: 121414</span><br><span class="line">is_args: ?</span><br><span class="line">query_string: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">host: var.lion-test.club</span><br><span class="line">http_user_agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;88.0.4324.182 Safari&#x2F;537.36</span><br><span class="line">http_referer:</span><br><span class="line">http_via:</span><br><span class="line">request_time: 0.000</span><br><span class="line">https:</span><br><span class="line">request_filename: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;test&#x2F;</span><br><span class="line">document_root: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure>

<p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p>
<p><strong>Nginx 应用核心概念</strong></p>
<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx6.png" alt="图片"></p>
<p><strong>正向代理</strong></p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
</blockquote>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<ul>
<li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li>
</ul>
</blockquote>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性；</li>
</ul>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<p><strong>动静分离</strong></p>
<p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx7.png" alt="图片"></p>
<p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<p><strong>负载均衡</strong></p>
<p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code> 口人少车空....”，这个工作人员的作用就是负载均衡。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx8.png" alt="图片"></p>
<p><code>Nginx</code> 实现负载均衡的策略：</p>
<ul>
<li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li>
<li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li>
<li>最快响应时间策略：优先分配给响应时间最短的服务器。</li>
<li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li>
</ul>
<p><strong>Nginx 实战配置</strong></p>
<p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p>
<p><strong>upstream</strong></p>
<p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx9.png" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：upstream name &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">upstream back_end_server&#123;</span><br><span class="line">  server 192.168.100.33:8081</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>upstream</code> 内可使用的指令：</p>
<ul>
<li><code>server</code> 定义上游服务器地址；</li>
<li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li>
<li><code>keepalive</code> 对上游服务启用长连接；</li>
<li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li>
<li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code> 哈希负载均衡算法；</li>
<li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code> 最少连接数负载均衡算法；</li>
<li><code>least_time</code> 最短响应时间负载均衡算法；</li>
<li><code>random</code> 随机负载均衡算法；</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：server address [parameters]</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p><code>parameters</code> 可选值：</p>
<ul>
<li><code>weight=number</code> 权重值，默认为1；</li>
<li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code> 服务器不可用的检查次数；</li>
<li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code> 标记服务器长期不可用，离线维护；</li>
</ul>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keepalive connections;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br><span class="line"></span><br><span class="line">示例：keepalive 16;</span><br></pre></td></tr></table></figure>

<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_requests number;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_requests 100;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>



<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_timeout time;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_timeout 60s;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream back_end&#123;</span><br><span class="line"> server 127.0.0.1:8081 weight&#x3D;3 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;2;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 50;</span><br><span class="line">  keepalive_timeout 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_pass URL;</span><br><span class="line"></span><br><span class="line">上下文：location、if、limit_except</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;proxy</span><br></pre></td></tr></table></figure>

<p><code>URL</code> 参数原则</p>
<ol>
<li><p><code>URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p>
</li>
<li><p><code>URL</code> 中可以携带变量；</p>
</li>
<li><p><code>URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p>
</li>
</ol>
<p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p>
<ol>
<li><code>proxy_pass http://192.168.100.33:8081</code></li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ol>
<p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li>
<li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li>
</ul>
<p>不带 <code>/</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
</ol>
<p> 3 . 请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
<p>带 <code>/</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p>
</li>
</ol>
<p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p>
<p><strong>配置反向代理</strong></p>
<p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code> 与 <code>121.5.180.193</code> 。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">server&#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy&#x2F;index.html</span><br><span class="line">&lt;h1&gt; 121.42.11.34 proxy html &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>



<p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">upstream back_end &#123;</span><br><span class="line">  server 121.42.11.34:8080 weight&#x3D;2 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;3;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 80;</span><br><span class="line">  keepalive_timeout 20s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name proxy.lion.club;</span><br><span class="line">  location &#x2F;proxy &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;back_end&#x2F;proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code> 进入配置文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.5.180.193 proxy.lion.club</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx10.png" alt="图片"></p>
<p>分析：</p>
<p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p>
<p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p>
<p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p>
<p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8020 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8030;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8030 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8040;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8040 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后：</p>
<ol>
<li><p><code>nginx -t</code> 检测配置是否正确；</p>
</li>
<li><p><code>nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p>
</li>
<li><p>执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p>
</li>
</ol>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">121.5.180.193 balance.lion.club</span><br></pre></td></tr></table></figure>

<p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx11.png" alt="图片"></p>
<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：least_conn;</span><br><span class="line"></span><br><span class="line">上下文：upstream;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  zone test 10M; # zone可以设置共享内存空间的名字和大小</span><br><span class="line">  least_conn;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后你会发现，负载均衡的配置其实一点都不复杂。</p>
<p><strong>配置缓存</strong></p>
<p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习 <code>Nginx</code> 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache zone | off ; # zone 是共享内存的名称</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache off;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_path path [level&#x3D;levels] ...可选参数省略，下面会详细列举</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_path off</span><br><span class="line"></span><br><span class="line">上下文：http</span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li><code>path</code> 缓存文件的存放路径；</li>
<li><code>level path</code> 的目录层级；</li>
<li><code>keys_zone</code> 设置共享内存；</li>
<li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li>
</ul>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_key</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_key $scheme$proxy_host$request_uri;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_valid [code...] time;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span><br></pre></td></tr></table></figure>

<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_no_cache string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_no_cache $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>

<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_bypass string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_cache_bypass $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>

<h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MISS: 未命中缓存</span><br><span class="line">HIT：命中缓存</span><br><span class="line">EXPIRED: 缓存过期</span><br><span class="line">STALE: 命中了陈旧缓存</span><br><span class="line">REVALIDDATED: Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING: 内容陈旧，但正在更新</span><br><span class="line">BYPASS: X响应从原始服务器获取</span><br></pre></td></tr></table></figure>

<h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 1010;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1010;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 1020;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path &#x2F;etc&#x2F;nginx&#x2F;cache_temp levels&#x3D;2:2 keys_zone&#x3D;cache_zone:30m max_size&#x3D;2g inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line"></span><br><span class="line">upstream cache_server&#123;</span><br><span class="line">  server 121.42.11.34:1010;</span><br><span class="line">  server 121.42.11.34:1020;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p>
<p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span><br><span class="line">  if ($request_uri ~ \.(txt|text)$) &#123;</span><br><span class="line">   set $cache_name &quot;no cache&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HTTPS</strong>**</p>
<p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<ol>
<li><p>客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p>
</li>
<li><p>百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p>
</li>
<li><p>浏览器验证 <code>CA</code> 证书是否为合法证书；</p>
</li>
<li><p>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
</li>
<li><p>发送公钥加密后的随机数给百度服务器；</p>
</li>
<li><p>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
</li>
<li><p>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
</li>
<li><p>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p>
</li>
</ol>
<p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p>
<h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server; # SSL 访问端口号为 443</span><br><span class="line">  server_name lion.club; # 填写绑定证书的域名(我这里是随便写的)</span><br><span class="line">  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club_bundle.crt; # 证书地址</span><br><span class="line">  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club.key; # 私钥地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span><br><span class="line"> </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p>
<p><strong>配置跨域 CORS</strong></p>
<p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html 同源</span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html 不同源，协议不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html 不同源，端口不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html 不同源，主机不同</span><br></pre></td></tr></table></figure>

<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、 <code>LocalStorage</code> 等数据。</li>
<li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li>
<li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p>
<ul>
<li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen      80;</span><br><span class="line"> server_name  fe.server.com;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  proxy_pass dev.server.com;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p>
<p><strong>配置开启 gzip 压缩</strong></p>
<p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code> 、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p>
<p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p>
<p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx12.png" alt="图片"></p>
<p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx13.png" alt="图片"></p>
<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># # 默认off，是否开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 要采用 gzip 压缩的 MIME 文件类型，其中 text&#x2F;html 被系统强制启用；</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><br><span class="line"></span><br><span class="line"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span><br><span class="line">gzip_static on;</span><br><span class="line"></span><br><span class="line"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>



<p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p>
<p><strong>Nginx 架构</strong></p>
<p><strong>进程结构</strong></p>
<p>多进程结构 <code>Nginx</code> 的进程模型图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx14.png" alt="图片"></p>
<p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p>
<ul>
<li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p>
</li>
<li><ul>
<li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li>
<li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li>
</ul>
</li>
<li><p>子进程间是通过共享内存的方式进行通信的。</p>
</li>
</ul>
<h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p>
<ol>
<li>向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</li>
</ol>
<p><code>2. master</code> 进程检查配置语法是否正确；</p>
<p><code>3. master</code> 进程打开监听端口；</p>
<p><code>4. master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p>
<p><code>5. master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p>
<p>\6. 老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p>
<p>\7. 整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p>
<h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx15.png" alt="图片"></p>
<p>转自： 掘金 - Lion</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6942607113118023710">https://juejin.cn/post/6942607113118023710</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Phshi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/phshis/phshi.github.io.git/2021/04/23/nginx/nginx/">https://github.com/phshis/phshi.github.io.git/2021/04/23/nginx/nginx/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/phshis/phshi.github.io.git" target="_blank">Phshi's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nginx/">nginx</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/pay/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/pay/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/pay/alipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/pay/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/23/LeetCode/easy/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"><img class="prev-cover" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/symmetric-tree-canva.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对称二叉树</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/24/LeetCode/easy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"><img class="next-cover" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/maximum-depth-of-binary-tree-canva.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">二叉树的最大深度</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Phshi</div><div class="author-info__description">stay hungry,stay foolish!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/XiaoXiao-S"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:phshi.0603@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">小小程序员一枚，欢迎大家进入我的blog，我也一直在学习，如果bolg中有什么错误，欢迎大家在<a href="/blog/messageboard/" style="color:#49b1f5">留言板</a>或者在邮件<span style="color:#49b1f5">phshi.0602@foxmail.com</span>进行反馈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx"><span class="toc-number">1.</span> <span class="toc-text">Nginx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Nginx 作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">Nginx 核心配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">配置文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-main-%E6%AE%B5%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">配置文件 main 段核心参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user"><span class="toc-number">3.3.</span> <span class="toc-text">user</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-rlimit-nofile-number"><span class="toc-number">3.3.1.</span> <span class="toc-text">worker_rlimit_nofile_number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-processes-number"><span class="toc-number">3.3.2.</span> <span class="toc-text">worker_processes_number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-cpu-affinity"><span class="toc-number">3.3.3.</span> <span class="toc-text">worker_cpu_affinity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-shutdown-timeout"><span class="toc-number">3.3.4.</span> <span class="toc-text">worker_shutdown_timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-resolution"><span class="toc-number">3.3.5.</span> <span class="toc-text">timer_resolution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-events-%E6%AE%B5%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">配置文件 events 段核心参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#use"><span class="toc-number">3.4.1.</span> <span class="toc-text">use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-connections"><span class="toc-number">3.4.2.</span> <span class="toc-text">worker_connections</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root"><span class="toc-number">3.5.</span> <span class="toc-text">root</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alias"><span class="toc-number">3.6.</span> <span class="toc-text">alias</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#return"><span class="toc-number">3.6.1.</span> <span class="toc-text">return</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rewrite"><span class="toc-number">3.7.</span> <span class="toc-text">rewrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.8.</span> <span class="toc-text">if 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-number">3.8.1.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keepalive"><span class="toc-number">3.8.2.</span> <span class="toc-text">keepalive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keepalive-requests"><span class="toc-number">3.8.3.</span> <span class="toc-text">keepalive_requests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.8.4.</span> <span class="toc-text">配置实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy-pass"><span class="toc-number">3.9.</span> <span class="toc-text">proxy_pass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.10.</span> <span class="toc-text">配置负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">3.10.1.</span> <span class="toc-text">最少连接数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-key"><span class="toc-number">3.10.2.</span> <span class="toc-text">proxy_cache_key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-no-cache"><span class="toc-number">3.10.3.</span> <span class="toc-text">proxy_no_cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-bypass"><span class="toc-number">3.10.4.</span> <span class="toc-text">proxy_cache_bypass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#upstream-cache-status-%E5%8F%98%E9%87%8F"><span class="toc-number">3.10.5.</span> <span class="toc-text">upstream_cache_status 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">3.10.6.</span> <span class="toc-text">配置实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6"><span class="toc-number">3.10.7.</span> <span class="toc-text">配置证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.8.</span> <span class="toc-text">Nginx 解决跨域的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%87%8D%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.</span> <span class="toc-text">配置文件重载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">3.12.</span> <span class="toc-text">Nginx 模块化管理机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/" title="JVM垃圾收集器(三) ------ 垃圾回收器（一）"><img data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/GC3-canva.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM垃圾收集器(三) ------ 垃圾回收器（一）"/></a><div class="content"><a class="title" href="/2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/" title="JVM垃圾收集器(三) ------ 垃圾回收器（一）">JVM垃圾收集器(三) ------ 垃圾回收器（一）</a><time datetime="2021-08-05T15:22:56.000Z" title="发表于 2021-08-05 23:22:56">2021-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/28/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%BA%8C)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="JVM垃圾收集器(二) ------ 垃圾收集相关算法"><img data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/GC1-canva.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM垃圾收集器(二) ------ 垃圾收集相关算法"/></a><div class="content"><a class="title" href="/2021/07/28/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%BA%8C)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="JVM垃圾收集器(二) ------ 垃圾收集相关算法">JVM垃圾收集器(二) ------ 垃圾收集相关算法</a><time datetime="2021-07-28T05:12:32.000Z" title="发表于 2021-07-28 13:12:32">2021-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/20/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%80)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/" title="JVM垃圾收集器(一) ------ 垃圾收集概述"><img data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/GC0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM垃圾收集器(一) ------ 垃圾收集概述"/></a><div class="content"><a class="title" href="/2021/07/20/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%80)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/" title="JVM垃圾收集器(一) ------ 垃圾收集概述">JVM垃圾收集器(一) ------ 垃圾收集概述</a><time datetime="2021-07-20T11:25:49.000Z" title="发表于 2021-07-20 19:25:49">2021-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/10/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89------%20%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/" title="JVM内存模型（六）------ 对象在内存中的存储"><img data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/runtime-data5-canva.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存模型（六）------ 对象在内存中的存储"/></a><div class="content"><a class="title" href="/2021/07/10/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89------%20%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/" title="JVM内存模型（六）------ 对象在内存中的存储">JVM内存模型（六）------ 对象在内存中的存储</a><time datetime="2021-07-10T02:15:49.000Z" title="发表于 2021-07-10 10:15:49">2021-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89------%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8E%A5%E5%8F%A3/" title="JVM内存模型（五）------ 执行引擎，本地库接口"><img data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/runtime-data4-canva.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存模型（五）------ 执行引擎，本地库接口"/></a><div class="content"><a class="title" href="/2021/07/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89------%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8E%A5%E5%8F%A3/" title="JVM内存模型（五）------ 执行引擎，本地库接口">JVM内存模型（五）------ 执行引擎，本地库接口</a><time datetime="2021-07-06T15:25:49.000Z" title="发表于 2021-07-06 23:25:49">2021-07-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/phshi/phshi_picture/raw/master/img/nginx-info.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Phshi</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener external nofollow noreferrer" href="http://baby_shi.gitee.io/blog/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.7.0/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.7.0/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.7.0/source/js/tw_cn.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.7.0/source/js/search/local-search.min.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://phshi-blog.vercel.app',
      avatar: 'monsterid',
      path: location.pathname,
      emojiCDN: '',
      emojiMaps: "",
      visitor: false
    }, {"placeholder":"如果有什么疑问或者问题，请在此处留言","pageSize":8,"lang":"zh-CN","requiredFields":["nick"]}))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/talking/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>