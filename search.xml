<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM垃圾收集器(三) ------ 垃圾回收器（一）</title>
      <link href="2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM垃圾收集器-三-垃圾回收器（一）"><a href="#JVM垃圾收集器-三-垃圾回收器（一）" class="headerlink" title="JVM垃圾收集器(三) ------ 垃圾回收器（一）"></a>JVM垃圾收集器(三) ------ 垃圾回收器（一）</h3><h4 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h4><h5 id="按照线程数分"><a href="#按照线程数分" class="headerlink" title="按照线程数分"></a>按照线程数分</h5><ul><li>串行垃圾回收器<ul><li>同一段时间内只允许一个CPU执行垃圾回收的操作， 此时工作线程暂停，直至垃圾收集工作结束</li><li>单CPU或者较小的应有等内存硬件平台不是特别优越的场合，串行回收器的表现就可以超过所并行回收器和并发回收器</li><li>串行回收器默认应有在客户端的Client模式下面的JVM中</li></ul></li><li>并行垃圾回收器 ------- 运用多个CPU同时执行垃圾回收，因此提升了吞吐量</li></ul><p>两个的相同特点:都采用了独占试，会产生STW</p><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716113019734.png" alt="image-20210716113019734" style="zoom:50%;" /><h5 id="按照工作模式分"><a href="#按照工作模式分" class="headerlink" title="按照工作模式分"></a>按照工作模式分</h5><ul><li>并发式垃圾回收器<br>与引用线程交替工作,尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器<br>垃圾收集线程一旦执行， 就停止应用程序中的所有用户线程，直到垃圾收集过程结束</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716113340366.png" alt="image-20210716113340366" style="zoom:50%;" /><h5 id="按照碎片分"><a href="#按照碎片分" class="headerlink" title="按照碎片分"></a>按照碎片分</h5><ul><li>压缩式垃圾回收器<ul><li>对存活的对象进行压缩整理，消除回收后的碎片 ------ 再分配对象的空间使用:指针碰撞</li></ul></li><li>非压缩式垃圾收集器<ul><li>不进行空间整理 ------ 分配对象使用的方式:空闲列表</li></ul></li></ul><h5 id="工作的内存分"><a href="#工作的内存分" class="headerlink" title="工作的内存分"></a>工作的内存分</h5><ul><li>老年代垃圾收集器</li><li>年轻代垃圾回收器</li></ul><h4 id="GC评估指标"><a href="#GC评估指标" class="headerlink" title="GC评估指标"></a>GC评估指标</h4><p>衡量垃圾收集器的三项最重要的指标是:内存占用(Footprint)、吞吐量(Throughput)和延迟(Latency)，三者共同构成了一个“不可能三角。</p><ul><li><strong>吞吐量:运行的用户代码时间占总时间的比例</strong></li><li>垃圾收集的开销:吞吐量的补数，垃圾收集的时间和总运行时间的比例</li><li><strong>暂停时间:垃圾收集时程序的工作线程被暂停的时间</strong></li><li>收集频率:相对于应用程序的执行，收集操作发生的频率</li><li><strong>内存占用: Java堆所占的内存大小</strong></li><li>快速:垃圾从收集到被回收所经历的时间</li></ul><p>在设计GC算法时，我们必须明确自己的目标，针对于吞吐量和暂停时间，我们只能取一个， 现在最大的目标就是最大吞吐量优化的情况下，降低停顿时间。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>垃圾收集器与他们的搭配规则：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716141200120.png" alt="image-20210716141200120"></p><ul><li>两个收集器之间有连线，表明他们可以搭配使用<ul><li>Serial/Serial Old、Serial/CMS、ParNaw/Serial Old、Serial/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1</li></ul></li><li>其中Serial Old作为CMS出现“Concurrent Mode Failure”失败的后背预案</li><li>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ， 即:移除。</li><li>(绿色虚线)JDK 14中:弃用Parallel Scavenge和Serial Old GC组合(JEP366)</li><li>(青色虚线)JDK 14中:删除CMS垃圾回收器 (JEP 363 )<h5 id="串行的垃圾收集器"><a href="#串行的垃圾收集器" class="headerlink" title="串行的垃圾收集器"></a>串行的垃圾收集器</h5></li></ul><p>图示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716150452591.png" alt="image-20210716150452591"></p><h6 id="Serial（年轻代）"><a href="#Serial（年轻代）" class="headerlink" title="Serial（年轻代）"></a>Serial（年轻代）</h6><ul><li>串行回收</li><li>最基本，历史最悠久的收集器</li><li>HotSpot中Client模式下默认的新生代垃圾收集器</li><li>采用复制算法、串行回收和STW机制的方式内存回收</li></ul><p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效(与其他收集器的单线程相比)，所以Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。</p><h6 id="Serial-Old（老年代）"><a href="#Serial-Old（老年代）" class="headerlink" title="Serial Old（老年代）"></a>Serial Old（老年代）</h6><ul><li>串行回收和STW机制</li><li>内存回收算法使用的是标记压缩算法</li><li>运行在client模式下的默认老年代垃圾回收器</li><li>在service模式下的两个用途<ul><li>与新生代的Parallel Scavenge配合使用</li><li>作为老年代CMS垃圾收集的后背方案</li></ul></li></ul><p>作用：</p><ul><li>供客户端模式下的HotSpot虚拟机使用</li><li>服务器端的模式下：<ul><li>在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用</li><li>作为CM S 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。</li></ul></li></ul><p><strong>Serial和Serial Old总结：</strong></p><p>是一个单线程的垃圾回收器，该单线程指的不只是使用一个CPU,而且在运行的时候会产生STW</p><p>优势：</p><ul><li>简单而高效</li><li>在client模式下是一个不错的选择</li></ul><p>XX: +UserSerialGC指定年轻代和老年代都使用串行回收收集器</p><p>总结：</p><ul><li>单核CPU时候使用</li><li>一般javaweb引用不会采用串行垃圾收集器的</li><li>单CPU的情况下，他比并行垃圾收集器更高效</li></ul><h5 id="并行的垃圾收集器"><a href="#并行的垃圾收集器" class="headerlink" title="并行的垃圾收集器"></a>并行的垃圾收集器</h5><h6 id="ParNew（年轻代）"><a href="#ParNew（年轻代）" class="headerlink" title="ParNew（年轻代）"></a>ParNew（年轻代）</h6><p>ParNew收集器实质上是Serial收集器的多线程并行版本</p><ul><li>并行回收</li><li>在多CPU、多核等情况下，可以更快速的完成垃圾收集，提升程序的吞吐量</li><li>目前，除了Serial外，就只有ParNew能和CMS收集器配合工作</li><li>-XX: +UserParNewGC手动设置</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716152001239.png" alt="image-20210716152001239" style="zoom:90%;" /><h6 id="parallel-Scavenge（年轻代）"><a href="#parallel-Scavenge（年轻代）" class="headerlink" title="parallel Scavenge（年轻代）"></a>parallel Scavenge（年轻代）</h6><p>目标：达到一个可控制的吞吐量(Throughput)。</p><p>吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）</p><p>特点：</p><ul><li>吞吐量优先</li><li>采用了复制算法，并行回收，stw机制</li><li>和ParNew不同，Parallel收集器目标是达到一个可控的吞吐量，他也被称之为吞吐量优先的垃圾收集器</li><li>比起ParNew新添加了自适应策略</li><li>高吞吐量可以有效的利用CPU时间，尽快的完成运算任务，主要适合在后台运算而不需要太多交互的任务，因此，在常见的服务器中使用</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716152621256.png" alt="image-20210716152621256" style="zoom:90%;" /><h6 id="parallel-Old（老年代）"><a href="#parallel-Old（老年代）" class="headerlink" title="parallel Old（老年代）"></a>parallel Old（老年代）</h6><p>特点：</p><ul><li>采用标记压缩算法、并行回收，stw机制</li><li>与Parallel组合是Java8中的默认组合</li><li>-XX: +UserAdapttiveSizePolicy 设置收集器的自适应调节策略<ul><li>这种模式下年轻代大小、Eden和Survivor的比例会被自动调整</li><li>在手动调比较困难的时候可以考虑使用该方式</li></ul></li><li>-XX: MaxGCPauseMllis 设置垃圾收集器最大停顿时间(STW停顿时间) ------ 该参数使用该谨慎</li><li>-XX:GCTimeRatio垃圾收集时间占总时间的比例</li></ul><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑<code>Parallel Scavenge</code>加<code>Parallel Old</code>收集器这个组 合。</p><h5 id="并发垃圾回收器"><a href="#并发垃圾回收器" class="headerlink" title="并发垃圾回收器"></a>并发垃圾回收器</h5><h6 id="CMS（老年代）"><a href="#CMS（老年代）" class="headerlink" title="CMS（老年代）"></a>CMS（老年代）</h6><p>JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器 —— CMS收集器</p><p>特点：</p><ul><li>低延迟</li><li>第一次让垃圾收集线程和用户线程同时工作</li><li>CMS的垃圾收集算法采用了标记清除算法，并且也会STW</li><li>在1.4无法与Parallel配合工作</li></ul><p>工作原理：</p><ul><li>初始标记<ul><li>该阶段会产生stw的短暂暂停</li><li>该阶段仅仅是标记出GCRoot直接关联的对象</li><li>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快(因此stw时间非常短)</li></ul></li><li>并发标记<ul><li>从GCRoot的直接关联对象开始遍历整个对象图的过程</li><li>该过程耗时长但是不需要停顿用户线程，可以与垃圾收集线程一起并发执行</li></ul></li><li>重新标记<ul><li>由于并发标记阶段，程序的工作线程会和垃圾收集线程同时运行或者交叉执行，因此该时期，修正并发标记时期，因为用户程序运作而导致标记产生变动的哪一部分对象的标记记录</li><li>该阶段停顿时间通常会比初始标记阶段长一些但是远比标记阶段的短</li></ul></li><li>并发清除<ul><li>清除标记阶段已经判定为死亡岛饿对象，释放空间</li><li>由于不需要移动存活的对象，所以这阶段也是可以与用户线程并发的</li></ul></li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210719095530544.png" alt="image-20210719095530544" style="zoom:50%;" /><p>整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的</p><p>优点：</p><ul><li>采用并发回收(非独占式)，在初始标记和再次标记仍需要执行stw,但是暂停时间不会过长</li><li>由于耗费时间的并发标记与并发清除阶段都不需要暂停工作,所以整体回收是低停顿的</li></ul><p>缺点：</p><ul><li>在CMS回收过程中，由于用户线程还没有中断，所以应该确保用户线程有足够的内存可用</li><li>所以当堆达到某一阈值的时候便开始垃圾回收</li><li>采用的是标记清除算法，所以回收结束之后难免会产生一些内存碎片， 所以新对象分配空间的时候只能选择内存分配</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210719094249090.png" alt="image-20210719094249090" style="zoom:100%;" /><p>注意：采用Mark Sweep会造成内存碎片，为什么不使用Mark Compact呢?并发清除的时候，用compact整理内存的话，会导致内存位置发生变化，要保证用户线程能够继续执行，就要保证运行时对象地址不变。</p><ul><li>CMS收集器对CPU资源非常敏感</li><li>CMS无法处理浮动垃圾 ------ 在并发阶段如果产生了新的垃圾对象，CMS无法对这些垃圾对象进行标记，最后导致这些垃圾对象没有被及时回收</li></ul><p>总结：</p><ul><li>如果想要最小化的使用内存和并行开销 ------ <code>Serial GC</code></li><li>如果想要最大化的应用程序吞吐量 ------ <code>Parallel GC</code></li><li>如果想要最小化GC中断或者停顿时间 ------ <code>CMS GC</code></li></ul><p>JDK后续变化：</p><ul><li>JDK9被标记为<code>Deprecate</code></li><li>JDK14删除了CMS垃圾回收器</li></ul><p>JDK 9及以上版本的HotSpot虚拟机使用 参数-XX:+UseConcM arkSweep GC来开启CM S收集器的话，用户会收到一个警告信息，提示CM S未 来将会被废弃</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 垃圾收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集器(三) ------ 垃圾回收器(二)</title>
      <link href="2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2021/08/05/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%89)%20------%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM垃圾收集器-三-垃圾回收器（二）"><a href="#JVM垃圾收集器-三-垃圾回收器（二）" class="headerlink" title="JVM垃圾收集器(三) ------ 垃圾回收器（二）"></a>JVM垃圾收集器(三) ------ 垃圾回收器（二）</h3><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h5><h6 id="G1（整堆回收）"><a href="#G1（整堆回收）" class="headerlink" title="G1（整堆回收）"></a>G1（整堆回收）</h6><p>设定目标：在低延迟可控的情况下尽可能的获得高吞吐量</p><p><strong>特点：</strong></p><ul><li>G1是一款主要面向服务端应用的垃圾收集器。</li><li>G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。</li><li>自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了</li></ul><p><strong>G1垃圾回收的过程：</strong></p><ul><li>包括三个阶段，按照顺时针执行</li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210719104829498.png" alt="image-20210719104829498" style="zoom:50%;" /><p>回收主要包括三个阶段年轻代回收（Young GC）--》年轻代GC+并发标记过程（Young GC+concurrent mark）--〉混合回收（Mixed GC）三个阶段，</p><p>使用算法：并行回收器，采用复制算法，整体可看成是标记压缩算法</p><p>原理：</p><ul><li>将内存分隔为很多不相关的区域(Region)(物理上不连续)。使用不同的Region表示Eden、幸存者0区、幸存者1区和老年代；</li><li>G1跟踪各个Region中垃圾堆积的价值的大小(回收所获得空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据运行的收集时间，优先回收价值最大的Region</li></ul><p>记忆集：</p><ol><li>存在原因</li></ol><ul><li>一个对象存在被不同区域引用的问题，也就是说在可达性分析算法中，新生代中的这个Region可能被老年代中的Region中引用，而两个Region存在不同区域，也就是说，一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?</li><li>在其他的分代收集器，也存在这样的问题(而G1更突出)</li><li>回收新生代也不得不同时扫描老年代?</li><li>这样的话会降低Minor GC的效率;</li></ul><ol start="2"><li>解决办法</li></ol><ul><li>无论G1还是其他分代收集器，JVM都是使用<code>RememberedSet</code>来避免全局扫描，每个Region都有一个对应的<code>Remembered Set</code>;</li><li>每次<code>Reference</code>类型数据写操作时，都会产生一个<code>Write Barrier</code> 暂时中断操作,然后检查将要写入的引用指向的对象是否和该<code>Reference</code>类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象) ;</li><li>如果不同，通过<code>CardTable</code>把相关引用信息证录到引用指向对象的所在Region对应的<code>Remembered Set</code>中;</li><li>当进行垃圾收集时，在GC根节点的枚举范围加入<code>Remembered Set</code>; 就可以保证不进行全局扫描，也不会有遗漏。</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210808161131162.png" alt="image-20210808161131162" style="zoom:30%;" /><p>G1堆空间图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210719105850171.png" alt="image-20210719105850171" style="zoom:50%;" /><p>Region中还有一类特殊的<code>Humongous</code>(又称之为巨型对象)区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p><p>Region：</p><ul><li>使用G1收集器，他将整个堆划分为2048个大小相同并且独立的region块，每个region块的大小根据堆空间实际的大小而定</li><li>每个region的大小被控制在1MB到32MB直接，并且为2的n次幂，可以通过<code>-XX: G1HeapRegionSize</code>设置</li><li>所有Region大小相同，并且在JVM生命周期内不会被改变</li><li>虽然G1还保留了新生代和老年代，但是他们已经不再是物理隔离了，他们现在都是一个个Region的集合（不需要连续），通过Region的动态分配实现逻辑上的连续。</li><li>一个Region只能是Eden，Survivor或者Old/Tenured内存区域，而且那个region只能属于一个角色</li><li>Humongous是G1垃圾收集器的一种新的内存区域，主要用于存储大对象，如果对象超过50%的Region就放在Humongous里面</li></ul><p>设置Humongous的原因：</p><ul><li>一般情况，如果对于堆空间中的大对象，在以前分区的情况下，我们都是直接分配到老年代的，但是如果该对象是一个短期存在的大对象，那么就会对垃圾回收造成负面影响。故设计了一个Humongous区域用于存储大对象。</li><li>当然如果一个H区域还是无法存放该对象的话，那么G1就会去寻找连续的H区用来存储该对象。有些时候，为了获得连续的H区，就不得不启动Full GC。G1的大多数行为都把H区看作是老年代的一部分看待。</li></ul><p><strong>G1垃圾收集器回收过程</strong></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210808163258420.png" alt="image-20210808163258420" style="zoom:33%;" /><ol><li>年轻代GC</li></ol><ul><li>第一阶段，扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li><li>第二阶段，更新RSet。<br>处理<code>dirty card queue</code>中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li><li>第三阶段，处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li>第四阶段，复制对象。<br>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到01d区中空的内存分段。如果Survivor空间不够， Eden 空间的部分数据会直接晋升到老年代空间。</li><li>第五阶段，处理引用。<br>处理Soft，Weak， Phantom， Final， JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul><ol start="2"><li>并发标记过程</li></ol><ul><li>**初始标记阶段:**标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li>**根区域扫描(<code>Root Region Scanning</code>) : **G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在<code>young GC</code>之前完成。</li><li>**并发标记(Concurrent Marking): **在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li><li>**再次标记(Remark): **由 于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:<code>snapshot-at-the- beginning (SATB)</code>。</li><li>**独占清理(cleanup ,STW):**计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。<ul><li>这个阶段并不会实际上去做垃圾的收集</li></ul></li><li>**并发清理阶段:**识别并清理完全空闲的区域。</li></ul><ol start="3"><li>混合回收</li></ol><p>当越来越多的对象晋升到老年代<code>old region</code>时，为了避免堆内存被耗尽，.虚拟机会触发一个混合的垃圾收集器即<code>Mixed GC</code>，该算法并不是一个<code>old GC</code>，除了回收整个<code>Young Region</code>)还会回收一部分的<code>old Region</code>。这里需要注意:是一部分老年代，而不是全部老年代。可以选择哪些<code>old Region</code>进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<code>Mixed GC</code>并不是<code>Full GC</code>。</p><ul><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</li><li>混合回收的回收集(<code>Collection Set</code>)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全-一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存<br>却很少。</li></ul><p><strong>G1的优势：</strong></p><ul><li>并行与并发<ul><li>并行 ------ G1回收期间。可以有多个GC线程同时工作，有效的利用了多核计算能力，此时用尸线程STW</li><li>并发 ------G1拥有与应用线程交替执行的能力，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li>分代收集<ul><li>G1属于分代型垃圾回收器</li><li>将堆划分为若干个小区域(Region) ，这些区域包含了逻辑上的年轻代和老年代</li><li>他和之前的回收器不同，他会同时兼顾年轻代和老年代</li></ul></li><li>空间整合<ul><li>CMS标记清除算法，内存碎片，若干次GC进行一次碎片整理</li><li>G1将堆划分为一个个Region, 内存回收以Region为单位, Region之间采用复制算法，整体可以看做是标记压缩算法。两种算法都可以避免内存碎片</li><li>在堆空间非常大的时候该优势就会表现的特别明显，只用挑一些内存不够的region进行回收而不是需要全部的堆进行回收</li></ul></li><li>可预测停顿时间模型<ul><li>可以明确的指定一个长度为M毫秒的时间段内，消耗在垃圾收集上面的时间不得超过N毫秒</li><li>由于分区的原因，G1只选择部分区域进行回收，缩短了回收范围,</li><li>G1跟踪各个Region里面垃圾堆积的大小（后台存在一个优先列表），根据允许收集的时间，优先回收价值大的，保证了尽可能在有限的时间内提高收集效率</li><li>对比CMS，G1未必能做到CMS最好情况下的延迟停顿，但是最差情况下却要好的很多 </li></ul></li></ul><p><strong>缺点：</strong></p><ul><li>相对于CMS，G1 还不具备全方位压倒性优势（比如G1在垃圾收集过程中的内存占用，运行时额外的执行负载都要比CMS要高）</li><li>经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存中才能更好的发挥其优势。平衡点在6-8GB之间</li><li>用户程序运行过程中，G1无论是 垃圾收集产生的内存占用还是运行时额外执行的负载，都比CMS要高</li></ul><p><strong>一些参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX: +UseG1GC</td><td>手动指定 使用G1收集器执行内存回收任务</td></tr><tr><td>-XX: G1HeapRegionSize</td><td>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java</br>堆大小划分出约2048个区域。默认是堆内存的1 /2000</td></tr><tr><td>-XX: MaxGCPauseMillis</td><td>设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</td></tr><tr><td>-XX: ParallelGCThread</td><td>设置sTw工作线程数的值。最多设置为8</td></tr><tr><td>-XX:ConcGCThreads</td><td>设置并发标记的线程数。将n设置为并行垃圾回收线程数(<code>ParallelGCThreads</code>)的1/4左右</td></tr><tr><td>-XX: InitiatingHeapoccupancyPercent</td><td>设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45.</td></tr></tbody></table><p><strong>使用步骤：</strong></p><ul><li>开启G1垃圾收集器.     <code>-XX: +UseG1GC</code></li><li>设置堆的最大内存      <code> -Xms.  -Xmx</code></li><li>设置最大的停顿时间    <code>  -XX: MaxGCPauseMillis</code></li></ul><p><strong>使用场景：</strong></p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)</li><li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案;<ul><li>如:在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒: (G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。</li></ul></li><li>用来替换掉JDK1.5中的CMS收集器;<br>在下面的情况时，使用G1可能比CMS好:<br>① 超过50%的Java堆被活动数据占用:<br>② 对象分配频率或年代提升频率变化很大:<br>③ GC停顿时间过长(长于0. 5至1秒)。</li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ul><p><strong>G1回收器优化建议</strong></p><ul><li>年轻代大小，<br>➢避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选顶显式设置年轻代大小，<br>➢固定年轻代的大小会覆盖暂停时间目标</li><li>暂停时间目标不要太过严苛<br>➢G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间<br>➢评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h6 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h6><p><code>Shenandoah</code>更像是G1的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致。</p><p>与G1的相同之处：</p><ul><li>使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region</li><li>默认的回收策略也同样是优先处理回收价值最大的 Region</li></ul><p>不同之处：</p><ul><li>支持并发的整理算法（G1的回收阶段是可以多线程并行的，但却不能与用户线程并发）</li><li>Shenandoah(目前)是默认不使用分代收集的</li><li>Shenandoah摒弃了在G 1中耗费大量内存和计算资源去维护的记忆集，改用名为“ 连接矩阵”(Connection Matrix)的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li></ul><h6 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h6><p>ZGC的内存布局：ZGC也采用基于Region的堆内存布局，但与它们不同的是 ，ZGC的Region具有动态性 —— 动态创建和销毁，以及 动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具的大、中、小三类容量</p><ul><li>小型Region(Small Region):容量固定为2MB，用于放置小于256KB的小对象。 </li><li>中型Region(M edium Region):容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li><li>大型Region(Large Region):容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4M B。大型Region在ZGC的实 现中是不会被重分配(重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到) 的，因为复制一个大对象的代价非常高昂。</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210720154744789.png" alt="image-20210720154744789" style="zoom:80%;" /><h5 id="经典垃圾收集器玉垃圾分代之间的关系"><a href="#经典垃圾收集器玉垃圾分代之间的关系" class="headerlink" title="经典垃圾收集器玉垃圾分代之间的关系"></a>经典垃圾收集器玉垃圾分代之间的关系</h5><table><thead><tr><th align="center">垃圾收集器</th><th align="center">分类</th><th align="center">作用位置</th><th align="center">使用算法</th><th align="center">特点</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行运行</td><td align="center">作用于新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">适用于单CPU环境下的Client模式</td></tr><tr><td align="center">ParNew</td><td align="center">并行运行</td><td align="center">作用于新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多CPU环境Server模式下于CMS配合使用</td></tr><tr><td align="center">Parallel</td><td align="center">并行运行</td><td align="center">作用于新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="center">Serial Old</td><td align="center">串行运行</td><td align="center">作用于老年代</td><td align="center">标记-压缩算法</td><td align="center">响应速度优先</td><td align="center">适用于单CPU环境下的Client模式</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行运行</td><td align="center">作用于老年代</td><td align="center">标记-压缩算法</td><td align="center">吞吐量优先</td><td align="center">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="center">CMS</td><td align="center">并行运行</td><td align="center">作用于老年代</td><td align="center">标记-压缩算法</td><td align="center">响应速度优先</td><td align="center">适用于互联网或者B/S业务</td></tr><tr><td align="center">G1</td><td align="center">并发、并行运行</td><td align="center">作用于新生代、老年代</td><td align="center">标记-压缩算法、复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用</td></tr></tbody></table><ul><li>新生代垃圾收集器：<code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code></li><li>老年代垃圾收集：<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code></li><li>整堆收集：<code>G1</code></li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210719104151558.png" alt="image-20210719104151558" style="zoom:50%;" /><hr><p><strong>GC发展阶段：</strong></p><p><code>Serial  =&gt;  Parallel（并行） =&gt; CMS（并发） =&gt;  G1 =&gt; ZGC</code></p><p><strong>查看默认使用的垃圾收集器：</strong></p><ul><li><code>-XX:+PrintCommonLineFlags</code> ------ 查看命令行相关参 数，包括使用的垃圾 收集器</li><li><code>jinfo flag</code>相关垃圾回收器参数进程ID</li></ul><h5 id="垃圾回收器的选择："><a href="#垃圾回收器的选择：" class="headerlink" title="垃圾回收器的选择："></a>垃圾回收器的选择：</h5><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一一个很大的提升。</p><p>为什么要选择垃圾收集器：</p><ul><li>没有最好的收集器，更没有万能的垃圾收集器</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸个收集器</li></ul><p>怎么选择垃圾收集器?</p><ul><li>优先调整堆的大小让JVM自适应完成；</li><li>如果内存小于100M， 使用串行收集器；</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器；</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择；</li><li>如果是多CPU、追求低停顿时间，需快速响应(比如延迟不能超过1秒，如互联网应用)，使用并发收集器<br><strong>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</strong></li></ul><h5 id="GC日志分析："><a href="#GC日志分析：" class="headerlink" title="GC日志分析："></a>GC日志分析：</h5><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p><p>内存分配与垃圾回收的参数列表：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX: +PrintGC</td><td>输出GC日志。类似:<code> -verbose:gc</code></td></tr><tr><td>-XX: +PrintGCDetails</td><td>输出GC的详细日志</td></tr><tr><td>-XX: +PrintGCTimeStamps</td><td>输出GC的时间戳(以基准时间的形式)</td></tr><tr><td>-XX: +PrintGCDateStamps</td><td>输出GC的时间戳(以日期的形式，如2013-05-04T21 :53:59.234+0800 )</td></tr><tr><td>-XX: +PrintHeapAtGC</td><td>在进行Gc的前后打印出堆的信息</td></tr><tr><td>-Xloggc:. . /logs/gc.1og</td><td>日志文件的输出路径</td></tr></tbody></table><h6 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h6><p>打开GC日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 215532K-&gt;11257K(217600K)] 224233K-&gt;26484K(314880K), 0.0139529 secs] [Times: user&#x3D;0.04 sys&#x3D;0.01, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 15119K-&gt;11179K(339968K)] 30346K-&gt;26413K(437248K), 0.0077372 secs] [Times: user&#x3D;0.03 sys&#x3D;0.01, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 11179K-&gt;0K(339968K)] [ParOldGen: 15234K-&gt;19906K(118784K)] 26413K-&gt;19906K(458752K), [Metaspace: 34048K-&gt;34048K(1079296K)], 0.0417696 secs] [Times: user&#x3D;0.15 sys&#x3D;0.01, real&#x3D;0.04 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 324096K-&gt;15851K(339968K)] 344002K-&gt;37957K(458752K), 0.0201106 secs] [Times: user&#x3D;0.04 sys&#x3D;0.01, real&#x3D;0.02 secs] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关闭虚拟机打印：</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 521216K, used 473385K [0x000000076ab00000, 0x000000078c280000, 0x00000007c0000000)</span><br><span class="line">  eden space 502784K, 94% used [0x000000076ab00000,0x000000078794a498,0x0000000789600000)</span><br><span class="line">  from space 18432K, 0% used [0x000000078ac00000,0x000000078ac00000,0x000000078be00000)</span><br><span class="line">  to   space 22528K, 0% used [0x0000000789600000,0x0000000789600000,0x000000078ac00000)</span><br><span class="line"> ParOldGen       total 142336K, used 36276K [0x00000006c0000000, 0x00000006c8b00000, 0x000000076ab00000)</span><br><span class="line">  object space 142336K, 25% used [0x00000006c0000000,0x00000006c236d3b0,0x00000006c8b00000)</span><br><span class="line"> Metaspace       used 68382K, capacity 72386K, committed 72448K, reserved 1112064K</span><br><span class="line">  class space    used 9278K, capacity 9970K, committed 9984K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>GC，Full GC</code>：同样是GC类型</li><li><code>Allocation Failure</code>：GC原因</li><li><code>PSYoungGen</code>：使用了Parallel Scavenge并行垃圾收集器后的新生代GC前后大小变化</li><li><code>ParOldGen</code>：使用了Parallel Old并行垃圾收集器的老年代GC前后大小变化</li><li><code>Metadata</code>：元数据区GC前后大小的变化，JDK1.8中引入了元数据区代替了永久代</li><li><code>xxx secs</code>：GC花费的时间</li><li><code>Times</code>：<code>user</code>: 指的是垃圾收集器花费的所有CPU时间，<code>sys</code>: 花费在等待系统调用或系统事件的时间，<code>real</code>:GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</li></ul><p>日志补充说明：</p><ul><li>”[GC&quot;和&quot; [Full GC&quot;说明了这次垃圾收集的停顿类型，如果有&quot;Full&quot;则说明GC发生了&quot;Stop The World&quot;</li><li>使用<code>Serial</code>收集器在新生代的名字是<code>Default New Generation</code>,因此显示的是&quot;[DefNew&quot;</li><li>使用<code>ParNew</code>收集器在新生代的名字会变成&quot; [ParNew&quot;,意思是&quot;Parallel New Generation&quot;</li><li>使用<code>Parallel Scavenge</code>收集器在新生代的名字是&quot; [PSYoungGen&quot; </li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用<code>G1</code>收集器的话，会显示为&quot;garbage-first heap&quot;</li><li><code>Allocation Failure</code>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li><code>[PSYoungGen: 215532K-&gt;11257K(217600K)] 224233K-&gt;26484K(314880K) </code><ul><li>中括号内: GC回收前年轻代大小，回收后大小，( 年轻代总大小)</li><li>括号外: GC回收前年轻代和老年代大小，回收后大小，( 年轻代和老年代总大小)</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核的原因，时间总和可能会超过real时间</li></ul><p>关闭虚拟时打印日志分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Heap (堆)</span><br><span class="line">PSYoungGen (Parallel Scavenge收集器新生代) total 521216K, used 473385K [0x000000076ab00000, 0x000000078c280000, 0x00000007c0000000)</span><br><span class="line">eden space (堆中的Eden区默认占比是8)502784K, 94% used [0x000000076ab00000,0x000000078794a498,0x0000000789600000)</span><br><span class="line">from space (堆中的Survivor,这里是from Survivor区默认占比是1) 18432K, 0% used [0x000000078ac00000,0x000000078ac00000,0x000000078be00000)</span><br><span class="line">to space (堆中的Survivor,这里是to Survivor区默认占比是1，需要先了解一下堆的分配策略)22528K, 0% used [0x0000000789600000,0x0000000789600000,0x000000078ac00000)</span><br><span class="line">ParOldGen (老年代总大小和使用大小)total 142336K, used 36276K [0x00000006c0000000, 0x00000006c8b00000, 0x000000076ab00000)</span><br><span class="line">object space (显示个使用百分比)142336K, 25% used [0x00000006c0000000,0x00000006c236d3b0,0x00000006c8b00000)</span><br></pre></td></tr></table></figure><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210808191111109.png" alt="image-20210808191111109" style="zoom:40%;" /><p>Full GC图示</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210808191221194.png" alt="image-20210808191221194" style="zoom:40%;" />]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 垃圾收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集器(二) ------ 垃圾收集相关算法</title>
      <link href="2021/07/28/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%BA%8C)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>2021/07/28/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%BA%8C)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM垃圾收集器-二-垃圾收集相关算法"><a href="#JVM垃圾收集器-二-垃圾收集相关算法" class="headerlink" title="JVM垃圾收集器(二) ------ 垃圾收集相关算法"></a>JVM垃圾收集器(二) ------ 垃圾收集相关算法</h3><h4 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h4><blockquote><p>对垃圾进行GC回收之前，首先需要区分内存中那些是存活的对象，那些是已经死亡的对象。<br>只有被标记为已经死亡的对象，GC才会执行垃圾回收，释放掉所占用的空间，这个阶段过程，我们称之为垃圾标记阶段</p></blockquote><p>判断一个对象是否存活主要有两种方式：引用计数法和可达性分析算法。</p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><ul><li>对每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A,则A的引用计数器就加1，当引用失败的时候，引用计数器就减1，只要A的引用计数器的值为0，则表明A不可再被使用，可进行回收。</li></ul><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>实现简单，垃圾对象便于识别</li><li>判定效率高，回收没有拖延性</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>需要单独字段存储计数器，增加了内存的开销</li><li>每次赋值需要更新计数器，伴随加法减法操作，增加了时间开销</li><li>无法处理循环引用的问题，是一条致命缺陷，导致了Java中没有使用该类算法</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710141944660.png" alt="image-20210710141944660" style="zoom:40%;" /><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和bj2能否被回收?</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710142715925.png" alt="image-20210710142715925" style="zoom:50%;" /><p>如果不下小心直接把obj1-reference和obj2-reference置null。则在Java堆当中的两块内存依然保持着互相引用，无法回收。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ul><li>Java没有使用引用计数法，因为他存在着循环引用问题，很难处理</li><li>Python使用了引用计数法<ul><li>Python手动的解决了循环引用的问题。就是在合适的时机，解除引用关系</li><li>使用弱引用weakref。是Python的标准库，旨在解决循环引用</li></ul></li></ul><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>又称之为：根搜索法，追踪性垃圾收集</p><p>目的：解决了引用计数法中循环引用的问题，防止了内存泄露的发生。</p><h6 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h6><ul><li>以跟对象集合(<code>GC Root</code>)为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达；</li><li>使用可达性分析算法之后，内存中存活的对象都会被根对象集合直接或者间接的连接着，搜索所走过的路径称之为引用链；</li><li>如果目标没有任何应用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象；</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活的。</li></ul><p>图解：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210714164358892.png" alt="image-20210714164358892" style="zoom:50%;" /><h6 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h6><p>GC Root包含的元素：</p><ul><li>虚拟机栈中的引用对象 ------ 比如各个线程被调用的方法中使用到的参数、局部変量(局部变量表中的内容)，临时变量</li><li>本地方法栈内JNI (通常说的本地方法)引用的对象</li><li>方法中类静态属性引用的对象 ------ 比如: java类引用类型静恋変量</li><li>方法区中的常量引用的对象 ------ 比如:宇符串常量池中(String Table)里面的引用</li><li>方法区中的静态属性引用的对象 ------ Java类的引用类型静态变量</li><li>所有被同同步<code>synchronize</code>持有的对象</li><li>Java虚拟机的内部引用 ------ 基本数据类型对应的Cass对象，一些常驻的异常对象(如<code>NullPointerException</code>,<code>OutOfMemoryrror</code>) ,系统类加载器</li><li>反虚Java虚拟机内部情况的<code>JXMBean</code>、<code>JVMTI</code>中注册的回调，本地代码缓存等。</li></ul><p>小技巧:由于Root采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那就是一个Root（也就是说存在于堆中，但是存在外部引用）。</p><p>注意：</p><ul><li>如果要使用可达性分析算法来判断内存是否可以被回收，那么分析工作必须在一个能保障一致性的快照中进行。 这点不能满足的话分析结果准确性就无法得到保障；</li><li>这点就是导致GC进行时必须&quot;<code>Stop The World</code>&quot;的一个重要原因 ------- 即使号称不会发生停顿的CMS收集器，枚举根节点时候也必须要停顿。</li></ul><h4 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h4><p>当成功区分出内存中存活对象和死亡对象之后，GC接下来的任务就是对执行垃圾进行回收，释放掉所占用的内存空间。</p><h5 id="清除对象的几种方式"><a href="#清除对象的几种方式" class="headerlink" title="清除对象的几种方式"></a>清除对象的几种方式</h5><h6 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（<code>Mark-Sweep</code>）</h6><p>执行过程：当堆的有效内存空间被耗尽的时候，就会停止整个程序(SWT)，然后进行两项工作(标记，清除)</p><ul><li>标记 ------ Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象头中标记为是可达对象</li><li>清除 ------ Collector从堆内存中从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为是可达对象，则将其回收</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210714224045506.png" alt="image-20210714224045506" style="zoom:30%;" /><p>缺点：</p><ul><li>效率不算高（如果包含大量的对象，且大部分是需要被回收的，那么就需要进行大量标记和清除的动作，导致执行效率随对象增长而降低）</li><li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li><li>清理出来的空间不是连续的，会产生内存碎片，需要维修一个空闲列表</li></ul><p>比较适合比如堆空间对象数量少并且存活时间长的回收</p><p>注意：这里指的置空并不是真正的置空，而是把需要清除的对象保存在空闲列表里面，下次加载，先判断该内存地址是否足够,如果够，就存放。</p><h6 id="标记-复制算法（Copying）"><a href="#标记-复制算法（Copying）" class="headerlink" title="标记-复制算法（Copying）"></a>标记-复制算法（Copying）</h6><p>主要用于解决<strong>标记-清除</strong>算法面对大量可回收对象时执行效率低的问题。</p><p>核心：它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。在垃圾回收的时候将内存中存活的对象复制到另一块未被使用的内存中，之后清除刚刚使用的内存块的所有对象,交换内存角色，完成回收。</p><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210716102741062.png" alt="image-20210716102741062" style="zoom:70%;" /><p>优点：</p><ul><li>没有标记清除过程，实现简单，运行高效</li><li>复制过去保证空间的连续性,不会产生内存碎片</li></ul><p>缺点：</p><ul><li>需要两倍的内存空间</li><li>当对象复制，导致地址改变，需要维护对象的引用关系。比如局部变量表中的对象引用需要从原来的改为复制过来的地址</li><li>如果内存中多数对象都是存 活的，这种算法将会产生大量的内存间复制的开销</li></ul><p>特别的：如果系统中，垃圾对象很多，复制算法需要复制的存活的对象并不是很大，比如年轻代。<br>应用场景：新生代中，对常规的垃圾进行回收（幸存者区）</p><p><strong>在新生代中很好的解决了空间浪费这个问题：</strong>新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。具体做法是把新生代分为一块较大的<code>Eden</code>空间和两块较小的<code> Survivor</code>空间，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。发生垃圾收集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。HotSpot虚拟机默认<code>Eden</code>和<code>Survivor</code>的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%(<code>Eden</code>的80%加上一个<code>Survivor</code>的10%)，只有一个<code>Survivor</code>空间，即10%的新生代是会 被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖其他内存区域(实际上大多就是老年代)进行分配担保(<code>Handle Promotion</code>)。</p><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210714224553581.png" alt="image-20210714224553581" style="zoom:50%;" /><h6 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（<code>Mark-Compact</code>）</h6><p>为了解决<strong>标记-复制算法</strong>在对象存活率较高时就要进行较多的复制操作，效率将会降低问题。</p><p>执行过程：</p><ul><li>第一阶段和标记清除算法一样,从根节点开始标记所有被引用的对象</li><li>第二阶段讲所有的存活的对象压缩到内存的一端，按照顺序排放</li><li>之后清理所有的内存空间</li><li>故也可以叫:标记-清除-压缩算法</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210715140456364.png" alt="image-20210715140456364" style="zoom:40%;" /><p>优点：</p><ul><li>消除了标记清除算法中，内存区域分散的缺点，我们需要给新的对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除复制算法中，内存减半的高频代价</li></ul><p>缺点：</p><ul><li>效率低于复制算法</li><li>移动对象的同时，如果被其他对象引用，则需要调整引用的地址</li><li>移动的过程中，需要全程暂停用户行为，STW</li></ul><h6 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h6><table><thead><tr><th></th><th>Mark-Sweep</th><th align="center">Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td align="center">最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但是会堆积碎片）</td><td align="center">最少（但是不会堆积碎片）</td><td>需要两倍空间（不会堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td align="center">是</td><td>是</td></tr></tbody></table><h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p><strong>分代收集算法建立起来的原因：</strong></p><ul><li>弱分代假说(<code>Weak Generational Hypothesis</code>):绝大多数对象都是朝生夕灭的；</li><li>强分代假说(<code>Strong Generational Hypothesis</code>):熬过越多次垃圾收集过程的对象就越难以消亡。</li><li>跨代引用假说(<code>Intergenerational Reference Hypothesis</code>):跨代引用相对于同代引用来说仅占极少数。（该条主要是因为比如在新生代内进行垃圾收集（<code>Minor GC</code>），但是新生代中的对象完全有可能在老年代中被使用，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样）</li></ul><p><strong>采用分代的话我们可以分情况分区域来考虑垃圾收集效率的问题：</strong>如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。</p><ul><li>年轻代</li></ul><p>特点：区域比老年代小，对象生命周期短，存活效率低，回收频繁</p><p>使用算法：复制算法 ------ 速度最快（对于空间问题的话使用survivor的设计得以解决）</p><p>垃圾收集器：<code>Minor GC/Young GC</code></p><ul><li>老年代</li></ul><p>特点：区域较大，对象生命周期长，存活率高，回收没有年轻代频繁</p><p>使用算法：标记清除或者标记压缩混合使用</p><p>垃圾收集器：<code>Major GC/Old GC</code>、<code>Full GC</code></p><p><strong>解决假说第三点的跨代引用问题：</strong></p><ul><li><p>问题出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以</span><br><span class="line">消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。但是，如果我们为了这老年代的少量的跨代引用就去扫描整个老年代，就太过于浪费空间与时间了。</span><br></pre></td></tr></table></figure></li><li><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在新生代上建立一个全局的数据结构(该结构被称为“记忆集”，Remembered Set)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</span><br></pre></td></tr></table></figure></li></ul><h6 id="增强收集算法"><a href="#增强收集算法" class="headerlink" title="增强收集算法"></a>增强收集算法</h6><ul><li><p>出现原因：为了尽量减少stw出现的时长</p></li><li><p>基本思想</p><ul><li>如果一次性将所有垃圾进行处理，需要造成系统长时间停顿，难么，我们就让用户线程和垃圾收集线程交替执行</li><li>每次垃圾收集只是收集一小块的区域的内存空间，接着切换到应用程序的线程。依次反复，直到垃圾收集完成。</li><li>总的来说，增量收集算法的基础任然是传统的标记清除和复制算法，增量收集算法基础仍然是标记清除和复制算法,增量收集算法通过对线程冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或者复制工作。</li></ul></li><li><p>缺点：使用该方式，由于垃圾回收过程中，间断性的还执行了引用程序代码,所有能够减少系统停顿的时间。但是，因为线程切换和上下文转化的消耗，会使得垃圾回收的总成本上升，造成系统吞吐量下降。</p></li></ul><h6 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h6><ul><li>般来说堆空间越大，一次性GC的时间就会越长，有关GC产生的停顿时间就越长，为了更好的控制GC产生的停顿时间，将一个内存很大的区域分割成多个小块，根据目标的停顿时间，每每次合理的回收若干个小区域，而不是整堆回收，从而减少一次GC所产生的停顿</li><li>分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分为连续的不同小区间</li><li>每一个小区间都独立使用，独立回收，这个算法的好处就是可以控制一次回收多少个小区间</li></ul><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210715124617296.png" alt="image-20210715124617296" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 垃圾收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集器(一) ------ 垃圾收集概述</title>
      <link href="2021/07/20/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%80)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/"/>
      <url>2021/07/20/Java/GC/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(%E4%B8%80)%20------%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM垃圾收集器-一-垃圾收集概述"><a href="#JVM垃圾收集器-一-垃圾收集概述" class="headerlink" title="JVM垃圾收集器(一) ------ 垃圾收集概述"></a>JVM垃圾收集器(一) ------ 垃圾收集概述</h3><blockquote><p>垃圾收集主要考虑的三件事情：</p><ul><li>哪些内存需要回收? </li><li>什么时候回收? </li><li>如何回收?</li></ul></blockquote><h4 id="垃圾收集概述"><a href="#垃圾收集概述" class="headerlink" title="垃圾收集概述"></a>垃圾收集概述</h4><ol><li>什么是垃圾？</li></ol><p>运行的程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><ol start="2"><li>为什么需要进行垃圾回收？</li></ol><p>如果没有GC,那么内存迟早会被耗完。除了释放没有用的对象，垃圾收集也可以清楚内存中记录的碎片。</p><ol start="3"><li>垃圾回收的地点？</li></ol><ul><li>垃圾收集可以对年轻代回收，也可以对老年代进行回收，甚至可以全堆和方法区的回收；</li><li>启动堆是垃圾收集器的工作重点；</li><li>从次数.上来讲<ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不动元空间</li></ul></li></ul><h5 id="system-gc"><a href="#system-gc" class="headerlink" title="system.gc()"></a><code>system.gc()</code></h5><ul><li><code>system.gc()</code>或者<code>Runtime.getRuntime().gc()</code>的调用，会显示的触发<code>FulIGC</code>,同<br>时对老年代和新生代进行回收，尝试释放被丢弃的对象占用的内存。</li><li><code>System.gc()</code>调用附带一个免责声明，无法保证对垃圾回收器的调用</li></ul><h5 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h5><ul><li>javadoc对OOM的解释就是:没有空闲的内存，并且垃圾收集器也没法提供更多的内存</li><li>JVM内存不够的两个原因<ul><li>java堆内存设置不够</li><li>代码中创建了大量的大对象，而且长时间不能被垃圾回收器收集(存在被引用)</li></ul></li><li>在抛出OOM之前，通常垃圾回收器会被触发，尽可能的去清理出空间（例如引用分析中的涉及jvm尝试会收的软引用指向的对象）</li></ul><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><ul><li>严格来说，只有对象不会再被程序用到，但是GC又不能回收他们的情况，才叫内存泄露</li><li>内存泄露不会立即引起程序奔溃,但是会一点一点的蚕食，直至内存被耗尽，直至出现OOM异常<br>例如：</li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710131808029.png" alt="image-20210710131808029" style="zoom:50%;" /><ul><li>举例<ul><li>单例模式 -------- 单例模式的生命周期和应用程序一样长， 如果持有对外部对象的引用的话，那么这个外部对象是不可回收的，会导致内存泄露的问题</li><li>一些close的资源未关闭 --------- 数据库连接，网络连接和io连接必须手动的close,否则不能被回收。</li></ul></li></ul><h5 id="SWT（stop-the-word）"><a href="#SWT（stop-the-word）" class="headerlink" title="SWT（stop the word）"></a>SWT（stop the word）</h5><ul><li>Stop The Word --------- 指的是发生GC的时候，会产生程序的停顿。停顿时整个应用程序都会被暂停,没有任何响应，就和卡死了一样；</li><li>可达性分析算法中枚举根节点(GC Roots)会导致所有的Java执行的线程停顿<ul><li>分析工作必须保证在一个能确保一致性的快照中进行</li><li>一致性指的是整个分析期间执行系统看起来像被冻结在某个时间点上面</li><li>如果出现分析过程中对象引用关系的不断变化则分析结果的准确性无法被确保</li></ul></li><li>SWT与哪款GC无关，所有GC都会有这个事件</li><li>STW是JVM在后台自动完成的，，在用户不可见的情况下，将用户的所有线程停止</li><li>开发过程中不要使用<code>System.gc()</code> ,会导致SWT的产生</li></ul><h5 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h5><p>并行：同时执行</p><p>并发：增抢线程前后执行</p><h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><ul><li>程序并非所有地方都能停下来进行GC，只有在特定位置才能停下来GC，这些位置就称之为安全点</li><li>安全点选择很重要，如果太少会导致GC等待时间太长，如果太频繁会导致性能问题</li><li>会选择执行时间长的指令作为安全点，如方法调用，循环跳转和异常跳转等</li><li>如何判断发生GC时，线程都跑到最近的安全点停顿下来呢<ul><li>抢先式中断(目前不采用了)</li><li>主动式中断</li></ul></li></ul><h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>指一段代码中，对象的引用关系不会发生变化，这个位置中任何位置开始GC都是安全的</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>我们希望这样一类对象，当内存空间足够时，如果内存空间进行了垃圾回收依旧还是很紧张，则可以抛弃这些对象 ------ 很多系统的缓存功能都符合这样的应 用场景。</p><p>对应的对象：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710133615641.png" alt="image-20210710133615641" style="zoom:50%;" /><h5 id="强引用-Strang-Reference"><a href="#强引用-Strang-Reference" class="headerlink" title="强引用(Strang Reference)"></a>强引用(Strang Reference)</h5><ul><li>传统的引用方式，无论任何情况下，只要引用关系还存在,垃圾回收就不会回收掉被引用的对象(指的是可达性分析中被标记为不是垃圾的对象)</li><li>java中最常见的引用类型就是强引用(99%以上都是)， 也是默认的引用类型。</li><li>强引用对象是可触及的，垃圾回收器永远不会回收被引用的对象</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿报OOM,也不会回收强引用指向的对象。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello Word&quot;</span>);</span><br></pre></td></tr></table></figure><p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是Str ingBuffer实例的强引用。</p><p>对应的内存结构：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710134035989.png" alt="image-20210710134035989" style="zoom:50%;" /><h5 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h5><ul><li>当系统将要发生内存溢出之前，将这些对象列入回收对象进行二次回收，回收后还没有足够的内存，才抛出OOM异常（指的是可达性分析中被标记为不是垃圾的对象)</li><li>内存不足及回收</li><li>软引用通常用来实现内存敏感的缓存，比如高速缓存就用到了软引用。如果还有空闲的内存，就保留缓存，当内存不足就清理掉。</li></ul><p>在<code>JDK 1.2</code>版之后提供了<code>java.lang.ref.SoftReference</code>类来实现软引用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//声明为强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;<span class="comment">//摧毁强引用</span></span><br></pre></td></tr></table></figure><h5 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h5><ul><li>被弱引用引用的对象只存活到下一次垃圾街回收之前， 当垃圾收集器工作时，无论空间是否足够，都会回收掉被引用的对象</li><li>发现即回收</li><li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统空间是否充足，都会回收掉被弱引用关联的对象</li><li>软引用和弱引用都适合来保存一些可有可无的缓存</li><li>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</li></ul><p>在<code>JDK 1. 2</code>版之后提供了<code>java.lang.ref.WeakReference</code>类来实现弱引用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; softReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>面试题:你开发中使用过<code>WeakHashMap</code>吗?</p><h5 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h5><ul><li>一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来获得一个对象的实例。 为一个对象设置<br>虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。</li><li>对象回收跟踪</li><li>虚引用必须和引用队列一起使用。虚引用在创建时必需提供一个引用队列作为参数， 当垃圾回收器准备回收一个对象时， 发现他还有虚引用，就会在回收对象后，将虚拟引用加入引用队列，已通知应用程序的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，所以也可以将资源释放的一些操作放置在虚引用中执行和记录</li></ul><p>在JDK 1. 2版之后提供了PhantomRe ference类来实现虚引用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, referenceQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h5 id="终结引用-Final-Reference"><a href="#终结引用-Final-Reference" class="headerlink" title="终结引用(Final Reference)"></a>终结引用(Final Reference)</h5><ul><li>他用以现实对象的finalize()方法，也可以称之为终结引用</li><li>无需手动编码，配合引用队列使用</li><li>在GC时，终结器引用队列</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><code>finalize()</code>是Object类的一个方法，一个对象重写该方法将会在垃圾回收之前执行，finalize()方法是对象逃脱死亡命运的最后一次机会，但是，该方法只会执行一次。</p><p>可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:</p><ul><li>对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记</li><li>通过第一次标记之后，会再进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</li></ul><p>代码示例对象一次自我拯救的演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>); FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>从上面的代码中看见，<code>System.gc();</code>触发了垃圾回收器，并在第一次回收过程中调用了<code>finalize()</code>方法，而且在第一次中成功的逃脱了，但是在第二次执行<code>System.gc();</code>触发垃圾回收器后并没有执行<code>finalize()</code>方法，并自救失败。很好的说明了<code>finalize()</code>方法只会执行一次。</p><p>注意：并不建议重写<code>finalize()</code>来进行垃圾回收之前的处理。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 垃圾收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型（六）------ 对象在内存中的存储</title>
      <link href="2021/07/10/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89------%20%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>2021/07/10/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%85%AD%EF%BC%89------%20%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="对象在内存中的存储"><a href="#对象在内存中的存储" class="headerlink" title="对象在内存中的存储"></a>对象在内存中的存储</h3><h4 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h4><h5 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h5><ul><li>最常见的方式<ul><li>new</li><li>变形一: Xxx的静态方法</li><li>变形二: XXXBuilder/XXXFactory的静态方法</li></ul></li><li>Class的newInstance() -------- 反射的方式，只能调用空参构造器。权限操作符必须是public</li><li>Constructor的newInstance(XXX)  -------- 可以调用空参数，带参数的构造器，权限没有要求</li><li>使用clone() -------- 不使用构造器，但是前提必须是实现cloneable接口，重写clone()方法</li><li>使用反序列化 -------- 从文件中，网络中获取对象的二进制字节流</li><li>第三方库Objenesis</li></ul><h5 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h5><p>1、判断对象对应的类是否加载，链接，初始化</p><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出<code>ClassNotFoundException</code>异常，如果找到，则进行类加载，并生成对应的Class类对象 ;</p><p>2、对象内存分配</p><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。 </p><ul><li>如果内存规整<ul><li>指针碰撞：如果内存是规整的，那么虚拟机将采用的是指针碰撞法（<code>Bump The Pointer</code> )来为对象分配内存。 意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。 </li></ul></li><li>如果内存不规则<ul><li>虚拟机需要维护一个列表</li><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为&quot;空闲列表(Free List ) &quot;. </li></ul></li></ul><p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器差否带有压缩整理功能决定。</p><p>3、处理并发安全问题</p><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ul><p>4、初始化分配到的空间</p><p>所有属性设置默认值，保证对象实例字段在不赋值的情况下可以直接使用</p><p>5、设置对象的对象头</p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>6、执行init方法进行初始化</p><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 </p><p>因此一般来说（由字节码中是否跟随有invokespec1r指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>对象内存布局：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" style="zoom:50%;" /><h5 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h5><h6 id="运行时元数据-mark-Word"><a href="#运行时元数据-mark-Word" class="headerlink" title="运行时元数据(mark Word)"></a>运行时元数据(mark Word)</h6><ul><li>哈希值(HashCode)</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><h6 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h6><ul><li>指向类元数据InstanceClass,确定该对象所属的类型</li></ul><p>说明：如果是数组，对象头中还有一块用于记录数组长度的数据（因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小）</p><h5 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h5><p>他是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括父类继承下来的和本身拥有的字段)，存储顺序会 受到虚拟机分配策略参数(<code>-XX:FieldsAllocationStyle</code>参数)和字段在Java源码中定义顺序的影响。</p><p>规则：</p><ul><li>默认分配策略下相同宽度的字段总是被分配到一起；</li><li>满足上一条件的前提下，父类中定义的字段会出现在子类之前</li><li>如果<code>+XX:CompactFields</code>参数值为true (默认为true) :子类的窄变量可能插入到父类变量的空隙之中，节省出一点点空间。</li></ul><h5 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h5><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用。</p><p>原因：<code>HotSpot</code>虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><p>示例：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710094226903.png" alt="image-20210710094226903" style="zoom:50%;" /><h4 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h4><p>Java程序会通过栈上的<code>reference</code>数据来操作堆上的具 体对象。</p><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210706225721035.png" alt="image-20210706225721035" style="zoom:50%;" /><ul><li><p>创建对象的目的就是为了使用它</p></li><li><p>JVM是如何通过栈帧中对象的引用访问到其他内部的对象实例呢?---------定位:通过栈帧上面的reference</p><p>对象访问两种的两种方式：句柄和直接指针两种。</p></li></ul><h6 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h6><p>Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>示意图：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210710100253078.png" alt="image-20210710100253078" style="zoom:50%;" /><p>优点：reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。 </p><p>缺点：访问需要间接性的借用句柄池访问，提高了开销成本，访问速度降低。</p><h6 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h6><p><code>HotSpot</code>虚拟机主要采用了该种方式。</p><p>图示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/image-20210708220713751.png" alt="image-20210708220713751" style="zoom:50%;" /><p>优点：速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>缺点：如果对象在堆中的地址发生了改变（如垃圾收集时常见），那么需要改变Java栈中的引用地址产生开销。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul><li>对象在JVM中是怎么存储的?</li><li>对象头信息里面有哪些东西?</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型（五）------ 执行引擎，本地库接口</title>
      <link href="2021/07/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89------%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8E%A5%E5%8F%A3/"/>
      <url>2021/07/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%EF%BC%89------%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="JVM内存模型（五）-执行引擎，本地库接口"><a href="#JVM内存模型（五）-执行引擎，本地库接口" class="headerlink" title="JVM内存模型（五）------ 执行引擎，本地库接口"></a>JVM内存模型（五）------ 执行引擎，本地库接口</h4><h5 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpeg" style="zoom:67%;" /><h6 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h6><p>将字节码指令解释/编译为对应平台上的本地机器指令,简单来说就是高级语言的翻译, 将高级语言翻译为机器语言。</p><h6 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h6><p>当JAVA虚拟机启动的时候会根据预定义的规范对字节码文件采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的机器指令执行。</p><h6 id="JTI即时编译器"><a href="#JTI即时编译器" class="headerlink" title="JTI即时编译器"></a>JTI即时编译器</h6><p>就是将虚拟机源代码直接编译成和本地机器平台相关的机器语言。</p><p>为什么说Java半解释半编译语言？</p><p>很多时候会说半解释半编译语言就是Java文件编译后形成的.class的解释语言，这样说或许是不对的，其实半解释半编译指的是将解释执行与编译执行二者结合起来进行。</p><h5 id="本地库接口"><a href="#本地库接口" class="headerlink" title="本地库接口"></a>本地库接口</h5><ul><li>什么是本地方法：一个<code>Native method</code>就是一个Java代码调用非Java代码的接口</li><li>本地接口就是融合了不同编程语言提供Java所用，他的初衷是融合C/C++</li><li>注意:标识符<code>native</code>可以与其他的标识符连用用，但是abstract除外</li><li>为什么要使用本地方法？Java有时需要和外面的坏境交互，这时候使用Java语言很难实现，这就是本地方法存在的主要原因</li><li>现状使用本地方法的越来越少，除非是与硬件操作相关的任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中一些常用中间件安装</title>
      <link href="2021/07/05/Linux/docker/Docker%E4%B8%80%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/07/05/Linux/docker/Docker%E4%B8%80%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、MySql"><a href="#1、MySql" class="headerlink" title="1、MySql"></a>1、MySql</h4><ol><li>下载镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:5.7</span><br></pre></td></tr></table></figure><ol start="2"><li>启动镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行</span></span><br><span class="line">sudo docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于配置映射，直接打开文件，修改配置</span></span><br><span class="line">vi /mydata/mysql/conf/my.conf</span><br></pre></td></tr></table></figure><p>将下面内容复制进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 将下面内容复制进去</span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置在docker启动的时候启动</span></span><br><span class="line">docker update mysql --restart=always</span><br></pre></td></tr></table></figure><h4 id="2、Redis"><a href="#2、Redis" class="headerlink" title="2、Redis"></a>2、Redis</h4><ol><li>挂在目录</li></ol><p>如果直接挂载的话docker会以为挂载的<code>redis.conf</code>是一个目录，所以我们先创建一个文件然后再挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在虚拟机中</span></span><br><span class="line">mkdir -p /mydata/redis/conf</span><br><span class="line">touch /mydata/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><ol start="3"><li>启动镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>测试安装情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接进去redis客户端。</span></span><br><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure><ol start="5"><li>修改配置</li></ol><p>默认是不持久化的。在配置文件中输入appendonly yes，就可以aof持久化了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入下面内容</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ol start="6"><li>重启</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置在docker启动的时候启动</span></span><br><span class="line">docker update redis --restart=always</span><br></pre></td></tr></table></figure><h4 id="3、Nginx"><a href="#3、Nginx" class="headerlink" title="3、Nginx"></a>3、Nginx</h4><ol><li>拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.10</span><br></pre></td></tr></table></figure><ol start="2"><li>启动</li></ol><p>随便启动一个nginx实例，只是为了复制出配置，放到docker里作为镜像的统一配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx -d nginx:1.10</span><br></pre></td></tr></table></figure><ol start="3"><li>拷贝配置至外部目录</li></ol><p>先创建一个nginx目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mydata/nginx</span><br></pre></td></tr></table></figure><p>拷贝内部文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container cp /mydata/nginx:/etc/nginx .</span><br><span class="line">mv /mydata/nginx/nginx /mydata/nginx/conf</span><br></pre></td></tr></table></figure><ol start="4"><li>重启</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停掉nginx</span></span><br><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建新的nginx</span></span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置在docker启动的时候启动</span></span><br><span class="line">docker update nginx --restart=always</span><br></pre></td></tr></table></figure><ol start="5"><li>测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/nginx/html/</span><br><span class="line">vim index.html</span><br><span class="line">随便写写</span><br><span class="line">测试 http://192.168.56.10:80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VM内存模型（四）------ 运行时数据区（三）</title>
      <link href="2021/07/01/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2021/07/01/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%9B%9B%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM内存模型（四）-运行时数据区（三）"><a href="#JVM内存模型（四）-运行时数据区（三）" class="headerlink" title="JVM内存模型（四）------ 运行时数据区（三）"></a>JVM内存模型（四）------ 运行时数据区（三）</h3><h4 id="五、本地方法"><a href="#五、本地方法" class="headerlink" title="五、本地方法"></a>五、本地方法</h4><p>方法区是独立于堆的一块内存空间</p><p>栈、堆、方法区相对于对象创建的关系：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E3%80%81%E6%A0%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" style="zoom:90%;" /><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li>方法区与堆一样,是各个线程共享的区域；</li><li>方法区在JVM启动的时候被创建，并且它的实际物理内存空间中和堆一样都可以是不连续的；</li><li>方法区的大小和堆一样是可以选择固定大小或者可扩展的；</li><li>方法区的大小决定了系统可以保存多少个类。如果定义了太多的类,会导致方法区溢出，虚拟机会抛出内存溢出错误；<ul><li><code>java.lang.OutOfMemoryError:Metaspace</code>（JDK8元空间）</li><li><code>java.lang.OutOfMemoryError:PermGen Space</code>（JDK7之前永久代）</li></ul></li><li>关闭虚拟机就会释放这个区域的内存</li></ul><h5 id="2、设置方法区内存大小"><a href="#2、设置方法区内存大小" class="headerlink" title="2、设置方法区内存大小"></a>2、设置方法区内存大小</h5><p>方法区的大小不是固定的，他可以根据需要动态调整</p><h6 id="2-1、JDK7之前"><a href="#2-1、JDK7之前" class="headerlink" title="2.1、JDK7之前"></a>2.1、JDK7之前</h6><p>JDK7之前称之为永久代</p><ul><li>设置永久代初始分配空间         <code>-XX:PermSize</code>（默认20.75M）</li><li>设置永久代最大分配空间        <code> - XX:MaxPermSize</code>（32位默认为64M，64位默认为82M）</li></ul><h6 id="2-2、JDK8之后"><a href="#2-2、JDK8之后" class="headerlink" title="2.2、JDK8之后"></a>2.2、JDK8之后</h6><p>JDK8称之为元空间</p><ul><li>设置初始元空间大小      <code>  -XX:MetaspaceSize</code></li><li>设置最大元空间大小        <code>-XX:MaxMetaspaceSize</code></li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机可能耗尽所有的可用系统内存，然后抛出<code>OOM</code></li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E5%85%83%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E6%9F%A5%E7%9C%8B.png" style="zoom:50%;" /><h5 id="3、方法区存储内容"><a href="#3、方法区存储内容" class="headerlink" title="3、方法区存储内容"></a>3、方法区存储内容</h5><p>《深入理解ava虚拟机》书中对方法区(<code>Method Area</code>)存储的内容如下:它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9.png" style="zoom:50%;" /><h6 id="3-1、类型信息"><a href="#3-1、类型信息" class="headerlink" title="3.1、类型信息"></a>3.1、类型信息</h6><p>对每个加载的类型(类<code>class</code>, 接口<code>interface</code>, 枚举<code>enum</code>，注解<code>annotation</code>) ，jvm必须在方法区中存储以下信息</p><ol><li>这个类型要有完整有效名称(全名=包名.类名)</li><li>这个类型直接父类完整有效名(对于<code>interface</code>或是<code>java .lang.Object</code>,都没有父类)</li><li>这个类型的修饰符(<code>public</code>, <code>abstract</code>,<code> final</code>的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ol><h6 id="3-2、域Feild信息"><a href="#3-2、域Feild信息" class="headerlink" title="3.2、域Feild信息"></a>3.2、域Feild信息</h6><p>JVM必须在方法区中保存类型中的所有域的相关信息以及类的声明顺序</p><p>域的相关信息包括：</p><ul><li>域名称</li><li>域类型</li><li>域修饰符(<code>public</code>,<code> private</code>, <code>protected</code>, <code>static</code>, <code>final</code>, <code>volatile</code>, <code>transient</code>的某个子集)</li></ul><h6 id="3-3、方法（Method）信息"><a href="#3-3、方法（Method）信息" class="headerlink" title="3.3、方法（Method）信息"></a>3.3、方法（Method）信息</h6><p>JVM必须保存方法的以下信息，同域信息一样包括声明顺序</p><ul><li>方法名称</li><li>方法的返回值类型(包括<code>void</code>)</li><li>方法参数的数量和类型(按顺序)</li><li>方法的修饰符(<code>public</code>, <code>private</code>,<code> protected</code>, <code>static</code>, <code>final</code>,<code> synchronize</code>, <code>native</code>, <code>abstract</code>的一 个子集)</li><li>方法的字节码(<code>bytecodes</code>)、 操作数栈， 局部变量表及大小(<code>abstract</code>和<code>native</code>方法除外)</li><li>异常表(<code>abstract</code>和<code>native</code>方法除外)--------每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。</li></ul><h6 id="3-4、non-final的类变量"><a href="#3-4、non-final的类变量" class="headerlink" title="3.4、non-final的类变量"></a>3.4、non-final的类变量</h6><ul><li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p>类变量被类的所有实例共享，即便没有实例也可以访问</p></li></ul><h5 id="4、运行时常量池"><a href="#4、运行时常量池" class="headerlink" title="4、运行时常量池"></a>4、运行时常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含产量池（Constant Pool Table），包含对各种自变量和类型域和方法的符号引用 。</p><h6 id="4-1、常量池存储的数据类型"><a href="#4-1、常量池存储的数据类型" class="headerlink" title="4.1、常量池存储的数据类型"></a>4.1、常量池存储的数据类型</h6><p>几种在常量池内存储的数据类型包括:</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>可以将常量池看成是一张表，虚拟机指令通过这张表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h6 id="4-2、概述"><a href="#4-2、概述" class="headerlink" title="4.2、概述"></a>4.2、概述</h6><ul><li>运行时常量池属于方法区的一部分；</li><li>常量池表----是Class文件的一部分用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放在方法区的运行时常量池中；</li><li>在加载类和接口到虚拟机中后，就会创建对应的运行时常量池</li><li>JVM对以加载的类型(类或者接口)，都维护一个常量池。池中的数据项就像数组项一样，是通过索引访问的。</li><li>当创建类或接口到运行时常量池时,如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM就 会抛出OOM异常。</li></ul><h5 id="5、方法区演进"><a href="#5、方法区演进" class="headerlink" title="5、方法区演进"></a>5、方法区演进</h5><p><strong>注意：</strong>只有HotSpot才有永久代</p><ul><li><code>JDK1.6</code>之前<ul><li>有永久代，静态变量存放在永久代上面</li></ul></li><li><code>JDK1.7</code><ul><li>有永久代，但是逐步的“去永久代”，字符串常量池，静态变量移除，保存在堆中</li></ul></li><li><code>JDK1.8</code><ul><li>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但是字符串常量池，静态变量仍然在堆中</li></ul></li></ul><blockquote><p>为什么要把<code>StringTable</code>进行调整？</p><p><code>JDK1.7</code>将<code>StringTable</code>放到了堆空间中，主要原因是永久代的回收效率很低，在<code>full GC</code>的时候才会被触发，而<code>full GC</code>是老年代空间不足、永久代空间不足的时候才会触发。这就导致了<code>StringTable</code>的回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放在堆里能进行及时的回收.</p></blockquote><h5 id="6、方法区的垃圾回收"><a href="#6、方法区的垃圾回收" class="headerlink" title="6、方法区的垃圾回收"></a>6、方法区的垃圾回收</h5><ul><li>方法区的垃圾收集主要收集两部分内容:常量池中废弃的常量和不再使用的类型</li><li><code>HotSpot</code>虚拟机对常量池回收策略是非常明确的，只要常量池中没有被任何地方引用，就可以被回收</li><li>回收常量与回收Java堆中的对象非常相似</li><li>判断一个常量是否被废弃满足的三个条件<ul><li>该类的所有实例都已经被回收，也就是java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非精心设计的可替换的类加载器的场景，如<code>OSGI</code>, <code>JSP</code>等的重加载等，否则通常很难达成</li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是 和对象一样，没有引用了就必然会回收。</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h5 id="7、常见面试题"><a href="#7、常见面试题" class="headerlink" title="7、常见面试题"></a>7、常见面试题</h5><ul><li>说一下JVM的内存模型，有哪些区?分别干什么的?</li><li>java8中内存分代的改进?</li><li>JVM内存分为哪几个区?每个区的作用是什么?</li><li>JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么要有两个<code>survivor</code>区?</li><li><code>Eden</code>和<code>Survivor</code>的比例分配?</li><li>JVM内存分区，为什么要有新生代和老年代?</li><li>Java的内存分区?</li><li>讲讲JVM的运行时数据区?</li><li>什么时候对象会进入老年代?</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型（三）------ 运行时数据区（二）</title>
      <link href="2021/06/25/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2021/06/25/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM内存模型（三）-运行时数据区（二）"><a href="#JVM内存模型（三）-运行时数据区（二）" class="headerlink" title="JVM内存模型（三）------ 运行时数据区（二）"></a>JVM内存模型（三）------ 运行时数据区（二）</h3><h4 id="四、堆"><a href="#四、堆" class="headerlink" title="四、堆"></a>四、堆</h4><p>Java堆（<code>Java Heap</code>）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。在《Java虚拟机规范》中对Java堆的描述是：所有 的对象实例以及数组都应当在堆上分配。</p><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li>一个JVM实例只存在一个堆内存， 堆是Java内存管理核心区城</li><li>Java堆在JVM创建的时候被创建，其空间大小也就被确定（堆内存的大小是可以调节的）</li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但逻辑上应该被视为连续的</li><li>所有线程共享Java堆(这里还可以划分出线程私有的缓冲区TLAB)</li><li>《Java虚拟机规范》中对堆的描述是:所有的对象实例以及数组都应该运行时分配到堆上（注意:只能说是几乎所有的对象实例都在这里分配内存-要从实际使用角度看，具体描述看第8点）</li><li>数组和对象可能永远不会存储在栈上（因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置）</li><li>在方法结束之后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li><li>堆，是GC执行垃圾回收的重点区域</li></ul><h5 id="2、构成"><a href="#2、构成" class="headerlink" title="2、构成"></a>2、构成</h5><h6 id="2-1、jdk7"><a href="#2-1、jdk7" class="headerlink" title="2.1、jdk7"></a>2.1、jdk7</h6><ul><li>新生代(Young Generation Space) +老年代(Tenure generation space)+永久区(Permanent space)</li><li>新生代又分为伊甸园区(Eden)+s1(Survlvor1)+s2(Survor2)</li></ul><h6 id="2-2、jdk8"><a href="#2-2、jdk8" class="headerlink" title="2.2、jdk8"></a>2.2、jdk8</h6><ul><li>新生代(Young Generation Space) +老年代(Tenure generation space)+元空间(Meta Space)</li><li>新生代又分为伊利园区(Eden)+s1(Survlvor1)+s2(Survor2)</li></ul><h5 id="3、构成详述"><a href="#3、构成详述" class="headerlink" title="3、构成详述"></a>3、构成详述</h5><p>Java堆进一步分可以分为年轻代和老年代，年轻代又可以分为伊甸园区（Eden），幸存者0（Survivor0）和幸存者1（Survivor1）空间，有时候也叫from区和to区。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E5%A0%86%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png" style="zoom:50%;" /><h6 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h6><p>存储在JVM中的Java对象可以划分为两大类：一类是生命周期较短的瞬时对象，这些对象的创建和消亡都非常迅速；另一类是生命周期非常长，在某些情况下能够与JVM生命周期保持一致。</p><p>区间所占比例：</p><ul><li>默认：<code>-XX:NewRatio=2</code>,也就是新生代占一份，老年代占两份，新生代占整区的<code>1/3</code></li><li>可以通过<code>-XX:NewRatio=4</code>进行修改，表示为新生代占1，老年代占4，新生代占整区的1/5</li></ul><ol><li>新生代</li></ol><p>伊甸园区，几乎所有的对象都是在<code>Eden</code>区new出来的，新生代中80%的対象都是朝生夕死，绝大多数的Java对象销毁都在新生代中进行，<strong>可以使用<code>-Xmn</code>设置新生代的最大内存大小，但是这一参数一般使用默人值就行。</strong></p><ol start="2"><li>老年代</li></ol><p>老年代主要用于存储生命周期特别长的对象。</p><h6 id="3-2、对象在内存空间的分配过程"><a href="#3-2、对象在内存空间的分配过程" class="headerlink" title="3.2、对象在内存空间的分配过程"></a>3.2、对象在内存空间的分配过程</h6><ul><li>new对象的时候先放入伊甸园区(<code>Eden</code>) ，此区有大小限制</li><li>当伊甸园区填满的时候，程序又需要创建对象，JVM垃圾回收器会对伊甸园区进行垃圾回收(<code>Minor GC</code>) ,将伊甸园区中不再被其他对象引用的对象迸行摧毁，再加载新的対象到伊甸园区</li><li>然后将伊甸园区剩余的对象移动到幸存者0区，幸存者1区是空的</li><li>如果继续有对象在伊甸园区创建然后伊甸园区存不下就再次触发垃圾回收，此时对伊甸园区内进行回收的同时还对上次幸存下来的放到幸存者0区的进行垃圾收集，接下来将0区存活下来的移动到1区，伊甸园中存活下来的也放入幸存者1区。0区是空的。</li><li>如果再次进行垃圾回收，此时会重新放入幸存者0区，接着再去幸存者1区</li><li>毎次在幸存者去循坏，毎跳动一次, age加1, 默人当达到15次的时候，会将对象放入养老区（age默认次数可以通过修改<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code>来设置）</li><li>在养老区，相当悠闲，当养老区不足的时候，再次触发<code>GC:Major GC</code>,进行养老区的内存清理</li><li>如果养老区执行了<code>Major GC</code>之后依然发现无法对对象迸行保存，就发生<code>OOM</code>异常（<code>java.lang.OutOfMemoryErorjava heap space</code>）</li></ul><p>总结：针对于幸存者<code>s0</code>和<code>s1</code>区总结:复制之后有交换，堆空谁是to。关于垃圾回收:频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空同收集</p><h6 id="3-3、问题"><a href="#3-3、问题" class="headerlink" title="3.3、问题"></a>3.3、问题</h6><ol><li>为什么需要把java堆分代?不分代就不能正常工作了么?<br>不同对象的生命周期不同，大约有70%-90%的对象是临时对象，因此，通过分代，将对象通过生命周期大小过滤，针对不同的区域采用不同的垃圾收集方式，可以很大的提高GC收集性能。其实不分代完全可以，分代的唯一的理由就是优化GC性能</li></ol><h6 id="3-4、内存分配策略"><a href="#3-4、内存分配策略" class="headerlink" title="3.4、内存分配策略"></a>3.4、内存分配策略</h6><p>正常情况，对象在堆中生命周期为：如果<code>Eden</code>出生并经过<code>MinorGC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象的年龄设置为1，对象在<code>Survivor</code>中每熬过一次<code>Minor GC</code>，年龄就增加1，当年龄达到一定程度（默认15岁）时，就会被晋升到老年代中。 </p><p>  对象晋升老年代年龄阈值，可以通过：<code>-XX:MaxTenuringThreshold</code>来设置 </p><p>分配策略：</p><ul><li>优先分配到<code>Eden</code>区</li><li>大对象直接分配到老年代(所以要尽量避免程序中出现大对象)</li><li>长期存活的对象分配到老年代(正常情况下计算年龄大于15进入老年代)</li><li>动态年龄判断(如果<code>Survivor</code>区间相同年龄的所有对象大小总和大于<code>Survivor</code>空间的一般，年龄大于或者等于该年龄对象的可以直接进入老年代，无需等到<code>Max TenuringThreshold</code>中的年龄要求</li></ul><p>空间分配担保：<code>-XX:HandlePromotionFailure</code></p><h5 id="4、堆内存大小的设置"><a href="#4、堆内存大小的设置" class="headerlink" title="4、堆内存大小的设置"></a>4、堆内存大小的设置</h5><p>堆大小一般情况JVM启动的时候就已经设定好了：</p><ul><li><code>-Xms</code><ul><li>作用：用于表示堆的起始内存，等价于<code>-XX:InitalHeapSize</code>。用于设置堆空间(年轻代+老年代)的初始内存大小</li><li>参数说明：X：JVM运行参数     ms：memory start</li></ul></li><li><code>-Xmx</code><ul><li>作用：表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code>.用于设置堆空间(年轻代+老年代)的最大内存大小</li></ul></li><li>查看设定参数：<ul><li>方式一：1.<code>jps</code>获得进程id    2. <code>jstat -gc 进程id</code></li><li>方式二：启动参数上面添加：<code>-XX:+PrintGCDetails</code></li></ul></li><li>默认设置大小：<ul><li>初始内存大小     物理电脑内存大小/64</li><li>最大内存大小     物理电脑内存大小/4</li></ul></li></ul><p>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，就会抛出<code>OutOMemoryError</code>异常<br>我们通常会將<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆之后不需要重新分隔计算堆区的大小，从而提高性能。</p><h5 id="5、堆中垃圾回收概述"><a href="#5、堆中垃圾回收概述" class="headerlink" title="5、堆中垃圾回收概述"></a>5、堆中垃圾回收概述</h5><p>针对HotSpot VM的实现，它里面的GC安装回收区域分为两大种类型，一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><h6 id="5-1、部分垃圾回收"><a href="#5-1、部分垃圾回收" class="headerlink" title="5.1、部分垃圾回收"></a>5.1、部分垃圾回收</h6><ol><li>新生代收集（<code>Minor GC</code>/<code>Youn GC</code>）</li></ol><ul><li><p>只是新生代垃圾回收</p></li><li><p>触发机制：</p><p>1）当年轻代空间不足时，就会触发<code>Minor GC</code>,这里的满指的是<code>Eden</code>代满，**Survivor满不会引发GC **(每次<code>Minor GC</code>会清理年轻代的内存)</p><p>2）因为Java对象大多具备朝生夕灭的特性，所以Minor GC执行会非常频繁,一般回收速度也比较快</p><p>3）<code>Minor GC</code>会引发<code>STW</code>,暂停其他用户的线程，等垃圾回收结束，用户线程才会恢复执行（<code>STW</code>----<code>stop the word</code>,指的是暂停用户现在执行的线程，执行垃圾回收的线程）</p></li></ul><p>回收过程：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/Minor GC.png" style="zoom:35%;" /><ol start="2"><li>老年代收集（<code>Minor GC</code>/<code>old GC</code>）</li></ol><ul><li><p>只是老年代的垃圾收集</p></li><li><p>特点：</p><p>1）出现<code>Major GC</code>至少伴随一次<code>Minor GC</code>（也就是老年代不足的时候，会先尝试触发<code>Minor GC</code>，之后还不足，就会触发<code>Major GC</code>）<br>2）<code>Major GC</code>一般比<code>Minor GC</code>慢10倍以上，<code>STW</code>的时间会更长<br>3）如果<code>Major GC</code>后，内存还不足，就报<code>OOM</code></p></li></ul><p>注意：只有<code>CMS GC</code>会单独回收老年代行为；很多时候<code>Major GC</code>会和<code>Full GC</code>混合使用，需要具体分辨是老年代回收还是整堆回收</p><ol start="3"><li>混合收集（<code>Mixed GC</code>）</li></ol><ul><li>收集整个新生代以及部分老年代的垃圾收集(目前只有<code>G1 GC</code>有这种行为)</li></ul><h6 id="5-2、整堆收集"><a href="#5-2、整堆收集" class="headerlink" title="5.2、整堆收集"></a>5.2、整堆收集</h6><p><code>Full Gc</code>：整个Java堆和方法区的垃圾收集</p><p>触发机制：</p><ul><li>调用了<code>System.gc()</code>时，系统会建议执行<code>Full GC</code>，但是不是必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过<code>Minor GC</code>之后进入老年代的平均大小大于老年代的可用内存</li><li>有<code>Eden</code>区、<code>survivor space0 </code>(<code>From Space</code>)区向<code>survivor Space1</code>(<code>To Space</code>)区复制时，则把该对象转存到老年代，且老年代<br>的可用内存小于该对象内存</li></ul><p>**说明: ** <code>full GC</code>是开发或者调优中尽量避免的，这样暂停时间会短一些</p><h6 id="5-3、查看垃圾收集的参数"><a href="#5-3、查看垃圾收集的参数" class="headerlink" title="5.3、查看垃圾收集的参数"></a>5.3、查看垃圾收集的参数</h6><p>启动参数内添加：<code>-Xms600m -Xmx600m -XX:+PrintGCDetails</code></p><p>可以输出一些垃圾收集的信息。</p><h5 id="6、TLAB"><a href="#6、TLAB" class="headerlink" title="6、TLAB"></a>6、TLAB</h5><h6 id="6-1、什么是TLAB"><a href="#6-1、什么是TLAB" class="headerlink" title="6.1、什么是TLAB"></a>6.1、什么是TLAB</h6><p>1）从内存模型而不是垃圾收集的角度，对<code>Eden</code>区进行划分，<code>JVM</code>为每个线程分配一个私有缓存区域，他包含在<code>Eden</code>区中<br>2）多线程同时分配内存时，使用<code>TLAB</code>可以避免一系列的非线程安全问题</p><p>简单来说：也就是由于堆是内存共享的，所以为了解决线程安全问题，为每个线程在堆中创建一个私有的内存空间，就是TLAB</p><h6 id="6-2、为什么要使用TLAB"><a href="#6-2、为什么要使用TLAB" class="headerlink" title="6.2、为什么要使用TLAB"></a>6.2、为什么要使用TLAB</h6><p>1）堆是线程共享区域，任何线程都可以访问到堆中的共享数据<br>2）由于对象的实例创建在JVM中非常频繁，因此并发环境下从堆中划分内存空间是线程不安全的<br>3）为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p><p>简单来说：就是堆是属于内存共享区域，因此针对于不同的线程，可以使用同一对象地址，比如一种情况，a线程中要创建user对象，b线程同一时间也要创建user对象，而堆空间不是线程安全的，就又可能a线程和b线程拿到同一个user对象，这样也就会导致产生线程安全问题，如果不存在TLAB的话，我们就需要对创建对象的时候使用加锁机制，就会导致性能降低。</p><h6 id="6-3、说明"><a href="#6-3、说明" class="headerlink" title="6.3、说明"></a>6.3、说明</h6><p>1）尽管不是所有对象实例都能够在TLAB中成功分配内存，但是JVM确实将TLAB作为内存奉陪首选<br>2）可以通过<code>-XX:UseTLAB</code>来设置是否开启TLAB<br>3）默认情况下TLAB空间的内存非常小，仅占整个Eden区的1%，可以通过设置<code>-XX:TLABWasteTargetParcent</code>来设置百分比<br>4）一旦对象在TLAB中分配内存失败，JVM就会尝试使用加锁机制保障数据操作的原子性,从而直接从Eden空间中分配内存</p><h5 id="7、堆中常用参数设置"><a href="#7、堆中常用参数设置" class="headerlink" title="7、堆中常用参数设置"></a>7、堆中常用参数设置</h5><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官网地址</a></p><ul><li>-XX:+PrintFlagsInitial    查看所以参数的默认初始值</li><li>-XX:+PrintFlagsFinal     查看所有参数的最终值(可能会存在修改，不再是初始值)</li><li>-Xms    初始堆空间内存(默认为系统空间的1/64)</li><li>-Xmx    最大堆内存空间(默认为物理内存的1/4)</li><li>-Xmn    设置新生代的大小(初始值及最大值)</li><li>-XX:NewRatio   配置新生代与老年代的堆结构占比</li><li>-XX:SurvivorRatio   设置新生代中Eden区和S0/S1的比例</li><li>-XX:MaxTenuringThreshold   设置新生代垃圾的最大年龄</li><li>-XX:+PrintGCDetails   输出详细的GC处理日志</li><li>-XX:+PrintGC   打印简单信息</li><li>-verbose:gc      打印简单信息</li><li>-XX:HandlePromotionFailure   是否设置空间分配担保</li></ul><h5 id="8、堆是内存分配的唯一选择吗？"><a href="#8、堆是内存分配的唯一选择吗？" class="headerlink" title="8、堆是内存分配的唯一选择吗？"></a>8、堆是内存分配的唯一选择吗？</h5><p>随着JIT编译期的发展与逃逸技术的逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙变化，导致所有对象分配到堆上面也不是那么绝对了。<br>在虚拟机中，对象是在java堆中分配内存的，这是一个普遍常识，但是有一种特殊情况， 如果经过逃逸分析后发现，一个对象如果并没有逃逸出方法的话，那么可能就会优化在栈上分配，这样就无需在堆上分配内存，也无需进行垃圾回收，也是常见的堆外存储技术。</p><h6 id="8-1、概述"><a href="#8-1、概述" class="headerlink" title="8.1、概述"></a>8.1、概述</h6><ul><li>如何将堆中内存分配到栈，需要用到逃逸分析</li><li>这是一种有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</li><li>通过逃逸分析, Hotspot虚拟机可以推断出一个对象的作用域，从而进一步推断出是否需要将这个对象分配到堆上</li><li>逃逸分析的基本行为其实就是分析对象的动态作用域<ul><li>如果一个对象在一个方法中被定义后， 而对象只是在该方法内部使用，则认为没有发生逃逸</li><li>如果一个对象在方法中被定义，在外部方法中有被引用，就认为逃逸了</li></ul></li></ul><p>逃逸示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法认为发生了逃逸</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer() ;</span><br><span class="line">  sb.append(s1) ;</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未逃逸示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法认为发生了逃逸</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer() ;</span><br><span class="line">  sb.append(s1) ;</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="8-2、逃逸发生的几种情况"><a href="#8-2、逃逸发生的几种情况" class="headerlink" title="8.2、逃逸发生的几种情况"></a>8.2、逃逸发生的几种情况</h6><p>逃逸发生情况分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>  EscapeAnalysis  obj ;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法返回 EscapeAnalysis 的对象，发生了逃逸</span></span><br><span class="line"><span class="comment">   *  <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  EscapeAnalysis  <span class="title">getInstance</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  obj  ==  <span class="keyword">null</span>  ?  <span class="keyword">new</span>  EscapeAnalysis() :  obj ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   *  为成员变量赋值，发生了逃逸</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setObj</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj  =  <span class="keyword">new</span>  EscapeAnalysis() ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  对象的作用域仅仅在方法的内部，没有发生逃逸</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">userEscapeAnalysis</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    EscapeAnalysis e =  <span class="keyword">new</span>  EscapeAnalysis() ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  引用成员变量的值 , 发生了逃逸</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">userEscapeAnalysis1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    EscapeAnalysis e = getInstance() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="8-3、逃逸参数设置"><a href="#8-3、逃逸参数设置" class="headerlink" title="8.3、逃逸参数设置"></a>8.3、逃逸参数设置</h6><ul><li>在<code>JDK 6u23</code>版本之后，<code>HotSpot</code>默认就开启了逃逸分析</li><li><code>-XX:+DoEscapeAnalysis</code>显示开启逃逸分析</li><li><code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果</li></ul><h6 id="8-4、逃逸分析代码优化"><a href="#8-4、逃逸分析代码优化" class="headerlink" title="8.4、逃逸分析代码优化"></a>8.4、逃逸分析代码优化</h6><ul><li>栈上分配（将堆分配转化为栈分配。一个对象如果在子程序中被分配，要么指向该对象的指针永远不会发生逃逸，对象分配可能是栈上分配时候的候选，而不是堆上面分配）</li><li>同步省略（如果一个对象发现只能从一个线程中被访问到，那么对于对这个对象的操作可以不考虑同步）</li></ul><p>如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Object o = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中会对<code>o</code>这个对象进行加锁，但是<code>o</code>对象生命周期至在<code>f()</code>方法中，并不会被其他线程所访问到，所以在<code>JIT</code>编译阶段就会被又划掉。优化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Object o = <span class="keyword">new</span> Object();</span><br><span class="line">  System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>标量替换（有些时候一个对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的（或者全部）都可以不存储在内存，而是存储在CPU寄存器上面）</p><p><code>-XX:+ EliminateAllocations </code>开启标量替换，允许对象打撒分配到栈上</p><p><strong>标量(Scalar) ：</strong>指的是一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p><strong>聚合量（Aggregate）：</strong>相对的，那么还可以继续分解的数据就叫做聚合量，如Java对象就属于聚合量，因为他可以分解成其他聚合量和标量。</p><p>在<code>JIT</code>阶段，如果经过逃逸分析，如果发现一个对象不会被外界访问到的话，那么经过<code>JIT</code>优化，就会把这个对象拆解为若干个其中包含若干个成员变量来代替。这个过程就叫做<strong>标量替换</strong>。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  alloc() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Point point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  System. out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码通过标量替换后就会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">  System. out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢?就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br><strong>标量替换为栈上分配提供了很好的基础。</strong></p></li></ul><h6 id="8-5、逃逸分析说明"><a href="#8-5、逃逸分析说明" class="headerlink" title="8.5、逃逸分析说明"></a>8.5、逃逸分析说明</h6><p>逃逸分析通过多年发展，至今仍然不成熟。</p><ul><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析，这其实也是一个相对耗时的过程。</strong></li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li><li>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论:对象实例都是分配在堆上。</li></ul><h5 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h5><ul><li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这生产，引用，绝大多数的对象在这里被垃圾回收器收集,结束生命。</li><li>老年代存放生命周期长的对象，通常都是从survivor区域中筛选拷贝过来的Java对象，当然也有特殊情况，我们知道普通的对象会被分配到TLAB上面，如果对象较大，JVM试图分配到Eden去中的其他位置,如果对象太大以至于无法在新生代中找到足够长的连续存储空间，JVM会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代的行为被称为<code>Manor GC</code>。当GC发生在老年代则被称为<code>Major GC</code>或者<code>Full GC</code>，一<br>般的，<code>Minor GC</code>的发送频率要比<code>Major GC</code>高的很多，即老年代中垃圾回收的频率大大低于年轻代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型（二）------ 运行时数据区（一）</title>
      <link href="2021/06/20/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2021/06/20/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89------%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM内存模型（二）-运行时数据区（一）"><a href="#JVM内存模型（二）-运行时数据区（一）" class="headerlink" title="JVM内存模型（二）------ 运行时数据区（一）"></a>JVM内存模型（二）------ 运行时数据区（一）</h3><p>Java虚拟机定义了若千种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" style="zoom:50%;" /><h4 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h4><p>程序计数器(<code>Program Counter Register</code>)：较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><h5 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h5><ul><li>他是一块很小的空间，小到几乎可以忽略不计</li><li>在JVM规范中，每个线程都会有自己的程序计数器（线程私有）</li><li>程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器就是通过改变这个程序计数器的值来选取下一条需要执行的字节码指令（如果是正在执行本地的<code>native</code>方法，那么计数器对应的值为空（<code>undefined</code>））</li><li>java虚拟机规范中<strong>唯一</strong>没有规定任何<code>OOM</code>（<code>OutOfMemoryError</code>）</li></ul><h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><p>PC寄存器是用来存储下一条指令的地址，也就是即将要执行的指令代码，由执行引擎读取下一条指令,注意（如果是正在执行本地的<code>native</code>方法，那么计数器对应的值为空（<code>undefined</code>））</p><h5 id="3、问题"><a href="#3、问题" class="headerlink" title="3、问题"></a>3、问题</h5><ol><li>使用PC寄存器存储的字节码指令有何作用？为什么使用PC寄存器存储当前线程的地址？</li></ol><p>因为PC寄存器要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的来明确下一条该执行什么样的字节码指令。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/PC%E5%AF%84%E5%AD%98%E5%99%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%9B%BE.png" style="zoom:50%;" /><p>简单来说，就是一个主内存中可以有多个线程，线程处于并发状态，不断抢夺CPU资源，某一个时间段只可能执行一个线程中的方法，可能开始是线程1在执行，执行到了第5行，线程2抢占了主内存，线程1就停了，当线程2执行结束，回到线程1，如果没有PC寄存器记录执行到的位置，那么将不知道从哪儿开始继续执行。同理可得为什么PC寄存器为线程私有。如果线程共享，那么其他当前线程停止，进入其他线程，那么就会改变PC寄存器的值，回来执行线程1的时候也就不会从上次结束的地方开始。</p><h4 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h4><p>俗话说的好，<strong>栈管运行，堆管存储</strong>。早期也叫Java栈，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(<code>Stack Frame</code>)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h5 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h5><ul><li>每个线程对应一个虚拟机栈，内部保存着一个个栈帧，对应一次次方法调用</li><li>同PC寄存器一样属于线程私有的</li><li>生命周期与线程一致</li><li>一个快速有效的分配存储方式，速度仅次于程序计数器</li><li>JVM对应的Java栈的方式只有两个（方法执行入栈，执行结束出栈）</li><li><strong>对栈来说不存在垃圾回收问题</strong></li><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常</li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常</li></ul><h5 id="2、作用-1"><a href="#2、作用-1" class="headerlink" title="2、作用"></a>2、作用</h5><p>主管Java程序运行，内部包含的局部变量表存放了编译期可知的</p><ol><li>各种Java虚拟机基本数据类型(boolean、byte、char、short、int、 float、long、double)、</li><li>对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)</li><li>returnAddress 类型(指向了一条字节码指令的地址)</li></ol><h5 id="3、问题-1"><a href="#3、问题-1" class="headerlink" title="3、问题"></a>3、问题</h5><ol><li>栈的大小是动态的还是固定不变的？</li></ol><p>由特点的最后两条看出来是固定不变的</p><ol start="2"><li>设置栈的内存大小</li></ol><p>通过-Xss参数设置线程最大栈空间，栈的大小决定了函数调用可达的最大深度</p><h5 id="4、构成"><a href="#4、构成" class="headerlink" title="4、构成"></a>4、构成</h5><p>每个线程都有自己的栈，栈中的数据都是以栈帧的形式存在的，线程中执行的每个方法都各自对应一个栈帧，栈帧是一个内存区，一个数据集，维护着每个方法执行过程中各种数据集。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" style="zoom:50%;" /><h6 id="1）、栈帧执行原理"><a href="#1）、栈帧执行原理" class="headerlink" title="1）、栈帧执行原理"></a>1）、栈帧执行原理</h6><ol><li>JVM直接对栈的操作只有两个，就是栈帧的压栈和出栈，遵循先进后出，后进先出的原则；</li><li>在一条活动的线程上，只会有一条活动的栈帧，即当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为当前栈帧(<code>CurrentFrame</code>) ，与当前栈帧对应的方法就是当前方法(<code>CurrentMethod</code>)， 定义这个方法的类就是当前类(<code>Current Class</code>)</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作；</li><li>如果该方法中调用其他方法，对应新的栈帧就会被创建出来，放在栈的顶端，成为新的当前帧帧；</li><li>不同线程中存在的栈帧不允许存在相互引用，即不允许一个线程中的栈帧调用另外一个线程的栈帧；</li><li>如果一个方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧成为当前栈帧；</li><li>Java方法有两种返回函数的方法，一 种是正常的函数返回，使用<code>return</code>指令， 另外-种是抛出异常，不管是哪种方式，都会导致栈帧被弹出。</li></ol><h6 id="2）、栈帧构成"><a href="#2）、栈帧构成" class="headerlink" title="2）、栈帧构成"></a>2）、栈帧构成</h6><ol><li>局部变量表</li></ol><ul><li>定义一个数字数组，主要用于存储方法参数和定义在方法体内部的局部变量，这些数据类型包括各种基本数据类型，对象引用，以及返回值地址</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li>局部变量表所需要的大小是在编译器就确定下来的，并保存在方法的<code>Code</code>属性的<code>maximum local variables</code>数据项中，在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定的，一般来说，栈的大小越大，方法调用次数越多</li><li>局部变量表中的数据只有在当前方法调用中有效，当方法调用结束后，会伴随着方法栈帧的<br>销毁，局部变量表也会随之销毁</li><li>局部变量表中的变量是垃圾回收的根节点，只要被局部变量表中直接或者间接引用的对象都不会被回收</li></ul><ol start="2"><li>操作数栈</li></ol><ul><li><p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建，这时候这个方法的操作数栈是空的</p></li><li><p>每一个操作数栈都会有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就被定义好了</p></li><li><p>栈中任何一个元素都可以是任意的Java数据类型: 32bit的类型 占用一个栈深度单位，64bit占用两个栈单位深度</p></li><li><p>操作数栈使用的是数组来模拟，但是并非采用索引的方式来进行数据访问，而是通过标准的入栈出栈完成一次数据访问</p></li><li><p>某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈，使用他们后再把结果压入栈。比如：执行复制、交换，求和等操作</p></li><li><p>如果被调用的方法带有返回值的话，其放回值将会被压入当前栈帧的操作数栈中 ，并跟新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p></li></ul><ol start="3"><li>动态链接</li></ol><p>也可以称为 指向运行时常量池的方法引用 </p><ul><li>每一个栈帧内部都包含一个运行时常量池中该栈帧所属方法的引用，支持实现当前代码能够实现动态链接。比如: invokedynamic</li><li>java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用，保存在Class文件的常量池中,比如:描述-一个方法调用另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接作用就是为了将这些符号引用转化为调用方法的直接引用</li><li>为什么要有常量池呢？是为了提供一些符号和常量，便于指令识别</li></ul><p>方法调用分为两种：</p><ul><li>静态链接：目标在编译期可知，运行期间不变（如方法传入的是类，在调用的时候直接知道那个具体类型，故使用静态链接）</li><li>动态链接：被调用的方法在编译期间无法确定下来（如方法中传入的是个接口，所以编译器无法预知传入的参数的具体类型，故使用的是动态链接）</li></ul><ol start="4"><li>返回值地址</li></ol><p>作用：存放调用该方法的PC寄存器的值</p><p>一个方法的结束有两种方式：1、正常执行   2、出现为处理的异常，非正常退出</p><p>无论哪种方式退出，在方法退出后都返回到该方法被调用的地方，方法正常退出时，调用PC寄存器的值作为返回值地址，即调用该方法的指令的下一条指令地址。 而通过异常退出的，返回值是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><ol start="5"><li>一些附加信息</li></ol><p>携带与java虚拟机实现相关的些附加信息，例如对程序调试提供的支持</p><p>这些数据类型在局部变量表中的存储空间以局部变量槽(<code>Slot</code>)来表示，其中64位长度的<code>long</code>和 <code>double</code>类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h5 id="5、常见面试题"><a href="#5、常见面试题" class="headerlink" title="5、常见面试题"></a>5、常见面试题</h5><ol><li>举例说明栈溢出情况？StackOverflowError。  可以通过-Xss设置栈的大小</li><li>调整栈的大小能否保证不出现栈溢出？不能</li><li>分配到栈的内存越大越好吗？不是</li><li>垃圾回收是否会涉及到虚拟机栈？不会</li></ol><h4 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h4><p>虚拟机栈是用于管理java方法调用，而本地方法栈主要是用于负责本地方法的调用。</p><h5 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h5><ul><li>线程私有</li><li>本地方法使用的是C/C++或者是其他类型的语言</li><li>具体做法是native method stack中登记了native方法，在执行引擎时加载本地方法库</li><li>运行被实现为固定的或者可动态的扩展内存大小。1.如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将<br>会抛出一个stackoverlowEror异常。2.如果本地方法栈可以动态扩展，井且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虛拟机将会抛出一个outofMemoryError异常。</li><li>当一个线程调用一个本地方法的时候，他就进入一个全新的并且不受虚拟机限制的空间，他和虚拟机具有相同的操作权限。1.本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，2.他甚至可以本地处理器的寄存器，3.可以直接从本地内存的堆中分配任意数量的内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型（一） ------  类加载子系统</title>
      <link href="2021/06/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89------%20%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/06/06/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89------%20%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JVM内存模型（一）-类加载子系统"><a href="#JVM内存模型（一）-类加载子系统" class="headerlink" title="JVM内存模型（一）------  类加载子系统"></a>JVM内存模型（一）------  类加载子系统</h3><blockquote><p>本系统主要是按照常用的HotSpot虚拟机来讲述的</p></blockquote><p>JVM内存模型如下，本系列就是按照下图进行研究的：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" style="zoom:60%;" /><h4 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h4><p>1、类加载子系统负责从文件系统或者是网络中加载Class文件，Class文件在文件开头有特定的文件标识；</p><p>2、<code>ClassLoader</code>只是负责Class文件加载，至于他是否可以运行，则由<code>ExecuteEngine</code>（执行引擎）决定；</p><p>3、类加载的信息通过<code>ClassLoader</code>加载了之后，类的信息会被加载到成为方法区的内存空间。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/591BECE2-7538-4790-A29B-E481DD16D481.png" style="zoom:50%;" /><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><h6 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h6><ul><li>通过类的全限类名定义获取此类的二进制字节流</li><li>将这个字节流所代表的二进制存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类<code>java.lang.Class</code>对象，作为方法区这个类的各种数据访问入口。</li></ul><h6 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h6><ul><li>验证（Verification）<ul><li>保证Class文件的字节流中包含的信息符合当前虚拟机的要求，保证加载类的正确性，不会危及虚拟机的自身安全</li></ul></li><li>准备（Preparation）<ul><li>为类变量分配内存并设置该类变量的默认初始值，即零值。</li><li>这里不包含final修饰的static值 ，因为final在编译的时候就被分配了</li><li>这里不会为实例变量分配初始化 ，类变量会分配到方法区中，而实例变量会随着对象一起分配到Java堆中。</li></ul></li><li>解析（Resolution）<ul><li>将常量池内的符号引用转化为直接引用的过程</li></ul></li></ul><h6 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h6><ul><li>初始化阶段就是执行类构造方法<clinit>()的过程。 </li><li>该方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来。</li><li><clinit>()方法不同于类的构造器 </li><li>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经加载完毕。</li><li>虚拟机必须保证一个类的<clinit>()方法在多线程环境下同步加锁执行</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>主要分为两类，第一类就一个，引导类加载器（<code>BootstrapClassLoader</code>）,第二类为所有派生于抽象类<code>ClassLoader</code>的类加载器，被称之为自定义类加载器。</p><p>类加载器工作流程：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" style="zoom:70%;" /><h5 id="引导类加载器（BootStrapClassLoader）"><a href="#引导类加载器（BootStrapClassLoader）" class="headerlink" title="引导类加载器（BootStrapClassLoader）"></a>引导类加载器（<code>BootStrapClassLoader</code>）</h5><ul><li>使用C/C++语言实现的，嵌套在JVM内部；</li><li>主要用于加载Java的核心类库</li><li>并不继承与<code>java.lang.ClassLoader</code>,没有父加载器</li><li>出于安全考虑，<code>Bootstrap</code>类加载器只会加载包名为<code>java,javax,sun</code>等开头的类。</li></ul><p>该类加载器主要加载的位置有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">  Stream.of(urLs).forEach(e-&gt; System.out.println(e.toExternalForm()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------输出BootStrapClassLoad加载器加载的位置</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/classes</span><br></pre></td></tr></table></figure><h5 id="自定义类加载器（User-Defined-ClassLoader）"><a href="#自定义类加载器（User-Defined-ClassLoader）" class="headerlink" title="自定义类加载器（User Defined ClassLoader）"></a>自定义类加载器（<code>User Defined ClassLoader</code>）</h5><p>自定义类加载器都是派生于<code>ClassLoader</code>接口：<code>sun.misc.Launcher</code>。他是java虚拟机的一个入口应用，自定义类加载器位于内部作为一个内部类在使用。</p><h6 id="虚拟机自带的类加载器"><a href="#虚拟机自带的类加载器" class="headerlink" title="虚拟机自带的类加载器"></a>虚拟机自带的类加载器</h6><ol><li>扩展类加载器（<code>ExtClassLoader</code>）</li></ol><ul><li>java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现;</li><li>派生于<code>ClassLoader</code></li><li>父类加载器为启动类加载器</li></ul><p>扩展类加载器主要加载的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String property = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">  Stream.of(property.split(<span class="string">&quot;:&quot;</span>)).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------输出ExtClassLoad加载器加载的位置</span><br><span class="line">/Users/babyshi/Library/Java/Extensions</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_281</span>.jdk/Contents/Home/jre/lib/ext</span><br><span class="line">/Library/Java/Extensions</span><br><span class="line">/Network/Library/Java/Extensions</span><br><span class="line">/System/Library/Java/Extensions</span><br><span class="line">/usr/lib/java</span><br></pre></td></tr></table></figure><ol start="2"><li>应用程序类加载器（<code>AppClassLoader</code>）</li></ol><ul><li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现;</li><li>派生于ClassLoader;</li><li>父类为扩展类加载器;</li><li>他负责加载环境变量<code>classpath</code>或者系统属性，<code>java.class.path</code>指定路径下的类库;</li><li>该类是程序中默认的类加载器，一般来说，Java中的应用类都是由他来进行加载的；</li><li>通过ClassLoader.getSystemClassLoader()可以获得到该类加载器。</li></ul><h6 id="自定义的类加载器"><a href="#自定义的类加载器" class="headerlink" title="自定义的类加载器"></a>自定义的类加载器</h6><ol><li>为什么要自定义类加载器?</li></ol><ul><li>隔离加载类</li><li>修改类的加载方式</li><li>扩展加载源</li><li>防止源码泄露</li></ul><ol start="2"><li>自定义步骤</li></ol><ul><li>继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的要求;</li><li>在jdk1.2之前，继承<code>ClassLoader</code>并重写<code>loadClass()</code>方法，jdk1.2之后，不再建议重写<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中；</li><li>编写自定义类加载器时，如果没有复杂的要求，可以直接继承<code>URLClassLoader</code>类。<br>ClassL oader类国<br>ClassLoader获取途径国</li></ul><h6 id="ClassLoaader获取方式"><a href="#ClassLoaader获取方式" class="headerlink" title="ClassLoaader获取方式"></a><code>ClassLoaader</code>获取方式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:获取当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">//方式二:获取当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">//方式三:获取系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">//方式四:获取调用者的ClassLoader</span></span><br><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>Java虚拟机对Class文件采用的是按需加载方式，也就是说需要这个类的时候才会将他的Class文件加载到内存生成Class对象，而且加载某个类的Class文件的时候，Java虚拟机采用的是双亲委派模式 ，即把请求交给父类处理，他是一种任务委派模式。 </p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>工作原理：</p><ul><li>如果一个类加载器收到类加载请求的时候，他并不会自己先去加载，而是把这个请求委托给父类加载器去执行;</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求到达最顶层的启动类记载器;</li><li>如果父类加载器可以完成类的加载任务，就成功返回，如果父类加载器无法完成此加载任务，于是子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p>实例一：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" style="zoom:70%;" /><p>实例二：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BDjdbc.jpg" style="zoom:70%;" /><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>使用双亲委派机制的优势：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心api被篡改<ul><li>比如自定义一个类<code>java.lang.String</code>-------也就是自己创建一个<code>java.lang</code>包，下面再创建一个类String，该情况由于双亲委派机制的存在，不会执行自定义类，而是执行系统自带的String类</li><li>比如自定义一个类<code>java.lang.TestApp</code>-------虽然系统不存在该类，但是由于存在于<code>java.lang</code>包下，就会交给引导类加载器（<code>BootrapClassLoader</code>）,他识别该类并向外抛出异常（<code>java.lang.SecurityException:Prohibited package name : java.lang</code>），以保证安全性。</li></ul></li></ul><h6 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h6><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\string.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><p>如自定义如下类并放在<code>java.lang</code>包下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Word&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------报错内容如下：</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br></pre></td></tr></table></figure><h4 id="JVM判断两个类是同一个对象的条件"><a href="#JVM判断两个类是同一个对象的条件" class="headerlink" title="JVM判断两个类是同一个对象的条件"></a>JVM判断两个类是同一个对象的条件</h4><ul><li>类的完整类名必须一致,包括包名；</li><li>加载这个类的类加载器必须完全相同。</li></ul><p>换句话来说，在JVM中，即使两个类的对象（Class对象）来源于同一个Class文件，被同一个虚拟机加载，但是只要是加载他们的ClassLoader不同，那么这两个对象也就是不相等的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="2021/06/01/Java/design/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/06/01/Java/design/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>有一些对象我们只需要一个，比如：线程池、缓存、日志、注册表、对话框等等。这些对象如果设计为多例，那么可能会产生很多问题，比如程序异常，资源使用过量，数据不一致，等问题。</p><p><strong>单例模式：</strong>确保一个类只有一个<code>实例</code>，并且具有一个全局访问点。</p><p>最经典的单例模式（懒汉式）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：多线程情况下操作，肯能会尝试两个不同的对象。</p><p>原因，如果现在有两个线程同时访问<code>Singleton.newInstance()</code>,并且恰巧，在还未给<code>uniqueInstance</code>变量进行第一次赋值的时候，另外一个线程也进行了是否为空的判断并且得到为空了那么便会进入重新new一个对象，从而得到两个不同的对象。</p><p>解决办法：</p><ul><li>将<code>newInstance()</code>方法用<code>synchronized</code>进行修饰变为同步方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样解决的缺点：只有第一次访问的时候才需要同步，一旦第一次赋值之后，就不需要同步了，这样做就显得很累赘了。</p><ul><li>使用饿汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计可以使得JVM启动加载到该类的时候就对uniqueInstance赋值了唯一的单件实例。</p><p>缺点：项目启动就创建，生命周期伴随程序一辈子，从项目启动就产生，项目结束才终止。如果项目中又一直不使用该单例对象，那么给项目带了一定的压力与负担</p><ul><li>双端检索机制</li></ul><p>使用双端加锁，首先检查对象是否已经创建，如果未创建，在进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>volatile</code>关键字具有原子性、可见行、禁止指令重排（有序性）。他可以保证在jvm编译未字节码执行的时候保持原有执行顺序，不会因为jvm优化而重排序导致的问题。</p><p>双端检索相对于上面使用<code>synchronized</code>修饰方法的来讲，已经大大的提高了性能。</p><p><strong>使用单例模式时候需要注意：</strong></p><p>如果一个单例被两个类加载器同时加载，那么该类会被加载两次，也会导致被实例化两次，从而违反单例。每个类加载器都被定义了一个命名空间，如果有两个或者两个以上的类加载器，不同的类加载器可能会加载同一个类，从整体来看，同一个类就会被加载多次。这样就会发生诡异的事情，导致单例创建出两个不同的对象。所以，如果同一个程序中有多个类加载器并且还使用了单例模式。那么必须自行指定类加载器，而且必须是同一个类加载器。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之命令模式</title>
      <link href="2021/05/20/Java/design/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/20/Java/design/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>封装方法调用</p><p>将发出请求的对象和执行请求的对象进行解耦。</p><h5 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h5><p>现在存在一个遥控器，主要是用来控制家用电器的开关，如电灯、空调、电视等的开与关。现在实现一组遥控器的API，让每个卡槽都能够控制一个或者一组装置。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/observation.png" style="zoom: 67%;" /><h5 id="2、命令模式设计"><a href="#2、命令模式设计" class="headerlink" title="2、命令模式设计"></a>2、命令模式设计</h5><h6 id="1-实现一个接口"><a href="#1-实现一个接口" class="headerlink" title="1.实现一个接口"></a>1.实现一个接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//撤销方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-实现一个电灯打开的动作"><a href="#2-实现一个电灯打开的动作" class="headerlink" title="2.实现一个电灯打开的动作"></a>2.实现一个电灯打开的动作</h6><ul><li>灯对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开灯控制类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="title">implement</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关灯控制类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="title">implement</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空调、电视等也使用相同的方式实现。</p><h6 id="3-实现遥控器"><a href="#3-实现遥控器" class="headerlink" title="3.实现遥控器"></a>3.实现遥控器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开灯集合</span></span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    <span class="comment">//开灯集合</span></span><br><span class="line">    Command[] offCommands;</span><br><span class="line">    <span class="comment">//撤销操作</span></span><br><span class="line">    Command undoCommand;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化遥控器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        onCommands =<span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands =<span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        Command noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化设置撤销按钮为没有命令</span></span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置遥控器中每个卡槽的开和关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot，Command onCommand,Command offCommand)</span> </span>&#123;</span><br><span class="line">        onCommands [slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击卡槽开按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonwasPushed</span> <span class="params">(<span class="keyword">int</span> slot)</span></span>&#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = offCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击卡槽关闭按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在上面进行初始化的时候，我们预先指定了一个<code>NoCommand</code>对象，<code>NoCommand</code>的执行体是空的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span>  </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>NoCommand</code>对象是一个空对象<code>(null object)</code>的例子。当你不想返回一个有意义的对象时，空对象就很有用。客户也可以将处理<code>null</code>的责任转移给空对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了<code>NoCommand</code>对象作为代用品，当调用它的<code>execute()</code>方法时,这种对象什么事情都不做。在许多设计模式中，都会看到空对象的使用。<strong>甚至有些时候，空对象本身也被视为是种设计模式。</strong></li></ul><h5 id="3、运用"><a href="#3、运用" class="headerlink" title="3、运用"></a>3、运用</h5><h6 id="1-队列请求"><a href="#1-队列请求" class="headerlink" title="1.队列请求"></a>1.队列请求</h6><p>在工作队列中，不同的任务在执行，而然我们不知道执行的内容是什么，例如线程池，工作队列等。</p><p>我们可以想象，有一个工作队列，在某一端添加命令，另一端是线程，线程进行下面动作：从队列中取出一个命令并执行<code>excute</code>方法，执行完毕丢弃并出去下一个命令继续执行。。。。。</p><h6 id="2-日志请求"><a href="#2-日志请求" class="headerlink" title="2.日志请求"></a>2.日志请求</h6><h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><p>命令模式：将请求分装为对象，这可以让你使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。</p><p><strong>当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之简单工厂</title>
      <link href="2021/05/17/Java/design/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
      <url>2021/05/17/Java/design/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>当使用<code>new</code>的时候，确实是在实例化一个类，为了使创建对象的时候更具有弹性，我们使用子类进行实例化，使用父类进行接收。</p><p>工厂（factory）：即处理创建对象的细节。</p><h5 id="1、问题产生"><a href="#1、问题产生" class="headerlink" title="1、问题产生:"></a>1、问题产生:</h5><p>当我们要创建一个对象的时候，平时我们都会直接使用<code>new</code>的方式，其实，使用<code>new</code>的方式创建对象是没有毛病的，但是，问题出在于”改变“的时候。</p><h5 id="2、情景设计："><a href="#2、情景设计：" class="headerlink" title="2、情景设计："></a>2、情景设计：</h5><ol><li>某披萨公司开业，设计出一款特色披萨并研制出一套制作流程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//披萨订单</span></span><br><span class="line"><span class="function">Pizz <span class="title">orderPizz</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Pizz pizz = <span class="keyword">new</span> Pizz();</span><br><span class="line">    </span><br><span class="line">    pizz.prepare();</span><br><span class="line">    pizz.bake();</span><br><span class="line">    pizz.cut();</span><br><span class="line">    pizz.box();</span><br><span class="line">    <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>后面又设计出一款芝士披萨。但是问题在于芝士披萨除了自身之外，准备，烘烤，切片，打包都是一样的。故重新设计。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizz <span class="title">orderPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    Pizz pizz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">        pizz = CheesePizz();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;special &quot;</span>)&#123;</span><br><span class="line">        pizz = <span class="keyword">new</span> <span class="function">Special <span class="title">Pizz</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     pizz.prepare();</span><br><span class="line">     pizz.bake();</span><br><span class="line">     pizz.cut();</span><br><span class="line">     pizz.box();</span><br><span class="line">     <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传入的披萨类型来判断要创建的披萨类型。注意，这里面Pizz是一个接口，所有其他披萨都必须实现该接口。</p><ol start="3"><li>该设计依旧还存在问题，如果后来芝士披萨不好卖了，需要将该披萨去除，然后新增一个蔬菜披萨，那么就得动源码，不符合<strong>对修改关闭</strong>的原则，故继续修改。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 披萨工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizz <span class="title">createPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizz = CheesePizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;greek&quot;</span>)&#123;</span><br><span class="line">            pizz = <span class="keyword">new</span> GreekPizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;veggie&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> VeggiePizz();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 披萨订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzStore</span></span>&#123;</span><br><span class="line">    <span class="comment">//披萨工厂</span></span><br><span class="line">    <span class="keyword">private</span> SimplePizzFactory;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">PizzStore</span><span class="params">(SimplePizzFactory simplePizzFactory)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.simplePizzFactory = simplePizzFactory;</span><br><span class="line">     &#125;        </span><br><span class="line"></span><br><span class="line"><span class="function">Pizz <span class="title">orderPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过传入的类型到披萨工厂中获取相应类型的披萨</span></span><br><span class="line">   Pizz pizz = simplePizzFactory.createPizz(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有披萨流程不变</span></span><br><span class="line">         pizz.prepare();</span><br><span class="line">         pizz.bake();</span><br><span class="line">         pizz.cut();</span><br><span class="line">         pizz.box();</span><br><span class="line">         <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该设计的优点，</p><ul><li>首先，将披萨工厂提出来用于创建披萨对象，很大提高<code>复用性</code>，因为披萨对象不只是在订单中使用，他也可能在菜单中，描述中被用到，以后要创建只需要直接在披萨工厂中取即可。</li><li>其次，将创建披萨的过程封装成为一个对象，以后如果创建披萨对象需要修改，只要修改工厂内部即可，其他地方无需改动。符合<code>对修改关闭</code></li></ul><p>疑问？在披萨工厂内部，为什么要使用普通方法创建披萨实例而不使用静态方法创建。如果使用静态方法可以不用传入工厂对象便可以直接通过类名调用方法呢？</p><ul><li>使用静态方法也可以，通常被称之为静态工厂，但是，这样做也有明显的缺点。就是以后不能使用继承的方式来改变对象创建的行为。（违背了对扩展开放）</li></ul><h5 id="3、简单工厂UML类图"><a href="#3、简单工厂UML类图" class="headerlink" title="3、简单工厂UML类图"></a>3、简单工厂UML类图</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/simplefactory_uml.png" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂方法</title>
      <link href="2021/05/13/Java/design/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/13/Java/design/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>续简单工厂可能存在的问题</p><h5 id="1、问题产生"><a href="#1、问题产生" class="headerlink" title="1、问题产生"></a>1、问题产生</h5><p>披萨店经营有成，现在需要外地需要进行加盟，但是由于口味存在差异，同一种类型的披萨也会存在一些口味的差异，现在希望加盟店都能利用你的代码，好让制作披萨的流程不变，但是又能制作出不同地域风味的披萨。</p><p>所以我们可得(<code>注意：NYPizzFactory和ChicagoFactory实现了PizzFactory并重写了创建披萨的方法</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//制作纽约风味的披萨</span></span><br><span class="line">NYPizzFactory nyPizzFactory = <span class="keyword">new</span> NYPizzFactory();</span><br><span class="line"><span class="comment">//创建一个披萨店，用纽约风味披萨做工厂</span></span><br><span class="line">PizzStore pizzStore = <span class="keyword">new</span> PizzStore(nyPizzFactory);</span><br><span class="line"><span class="comment">//当我们创建披萨的时候会得到纽约风味的披萨</span></span><br><span class="line">pizzStore.orderPizz(<span class="string">&quot;Veggie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作芝加哥风味的披萨</span></span><br><span class="line">ChicagoFactory chicagoPizzFactory = <span class="keyword">new</span> ChicagoPizzFactory();</span><br><span class="line">PizzStore pizzStore = <span class="keyword">new</span> PizzStore(chicagoPizzFactory);</span><br><span class="line">pizzStore.orderPizz(<span class="string">&quot;Veggie&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>问题：虽然<code>NYPizzFactory</code>和<code>ChicagoFactory</code>接受着<code>SimpleFactory</code>工厂的制约，但是很明显的把披萨店暴露给了别人，如果这时候有的加盟店减少了制作披萨的流程（如减少切片过程以减少成本），这时候就有可能对你原先的有所影响，所以，我们现在想要将所有让披萨制作的过程都在<code>PizzStore</code>中，却又可以制作不同地域风味的披萨</strong></p><h5 id="2、问题处理"><a href="#2、问题处理" class="headerlink" title="2、问题处理"></a>2、问题处理</h5><p>我们将<code>PizzStore</code>设计成一个抽象类，然后所有的地域都来实现他，然后，由各地域负责实现创建披萨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Pizz <span class="title">orderPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过传入的类型到披萨工厂中获取相应类型的披萨</span></span><br><span class="line">   Pizz pizz = createPizz(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有披萨流程不变</span></span><br><span class="line">         pizz.prepare();</span><br><span class="line">         pizz.bake();</span><br><span class="line">         pizz.cut();</span><br><span class="line">         pizz.box();</span><br><span class="line">         <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Pizz <span class="title">createPizz</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析，由于创建披萨的是抽象方法，而创建披萨的过程是抽象方法，子类必须实现该方法，所以，面对不同的地域，我们只需要实现该抽象类，在方法中进行地域能的披萨制作，就能够统一制作流程。</p><h5 id="3、披萨店实现"><a href="#3、披萨店实现" class="headerlink" title="3、披萨店实现"></a>3、披萨店实现</h5><h6 id="1-披萨店"><a href="#1-披萨店" class="headerlink" title="1.披萨店"></a>1.披萨店</h6><p>纽约披萨店</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzStore</span> <span class="title">extend</span> <span class="title">PizzStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方式是抽象方法，必须进行相应的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizz <span class="title">createPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizz = CheesePizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;greek&quot;</span>)&#123;</span><br><span class="line">            pizz = <span class="keyword">new</span> GreekPizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;veggie&quot;</span>)&#123;</span><br><span class="line">            pizz = <span class="keyword">new</span> VeggiePizz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>芝加哥披萨店</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzStore</span> <span class="title">extend</span> <span class="title">PizzStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizz <span class="title">createPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizz = CheesePizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;greek&quot;</span>)&#123;</span><br><span class="line">            pizz = <span class="keyword">new</span> GreekPizz();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;veggie&quot;</span>)&#123;</span><br><span class="line">           pizz = <span class="keyword">new</span> VeggiePizz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此设计，在抽象类<code>orderPizz</code>中，并不知道创建的披萨是哪一种，他就只是负责准备，烘烤，切片和装盒。而具体是什么风味的披萨由子类进行相关实现。</p><h6 id="2-披萨"><a href="#2-披萨" class="headerlink" title="2.披萨"></a>2.披萨</h6><ul><li>披萨抽象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizz</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String dough;</span><br><span class="line">    String sauce;</span><br><span class="line">    List toppings = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out.println ( <span class="string">&quot;Preparing &quot;</span> +name) ;</span><br><span class="line">        System. out.println( <span class="string">&quot;Tossing dough.….&quot;</span> );</span><br><span class="line">        System.out.println ( <span class="string">&quot;Adding sauce...&quot;</span> );</span><br><span class="line">        System. out.println ( <span class="string">&quot;Adding toppings: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; toppings.size(); i++)&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;&quot;</span> + toppings.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体实现</li></ul><p>纽约风格披萨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStylecheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NYStyleCheesePizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">&quot;NY Style Sauce and Cheese Pizza&quot;</span>;</span><br><span class="line">        dough =<span class="string">&quot;Thin Crust Dough&quot;</span> ;</span><br><span class="line">        sauce =<span class="string">&quot;Marinara Sauce&quot;</span> ;</span><br><span class="line">        toppings.add ( <span class="string">&quot;Grated Reggiano Cheese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>芝加哥风格披萨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagostyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChicagoStyleCheesePizza</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">&quot;Chicago Style Deep Dish Cheese Pizza&quot;</span>;</span><br><span class="line">        dough =<span class="string">&quot;Extra Thick Crust Dough&quot;</span>;</span><br><span class="line">        sauce =<span class="string">&quot;Plum Tomato Sauce&quot;</span>;</span><br><span class="line">        toppings.add ( <span class="string">&quot;Shredded Mozzarella Cheese&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;Cutting the pizza into square slices&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-吃披萨"><a href="#3-吃披萨" class="headerlink" title="3.吃披萨"></a>3.吃披萨</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaTestDrive</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">        PizzaStore nyStore = <span class="keyword">new</span> NYPizzaStore() ;</span><br><span class="line">        PizzaStore chicagoStore = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">        </span><br><span class="line">        Pizza pizza= nyStore.orderPizza ( <span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println ( <span class="string">&quot;Ethan ordered a &quot;</span> + pizza.getName () + <span class="string">&quot;&#x27;\n&quot;</span>);</span><br><span class="line">        pizza = chicagoStore.orderPizza ( <span class="string">&quot;cheese&quot;</span>) ;</span><br><span class="line">        System.out.println ( <span class="string">&quot;Joel ordered a &quot;</span> + pizza.getName ()+ <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、UML类图"><a href="#4、UML类图" class="headerlink" title="4、UML类图"></a>4、UML类图</h5><p><strong>创建者</strong></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/method_factory_creator_uml.png" alt="method_factory_creator_uml" style="zoom:67%;" /><p><strong>产品类</strong></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/method_factory_product_uml.png" style="zoom: 80%;" /><h5 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h5><p><strong>工厂方法：</strong>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码和子类创建的代码就解耦了。简单来说，就是让子类来决定该创建的对象是什么以来达到对象创建过程封装的目的。</p><p><strong>缺点：</strong>由于需要传入一个字符串来进行确认创建的饿具体对象，所以，该处如果不小心将单词拼错，那么将会造成错误，我们可以使用枚举类型进行定义以减少该类问题的出现。</p><p>该方法使用了<strong>依赖倒置原则</strong></p><p>依赖倒置原则：不能让高层组件（<code>PizzStore</code>）依赖于底层组件(<code>Pizz</code>)，而且，不管高层组件还是底层组件，他们都应该依赖于抽象。</p><p>解释：<code>PizzStore</code>披萨商店依赖于<code>Pizz</code>披萨，为了不让<code>Pizz</code>披萨耦合，我们将<code>Pizz</code>抽象作为父类，但是，我们为了具体得到是哪一个<code>Pizz</code>我们进一步对<code>PizzStore</code>进行抽象，以对抽象<code>Pizz</code>进行实现。</p><p>使用以下原则可以避免违反依赖倒置原则：</p><ul><li>变量不可以持有具体类的引用（如果使用new就会持有具体类的引用）</li><li>不要让类派生自具体类（如果派生自具体类，就会依赖具体类，应该派生自一个抽象（接口或者抽象类））</li><li>不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象，基类中已经实现的方法，应该由所有的子类共享。）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之抽象工厂</title>
      <link href="2021/05/11/Java/design/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
      <url>2021/05/11/Java/design/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>续工厂方法可能存在的问题</p><p><strong>抽象工厂：</strong>提供一个接口，用于创建相关或者依赖的<strong>对象家族</strong>，而不需要明确指定集体类。</p><h5 id="1、问题的产生"><a href="#1、问题的产生" class="headerlink" title="1、问题的产生"></a>1、问题的产生</h5><p>披萨工厂设计到工厂方法已经设计的很棒了：具有弹性的框架，并且设计原则。</p><p>但是，现在又存在问题，虽然，我们已经规定好了每个连锁店中每个披萨的样式以及制作流程。但是，有的披萨店采用低价的原料来增加利润。这会导致品牌信誉度降低。</p><ul><li>需求：现在打算制作一家原料工厂，然后将原料再运送到各个加盟店（例如芝加哥的披萨店和纽约的披萨店应该从同一个工厂拿到的面团，芝士和蔬菜等等）。</li></ul><h5 id="2、方案设计"><a href="#2、方案设计" class="headerlink" title="2、方案设计"></a>2、方案设计</h5><h6 id="1-创建原料工厂"><a href="#1-创建原料工厂" class="headerlink" title="1.创建原料工厂"></a>1.创建原料工厂</h6><p>首先，创建一个生产原料的接口，负责创建所有原料（如生产面团、芝士、蔬菜等等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Veggies []createveggies ();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span> <span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面接口中，每一种原料都对应一个方法创建。每种原料就对应一个类。</p><h6 id="2-纽约风味的工厂的实现"><a href="#2-纽约风味的工厂的实现" class="headerlink" title="2.纽约风味的工厂的实现"></a>2.纽约风味的工厂的实现</h6><p>针对不同的区域就应对不同的口味就创建不同的工厂，只需要实现上面接口，就可以实现不同原料的创建。如纽约的就创建纽约工厂，专门创建纽约风味的原料，芝加哥的就创建芝加哥的工厂，专门创建芝加哥风味的原料。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pblic <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//纽约风味的酱料</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThinCrustDough ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MarinaraSauce ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReggianoCheese();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Veggies[]createveggies () &#123;</span><br><span class="line">        Veggies veggies[] = &#123; <span class="keyword">new</span> Garlic(),<span class="keyword">new</span> Onion ()，<span class="keyword">new</span> Mushroom (), <span class="keyword">new</span> RedPepper() &#125;;</span><br><span class="line">        <span class="keyword">return</span> veggies;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//针对于腊肠，纽约风味和芝加哥分为都用到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SlicedPepperoni(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> clams <span class="title">createClam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FreshClams ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-重做披萨"><a href="#3-重做披萨" class="headerlink" title="3.重做披萨"></a>3.重做披萨</h6><p>与之前披萨的抽象类相比，该处，我们将prepare方法作为抽象，用子类来进行实现，来实现原料的选择。</p><ul><li>披萨的抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Dough dough;Sauce sauce;</span><br><span class="line">    Veggies veggies[];</span><br><span class="line">    Cheese cheese;</span><br><span class="line">    Pepperoni pepperoni;</span><br><span class="line">    Clams clam;</span><br><span class="line">    <span class="comment">//该方法进行抽象，内部负责实现对原料的选择</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...下面方法保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，以后纽约风味的披萨都会继承该抽象类，然后重写<code>prepare</code>方法，然后在内部去纽约风味的工厂获取各个调料的实例，然后进行赋值。</p><ul><li>制作纽约芝士披萨</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory ingredientFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去纽约风味的调料工厂里面获取然后封装到纽约风味的纽约芝士披萨上面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out.println ( <span class="string">&quot;Preparing &quot;</span> +name);</span><br><span class="line">        dough = ingredientFactory.createDough ();</span><br><span class="line">        sauce = ingredientFactory.createSauce ( );</span><br><span class="line">        cheese = ingredientFactory.createCheese ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重做纽约的披萨商店</li></ul><p>抽象的披萨商店不变，我们需要在子类纽约商店上面处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzStore</span> <span class="title">extend</span> <span class="title">PizzStore</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方式是抽象方法，必须进行相应的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizz <span class="title">createPizz</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建纽约风味披萨工厂</span></span><br><span class="line">        PizzaIngredientFactory pizzaIngredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//将纽约风味披萨工厂传入，用于里面到工厂里面获取原料</span></span><br><span class="line">            pizz = CheesePizz(pizzaIngredientFactory);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;greek&quot;</span>)&#123;</span><br><span class="line">            pizz = <span class="keyword">new</span> GreekPizz(pizzaIngredientFactory);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;veggie&quot;</span>)&#123;</span><br><span class="line">            pizz =  <span class="keyword">new</span> VeggiePizz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><p><strong>通过抽象方法提供的接口，我们可以创建产品家族，利用这个接口写代码，方便我们从实际工厂中解耦，以便在不同的上下文中实现各式各样的工厂，制作出不同的产品（如：不同地域，不同操作系统，不同外观的操作）。</strong></p><p>抽象工厂和工厂方法的区别：</p><ul><li>抽象工厂的的方法经常以工厂方法的方式实现。抽象工厂的任务是负责定义一组产品的接口，这组接口中的每个方法都负责创建一个产品。同时利用抽象工厂的子类来提供具体的做法。所以可以简单的说抽象工厂里面包含了工厂方法。</li><li>抽象工厂采用组合，工厂方法采用继承</li></ul><p>面向对象的设计原则：</p><ul><li>多用组合，少用继承</li><li>针对接口编程，不针对实现编程</li><li>为交互对象之间的松耦合设计而不断的努力</li><li>类应该对扩展开发，对修改关闭</li><li>依赖于抽象，不依赖与具体类（依赖倒置原则）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub骚操作</title>
      <link href="2021/05/09/git/github%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/09/git/github%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="GitHub骚操作"><a href="#GitHub骚操作" class="headerlink" title="GitHub骚操作"></a>GitHub骚操作</h4><h5 id="1、in关键词限制搜索范围"><a href="#1、in关键词限制搜索范围" class="headerlink" title="1、in关键词限制搜索范围"></a>1、<code>in</code>关键词限制搜索范围</h5><p>公式：xxx关键词 <code>in:name</code>或<code>description</code>或<code>readme</code></p><p>示例：</p><ul><li><code>xxx in:name</code>  项目名包含xxx的</li><li><code>xxx in:description</code>  项目描述包含xxx的</li><li><code>xxx in:readme</code>  项目中的<code>readme</code>文件中包含xxx</li><li><code>xxx in:name,descripption,readme</code>  组合使用(三者都包含xxx的)</li></ul><h5 id="2、start或fork数量关键词去查找"><a href="#2、start或fork数量关键词去查找" class="headerlink" title="2、start或fork数量关键词去查找"></a>2、<code>start</code>或<code>fork</code>数量关键词去查找</h5><p>公式：</p><ul><li>xxx关键词  <code>stars</code>/<code>forks</code> 通配符( <code>:&gt; </code>或者 <code>:&gt;=</code>)</li><li>xxx关键词  <code>stars</code>/<code>forks</code> 区间范围数字(数字1..数字2)</li></ul><p>示例：</p><ul><li>查找<code>stars</code>数大于等于5000的SpringBoot项目  --------&gt;  <code>springboot stars:&gt;=5000</code></li><li>查找<code>forks</code>数大于5000的springcloud项目  --------&gt;  <code> springcloud forks:&gt;=5000</code></li><li>组合使用(查找<code>forks</code>在80到100之间并且<code>stars</code>数在100到200 之间的SpringBoot项目)   --------&gt;   <code>springboot stars:100..200 forks:80..100</code></li></ul><h5 id="3、awesome加强搜索"><a href="#3、awesome加强搜索" class="headerlink" title="3、awesome加强搜索"></a>3、<code>awesome</code>加强搜索</h5><p><code>awesome</code>系列，一般是用来收集学习，工具，书籍类相关的项目</p><p>公式：<code>awesome</code> 关键字</p><p>示例：</p><ul><li>搜索优秀的redis相关的项目，包括框架，教程等   --------&gt;  <code>awesome redis</code></li></ul><h5 id="4、高亮显示某一行代码"><a href="#4、高亮显示某一行代码" class="headerlink" title="4、高亮显示某一行代码"></a>4、高亮显示某一行代码</h5><p>公式：</p><ul><li>1行  ----------&gt;   地址后面跟上<code>#L数字</code></li><li>多行  ----------&gt;   地址后面跟上<code>#L数字-#L数字</code></li></ul><h5 id="5、项目内搜索"><a href="#5、项目内搜索" class="headerlink" title="5、项目内搜索"></a>5、项目内搜索</h5><ul><li>查找文件 ------------&gt;  英文<code>t</code>（注意只能是小写<code>t</code>）</li><li>调到指定行号 ------------&gt;  文件中点击<code>l</code></li><li><a href="https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/keyboard-shortcuts"><code>GitHub快捷键</code></a></li></ul><h5 id="6、搜索某个地区内的大佬"><a href="#6、搜索某个地区内的大佬" class="headerlink" title="6、搜索某个地区内的大佬"></a>6、搜索某个地区内的大佬</h5><p>公式：</p><ul><li><code>location:地区</code></li><li><code>language:语言</code></li></ul><p>示例：</p><ul><li>地区北京的<code>java</code>方向的用户   ----------&gt; <code>location:beijing language:java</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作</title>
      <link href="2021/05/08/git/git%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/08/git/git%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h4><h5 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h5 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span></span><br></pre></td></tr></table></figure><h5 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h5 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h5 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h5 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h5 id="七、查询信息"><a href="#七、查询信息" class="headerlink" title="七、查询信息"></a>七、查询信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h5 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h5 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h5 id="10、Git-pull-强制拉取并覆盖本地代码"><a href="#10、Git-pull-强制拉取并覆盖本地代码" class="headerlink" title="10、Git pull 强制拉取并覆盖本地代码"></a>10、Git pull 强制拉取并覆盖本地代码</h5><p>注意：此方法会覆盖本地所有改动，慎用！！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="2021/05/06/Java/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/06/Java/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>来源：HeadFirst设计模式</p><h5 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h5><blockquote><p>第一版：</p><p>Joe上班的公司做了一套相当成功的模拟鸭子游戏:SimUDuck。游戏中出现各种鸭子，一边游泳戏水，一边呱呱叫。此系统的内部设计使用了标准的OO技术，设计了一个鸭子超类( Superclass)，并让各种鸭子继承此超类</p><p>第二版：</p><p>主管认为，此模拟程序需要会飞的鸭子，将竞争者抛在 后头。</p></blockquote><h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><ul><li><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不 需要变化的代码混在一起。（<strong>把会变化的部分取出 并「封装」起来，好 让其他部分不会受到 影响。</strong>）</p><p>​       这个原则的另一个思考方式:「把会变化的部分取出并 封装起来，以便以后可以轻易地扩充此部分，而不影响不需要 变化的其他部分」。</p></li><li><p>针对接口编程，而不是针对实现 编程。（<strong>将鸭子的行为将会被放在分开的类中，此类专门提供某行为的实现</strong>）</p><pre><code>  这样，鸭子类就不在需要知道行为的实现细节</code></pre></li><li><p>多用组合，少用继承。</p></li></ul><p>「针对接口编程」真正的意思是「针对超类型(supertype) 编程」。</p><p>这里所谓的「接口」有多个含意，接口是一个「概念」， 也是一种Java的interface构造。你可以在不涉及Java  interface的情况下，「针对接口编程」，关键就在多态。 利用多态，程序可以针对超类型编程，执行时会根据实际状 况执行到真正的行为，不会被绑死在超类型的行为上。「针 对超类型编程」这句话，可以更明确地说成「变量的声明类 型，应该是超类型，通常是一个抽象类或者是一个接口，如 此，只要是具体实现此超类型的类所产生的对象，都可以指 定给这个变量;这也意味着，声明类时，不用理会以后执行 时的真正对象类型!」</p><h5 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h5><ol><li>实现鸭子的行为</li></ol><ul><li><code>FlyBehavior</code>飞行行为定义</li></ul><p>定义接口，所有飞行类都实现它，所有新的飞行类 都必须实现fly()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义飞行接口的实现类，如不会飞行的和会飞行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一般的小鸭子飞行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不会飞的小鸭子&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>QuackBehavior</code>叫的行为定义</li></ul><p>定义接口，所有叫类都实现它，所有新的叫类 都必须实现quack()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义叫的实现类，如普通鸭子叫和橡皮鸭叫</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;呱呱叫的小鸭子&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;橡皮鸭子吱吱叫&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;什么都不做，不会叫&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样差出来的优点：</p><p>​            1）、这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。</p><p>​            2）、<strong>这么一来，有了继承 的「复用」好处，却 没有继承所带来的包袱。</strong></p><p>​            3）、而我们可以新增一些行为，不会影响到既有的行为类，也不会影响有「使用」到飞行行为的鸭子类。</p><ol start="2"><li>整合鸭子行为</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用父类的飞行行为接收</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">  <span class="comment">//使用父类的叫的行为接收</span></span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;小鸭子会游泳&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//委托给行为的类</span></span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quackBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>鸭子具体实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绿头鸭</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MallardDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//鸭子的具体行为，赋值给父类，针对不同的鸭子，在此处进行不同的处理</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外观是绿头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红头鸭</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedheadDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedheadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外观红头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//橡皮鸭</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RubberDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RubberDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Squeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外观是橡皮鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    <span class="comment">//这会调用MallardDuck继承来的performQuack()，进而委托给该对象的QuackBehavior对象处理。(也就是说，调用继承来的 quackBehavior 的 quack()。)</span></span><br><span class="line">    mallard.performQuack();</span><br><span class="line">    mallard.performFly();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">呱呱叫的小鸭子</span><br><span class="line">一般的小鸭子飞行</span><br></pre></td></tr></table></figure><p><strong>甚至，由于设置get/set方法，我们可以动态的设定行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    mallard.performQuack();</span><br><span class="line">    System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">    mallard.setQuackBehavior(<span class="keyword">new</span> MuteQuack());</span><br><span class="line">    mallard.performQuack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">呱呱叫的小鸭子</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">什么都不做，不会叫</span><br></pre></td></tr></table></figure><h5 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img//67B81619-D04A-49DA-9C2E-AE12F36B9DE3.png"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>『策略模式』定义了算法族，分别封装起来，让它 们之间可以互相替换，此模式让算法的变化独立于使用 算法的客户。</strong></p><p>​        将一个对象中会改变的部分抽取出来，形成一个新的整体，然后，采用组合的方式与原对象组合在一起，这样，就可以很好的实现行为与主体拆分出来，第一不会存在代码冗余，第二，也不会日后如果相关逻辑要改需要大规模改代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="2021/05/06/Java/design/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/06/Java/design/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><blockquote><p>现需要设计一个系统，此系统中的三个部分是气象站(获取实际气象数据的物理装置)、WeatherData对象(追踪来自气象站的数据，并更新布告板)和布告板(显示目前天气状况给用户看)</p><p>简单来说，就是有一个WeatherData对象，只要接受到相关的比如湿度的数据，就会自动的向一些子模块，比如当前状态，平均状态等更新信息。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/observer_1.png"></p><h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><ul><li>发布订阅模型，定义了对象之间的一对多依赖，这 样一来，当一个对象改变状态时，它的所有依赖者都 会收到通知并自动更新。</li></ul><p>主题和观察者定义了一对多的关系。观察者依赖于此主题，只 要主题状态一有变化，观察者就会被通知。根据通知的风格， 观察者可能因此新值而更新。</p><ul><li>松耦合设计，松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化， 是因为对象之间的互相依赖降到了最低。</li></ul><h5 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h5><ol><li>设计相关接口</li></ol><ul><li><code>Subject</code>发布者接口</li></ul><p>定义发布接口，负责规范观察者的注册，删除以及通知的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Observer</code>订阅者接口定义，规范订阅者获取观察者提供消息的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DisplayElement</code>公告展示接口</li></ul><p>规范定义行为展示的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上接口定义，在订阅者身上，只要子类实现了订阅者的父类，那么就可以直接使用父类接收。</p><ol start="2"><li>发布者实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于存储订阅者</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observerList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//温度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">  <span class="comment">//湿度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">  <span class="comment">//气压</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">    observerList.add(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = observerList.indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      observerList.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">      observer.update(temperature,humidity,pressure);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行消息通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notifyObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方便测试，模拟获取环境信息过程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">    <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">    <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">    measurementsChanged();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>订阅者相关实现</li></ol><ul><li>当前公告</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>,<span class="title">DisplayElement</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录该值主要是某些情况下方便移除订阅</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">//气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公告中：温度为=&quot;</span>+temperature+<span class="string">&quot;；湿度为：&quot;</span>+humidity+<span class="string">&quot;；气压为：&quot;</span>+pressure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>平均值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>,<span class="title">DisplayElement</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">//气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均中：温度为=&quot;</span>+temperature/count+<span class="string">&quot;；湿度为：&quot;</span>+humidity/count+<span class="string">&quot;；气压为：&quot;</span>+pressure/count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = <span class="keyword">this</span>.temperature + temp;</span><br><span class="line">        <span class="keyword">this</span>.humidity = <span class="keyword">this</span>.humidity + humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = <span class="keyword">this</span>.pressure + pressure;</span><br><span class="line">        count++;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>预测值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>,<span class="title">DisplayElement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">//气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForecastDisplay</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;预测中：温度为=&quot;</span>+temperature+<span class="string">&quot;；湿度为：&quot;</span>+humidity+<span class="string">&quot;；气压为：&quot;</span>+pressure);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">      </span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line">        ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">      <span class="comment">//注册</span></span><br><span class="line">        weatherData.registerObserver(currentConditionsDisplay);</span><br><span class="line">        weatherData.registerObserver(forecastDisplay);</span><br><span class="line">        weatherData.registerObserver(statisticsDisplay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得当前湿度/温度/气压</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">12</span>,<span class="number">22</span>,<span class="number">11</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">32</span>,<span class="number">12</span>,<span class="number">43</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">123</span>,<span class="number">43</span>,<span class="number">13</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">公告中：温度为&#x3D;12.0；湿度为：22.0；气压为：11.0</span><br><span class="line">预测中：温度为&#x3D;12.0；湿度为：22.0；气压为：11.0</span><br><span class="line">平均中：温度为&#x3D;12.0；湿度为：22.0；气压为：11.0</span><br><span class="line">公告中：温度为&#x3D;32.0；湿度为：12.0；气压为：43.0</span><br><span class="line">预测中：温度为&#x3D;32.0；湿度为：12.0；气压为：43.0</span><br><span class="line">平均中：温度为&#x3D;22.0；湿度为：17.0；气压为：27.0</span><br><span class="line">公告中：温度为&#x3D;123.0；湿度为：43.0；气压为：13.0</span><br><span class="line">预测中：温度为&#x3D;123.0；湿度为：43.0；气压为：13.0</span><br><span class="line">平均中：温度为&#x3D;55.666668；湿度为：25.666666；气压为：22.333334</span><br></pre></td></tr></table></figure><h5 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/observer_2.png"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>主要采用发布订阅模型，使用了多态的特性，在发布者身上直接使用父类接受订阅者，这样可以很好的达到松耦合的效果，如果我们想要新注册一个订阅者，无需修改发布者代码，这需要实现新的订阅者，然后，使用注册进入发布者就行。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="2021/04/28/LeetCode/medium/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>2021/04/28/LeetCode/medium/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月28日</li><li>描述：下了会小雨，但是还是有点闷热。</li></ul><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>提示</strong></li></ol><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.length();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">  <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">  <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">  <span class="comment">// 递推开始</span></span><br><span class="line">  <span class="comment">// 先枚举子串长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">    <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">      <span class="keyword">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">        dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">        begin = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：238 ms, 在所有 Java 提交中击败了42.12%的用户</span><br><span class="line">内存消耗：43 MB, 在所有 Java 提交中击败了25.48%的用户</span><br></pre></td></tr></table></figure><p>总结：动态规划，主要利用回文数内部的字串也是回文数的特点，我们使用一个开始二维数组，第一个为开始位置，第二个为结束位置，里面存储的结果直接为内字符串是否为回文数的判断结果，然后得到最长的开始和结束值，然后截取即可。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">    <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">      start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      end = i + len / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">    --left;</span><br><span class="line">    ++right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：31 ms, 在所有 Java 提交中击败了87.98%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了90.19%的用户</span><br></pre></td></tr></table></figure><p>总结：中心扩展法</p><h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = -<span class="number">1</span>;</span><br><span class="line">  StringBuffer t = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">    t.append(s.charAt(i));</span><br><span class="line">    t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">  s = t.toString();</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; arm_len = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="keyword">int</span> right = -<span class="number">1</span>, j = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur_arm_len;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">      <span class="keyword">int</span> i_sym = j * <span class="number">2</span> - i;</span><br><span class="line">      <span class="keyword">int</span> min_arm_len = Math.min(arm_len.get(i_sym), right - i);</span><br><span class="line">      cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_arm_len = expand(s, i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    arm_len.add(cur_arm_len);</span><br><span class="line">    <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">      j = i;</span><br><span class="line">      right = i + cur_arm_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">      start = i - cur_arm_len;</span><br><span class="line">      end = i + cur_arm_len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      ans.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">    --left;</span><br><span class="line">    ++right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：19 ms, 在所有 Java 提交中击败了91.10%的用户</span><br><span class="line">内存消耗：39.1 MB, 在所有 Java 提交中击败了54.77%的用户</span><br></pre></td></tr></table></figure><p>总结：Manacher 算法</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//保存起始位置，测试了用数组似乎能比全局变量稍快一点</span></span><br><span class="line">  <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="comment">//把回文看成中间的部分全是同一字符，左右部分相对称</span></span><br><span class="line">    <span class="comment">//找到下一个与当前字符不同的字符</span></span><br><span class="line">    i = findLongest(str, i, range);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.substring(range[<span class="number">0</span>], range[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> low, <span class="keyword">int</span>[] range)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查找中间部分</span></span><br><span class="line">  <span class="keyword">int</span> high = low;</span><br><span class="line">  <span class="keyword">while</span> (high &lt; str.length - <span class="number">1</span> &amp;&amp; str[high + <span class="number">1</span>] == str[low]) &#123;</span><br><span class="line">    high++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定位中间部分的最后一个字符</span></span><br><span class="line">  <span class="keyword">int</span> ans = high;</span><br><span class="line">  <span class="comment">//从中间向左右扩散</span></span><br><span class="line">  <span class="keyword">while</span> (low &gt; <span class="number">0</span> &amp;&amp; high &lt; str.length - <span class="number">1</span> &amp;&amp; str[low - <span class="number">1</span>] == str[high + <span class="number">1</span>]) &#123;</span><br><span class="line">    low--;</span><br><span class="line">    high++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录最大长度</span></span><br><span class="line">  <span class="keyword">if</span> (high - low &gt; range[<span class="number">1</span>] - range[<span class="number">0</span>]) &#123;</span><br><span class="line">    range[<span class="number">0</span>] = low;</span><br><span class="line">    range[<span class="number">1</span>] = high;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了99.82%的用户</span><br><span class="line">内存消耗：38.6 MB, 在所有 Java 提交中击败了79.81%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>腻害</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="2021/04/26/LeetCode/medium/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>2021/04/26/LeetCode/medium/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月26日</li><li>描述：晴，无聊的一天！</li></ul><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>提示</strong></li></ol><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>进阶：</strong> </p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  Set&lt;Character&gt; characters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> indx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = indx; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (characters.contains(c)) &#123;</span><br><span class="line">      i = indx;</span><br><span class="line">      indx++;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; characters.size()) &#123;</span><br><span class="line">        sum = characters.size();</span><br><span class="line">      &#125;</span><br><span class="line">      characters = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      characters.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Math.max(characters.size(), sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：126 ms, 在所有 Java 提交中击败了9.55%的用户</span><br><span class="line">内存消耗：39.1 MB, 在所有 Java 提交中击败了12.22%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 由于每次都创建一个新的对象，所以导致性能和内存都很低</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">  Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">  <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">      occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">      <span class="comment">// 不断地移动右指针</span></span><br><span class="line">      occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">      ++rk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">    ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：7 ms, 在所有 Java 提交中击败了79.30%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了77.56%的用户</span><br></pre></td></tr></table></figure><p>总结：其实思想大体相同，但是，这里面将我创建多个对象这个问题改为指针移动，就只用创建一个对象，然后之后就移除第一个，然后继续进行，性能就大幅度提升。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录字符上一次出现的位置</span></span><br><span class="line">  <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">    last[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 窗口开始位置</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//取出其中的字符转化为ascii</span></span><br><span class="line">    <span class="keyword">int</span> index = s.charAt(i);</span><br><span class="line">    <span class="comment">//取出该数组中ascii位置中的值，判断他加上1是否大于start，如果大于则说明该ascii已经出现过。此时需要取出上一个出现的位置，并将下标移动到他的下一位</span></span><br><span class="line">    <span class="comment">//原因：数组中存储为-1，-1+1 = 0   而出现过存储就不是-1，而是该ascii在字符串中出现的位置</span></span><br><span class="line">    start = Math.max(start, last[index] + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//计算这一次出现距离上一次出现的长度</span></span><br><span class="line">    res   = Math.max(res, i - start + <span class="number">1</span>);</span><br><span class="line">    last[index] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了75.93%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>好巧妙的方式，看了好久才看明白。将字符串中的字符存在的下标存储在数组中，如果遍历的时候查到数组中该字符对应的ascii值中的位置已经有值，说明该值之前出现过，就取出上一次出现的下标值，也就是存储在数组中的对应该ascii中的值，然后将计算不重复的下标移动至下一位。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数相加</title>
      <link href="2021/04/25/LeetCode/medium/%E4%B8%A4%E6%A0%91%E7%9B%B8%E5%8A%A0/"/>
      <url>2021/04/25/LeetCode/medium/%E4%B8%A4%E6%A0%91%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月25日</li><li>描述：做了这么久的简单，今天向中级进发！又是疲惫的一天，晴🌞</li></ul><h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/"> 两数相加</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><ol start="2"><li><p><strong>示例 1：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/addtwonumber1.jpg"></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提示</strong></li></ol><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode listNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">  ListNode l = listNode;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> next1Val = l1 != <span class="keyword">null</span>?l1.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2Val = l2 != <span class="keyword">null</span>?l2.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = next1Val + next2Val + temp;</span><br><span class="line">    temp = sum &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    listNode.val = sum &gt;= <span class="number">10</span> ? sum % <span class="number">10</span> : sum;</span><br><span class="line">    l1 = l1 != <span class="keyword">null</span>?l1.next:<span class="keyword">null</span>;</span><br><span class="line">    l2 = l2 != <span class="keyword">null</span>?l2.next:<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ListNode listNode1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">      listNode.next = listNode1;</span><br><span class="line">      listNode = listNode1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">    listNode.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了19.35%的用户</span><br><span class="line">内存消耗：38.7 MB, 在所有 Java 提交中击败了70.76%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 虽然简单实现得了，但是还是觉得冗余度太高，有好多地方可以优化。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  ListNode head = <span class="keyword">null</span>, tail = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      head = tail = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tail.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">      tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    carry = sum / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    tail.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.8 MB, 在所有 Java 提交中击败了54.83%的用户</span><br></pre></td></tr></table></figure><p>总结：思想相同，但是在赋值上面有一定的差别，导致性能上面的大幅度差距。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode cursor = root;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> l1Val = l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l2Val = l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumVal = l1Val + l2Val + carry;</span><br><span class="line">    carry = sumVal / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    ListNode sumNode = <span class="keyword">new</span> ListNode(sumVal % <span class="number">10</span>);</span><br><span class="line">    cursor.next = sumNode;</span><br><span class="line">    cursor = sumNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.7 MB, 在所有 Java 提交中击败了83.02%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>简洁明了，很好的解决了赋第一个值的问题。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度</title>
      <link href="2021/04/24/LeetCode/easy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>2021/04/24/LeetCode/easy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月24日</li><li>描述：晴，今天打球崴到脚了，有点微痛</li></ul><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。 </p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了38.05%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 递归方式，从最内层开始，返回左节点和右节点的最大值。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = queue.size();</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      TreeNode node = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.offer(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.offer(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">      size--;</span><br><span class="line">    &#125;</span><br><span class="line">    ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了16.68%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了65.22%的用户</span><br></pre></td></tr></table></figure><p>总结：采用迭代的方式进行解答。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了66.35%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>官方解答方式一的优化版。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx详解</title>
      <link href="2021/04/23/nginx/nginx/"/>
      <url>2021/04/23/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p><p><strong>Nginx 特点</strong></p><ul><li>高并发、高性能；</li><li>模块化架构使得它的扩展性非常好；</li><li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li><li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li><li>热部署、平滑升级；</li><li>完全开源，生态繁荣；</li></ul><h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p><ol><li>静态资源服务，通过本地文件系统提供服务；</li><li>反向代理服务，延伸出包括缓存、负载均衡等；</li><li><code>API</code> 服务， <code>OpenResty</code> ；</li></ol><p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和 <code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p><p>用一张图表示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx1.png" alt="图片"></p><p><strong>Nginx 安装</strong></p><p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p><p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Nginx配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf # nginx 主配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.default</span><br><span class="line"></span><br><span class="line"># 可执行程序文件</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;nginx-upgrade</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line"></span><br><span class="line"># nginx库文件</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service # 用于配置系统守护进程</span><br><span class="line">&#x2F;usr&#x2F;lib64&#x2F;nginx&#x2F;modules # Nginx模块目录</span><br><span class="line"></span><br><span class="line"># 帮助文档</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;CHANGES</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;README.dynamic</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;nginx-1.16.1&#x2F;UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line"></span><br><span class="line"># 静态资源目录</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;404.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 存放Nginx日志文件</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;nginx</span><br></pre></td></tr></table></figure><p>主要关注的文件夹有两个：</p><p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p><p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p><p><strong>Nginx 常用命令</strong></p><p><code>systemctl</code> 系统命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 开机配置</span><br><span class="line">systemctl enable nginx # 开机自动启动</span><br><span class="line">systemctl disable nginx # 关闭开机自动启动</span><br><span class="line"></span><br><span class="line"># 启动Nginx</span><br><span class="line">systemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span><br><span class="line"></span><br><span class="line"># 停止Nginx</span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line"># 重启Nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line"># 重新加载Nginx</span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"># 查看 Nginx 运行状态</span><br><span class="line">systemctl status nginx</span><br><span class="line"></span><br><span class="line"># 查看Nginx进程</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"># 杀死Nginx进程</span><br><span class="line">kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span><br></pre></td></tr></table></figure><p><code>Nginx</code> 应用程序命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen # 重启 Nginx</span><br><span class="line">nginx -s stop # 快速关闭</span><br><span class="line">nginx -s quit # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T # 查看当前 Nginx 最终的配置</span><br><span class="line">nginx -t # 检查配置是否有问题</span><br></pre></td></tr></table></figure><h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># main段配置信息</span><br><span class="line">user  nginx; # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  auto; # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; # Nginx 的错误日志存放目录</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid; # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll; # 使用epoll的I&#x2F;O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024; # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123;</span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on; # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on; # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             &#x2F;etc&#x2F;nginx&#x2F;mime.types; # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application&#x2F;octet-stream; # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; # 加载子配置项</span><br><span class="line">    </span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">     listen       80; # 配置监听的端口</span><br><span class="line">     server_name  localhost; # 配置的域名</span><br><span class="line">      </span><br><span class="line">     # location段配置信息</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; # 网站根目录</span><br><span class="line">      index  index.html index.htm; # 默认首页文件</span><br><span class="line">      deny 172.168.22.11; # 禁止访问的ip地址，可以为all</span><br><span class="line">      allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     error_page 500 502 503 504 &#x2F;50x.html; # 默认50x对应的访问页面</span><br><span class="line">     error_page 400 404 error.html; # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 全局配置，对全局生效；</li><li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li><li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li><li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li><li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li><li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li></ul><p>用一张图清晰的展示它的层级结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx2.png" alt="图片"></p><h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user USERNAME [GROUP]</span><br><span class="line"></span><br><span class="line">user nginx lion; # 用户是nginx;组是lion</span><br></pre></td></tr></table></figure><p><strong>pid</strong></p><p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid &#x2F;opt&#x2F;nginx&#x2F;logs&#x2F;nginx.pid # master主进程的的pid存放在nginx.pid的文件</span><br></pre></td></tr></table></figure><h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。</span><br></pre></td></tr></table></figure><p><strong>worker_rlimit_core</strong></p><p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_core 50M; # 存放大小限制</span><br><span class="line">working_directory &#x2F;opt&#x2F;nginx&#x2F;tmp; # 存放目录</span><br></pre></td></tr></table></figure><h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4; # 指定具体子进程数量</span><br><span class="line">worker_processes auto; # 与当前cpu物理核心数一致</span><br></pre></td></tr></table></figure><h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx3.png" alt="图片"></p><p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p><p><strong>worker_priority</strong></p><p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用 <code>Nginx</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_priority -10; # 120-10&#x3D;110，110就是最终的优先级</span><br></pre></td></tr></table></figure><p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p><p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p><h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_shutdown_timeout 5s;</span><br></pre></td></tr></table></figure><h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure><p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p><p><strong>daemon</strong></p><p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemon off; # 默认是on，后台运行模式</span><br></pre></td></tr></table></figure><h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use method; # 不推荐配置它，让nginx自己选择</span><br><span class="line"></span><br><span class="line">method 可选值为：select、poll、kqueue、epoll、&#x2F;dev&#x2F;poll、eventport</span><br></pre></td></tr></table></figure><h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_connections 1024 # 每个子进程的最大连接数为1024</span><br></pre></td></tr></table></figure><p><strong>accept_mutex</strong></p><p>是否打开负载均衡互斥锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex on # 默认是off关闭的，这里推荐打开</span><br></pre></td></tr></table></figure><p><strong>server_name 指令</strong></p><p>指定虚拟主机域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name name1 name2 name3</span><br><span class="line"></span><br><span class="line"># 示例：</span><br><span class="line">server_name www.nginx.com;</span><br></pre></td></tr></table></figure><p>域名匹配的四种写法：</p><ul><li>精确匹配：<code>server_name www.nginx.com</code> ;</li><li>左侧通配：<code>server_name *.nginx.com</code> ;</li><li>右侧统配：<code>server_name www.nginx.*</code> ;</li><li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li></ul><p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p><p><code>server_name</code> 配置实例：</p><p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span><br><span class="line">121.42.11.34 www.nginx-test.com</span><br><span class="line">121.42.11.34 mail.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.org</span><br><span class="line">121.42.11.34 doc.nginx-test.com</span><br><span class="line">121.42.11.34 www.nginx-test.cn</span><br><span class="line">121.42.11.34 fe.nginx-test.club</span><br></pre></td></tr></table></figure><p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p><p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 这里只列举了http端中的sever端配置</span><br><span class="line"></span><br><span class="line"># 左匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name *.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;left-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正则匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name ~^.*\.nginx-test\..*$;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;reg-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 右匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.*;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;right-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 完全匹配</span><br><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.nginx-test.com;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;nginx-test&#x2F;all-match&#x2F;;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  index index.html;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、访问分析</p><ul><li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li><li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li><li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li><li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li></ul><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root path</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F;image &#123;</span><br><span class="line"> root &#x2F;opt&#x2F;nginx&#x2F;static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure><p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line"> alias &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com&#x2F;image&#x2F;1.png 时，实际在服务器找的路径是 &#x2F;opt&#x2F;nginx&#x2F;static&#x2F;image&#x2F;1.png</span><br></pre></td></tr></table></figure><p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p><p><strong>location</strong></p><p>配置路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配规则：</p><ul><li><code>=</code> 精确匹配；</li><li><code>~</code> 正则匹配，区分大小写；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>^~</code> 匹配到即停止搜索；</li></ul><p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.nginx-test.com;</span><br><span class="line">  </span><br><span class="line">  # 只有当访问 www.nginx-test.com&#x2F;match_all&#x2F; 时才会匹配到&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;match_all&#x2F;index.html</span><br><span class="line">  location &#x3D; &#x2F;match_all&#x2F; &#123;</span><br><span class="line">      root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      index index.html</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;1.jpg 等路径时会去 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images&#x2F;1.jpg 找对应的资源</span><br><span class="line">  location ~ \.(jpeg|jpg|png|svg)$ &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;images;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 当访问 www.nginx-test.com&#x2F;bbs&#x2F; 时会匹配上 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;bbs&#x2F;index.html</span><br><span class="line">  location ^~ &#x2F;bbs&#x2F; &#123;</span><br><span class="line">   root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>location 中的反斜线</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test&#x2F; &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li><li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li></ul><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404; # 直接返回状态码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return 302 &#x2F;bbs ; # 返回状态码 + 重定向地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line"> return https:&#x2F;&#x2F;www.baidu.com ; # 返回重定向地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：rewrite 正则表达式 要替换的内容 [flag];</span><br><span class="line"></span><br><span class="line">上下文：server、location、if</span><br><span class="line"></span><br><span class="line">示例：rewirte &#x2F;images&#x2F;(.*\.jpg)$ &#x2F;pic&#x2F;$1; # $1是前面括号(.*\.jpg)的反向引用</span><br></pre></td></tr></table></figure><p><code>flag</code> 可选值的含义：</p><ul><li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li><li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li><li><code>redirect</code> 返回302临时重定向；</li><li><code>permanent</code> 返回301永久重定向；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion.club; # 要在本地hosts文件进行配置</span><br><span class="line">  root html;</span><br><span class="line">  location &#x2F;search &#123;</span><br><span class="line">   rewrite ^&#x2F;(.*) https:&#x2F;&#x2F;www.baidu.com redirect;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;images &#123;</span><br><span class="line">   rewrite &#x2F;images&#x2F;(.*) &#x2F;pics&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;pics &#123;</span><br><span class="line">   rewrite &#x2F;pics&#x2F;(.*) &#x2F;photos&#x2F;$1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;photos &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个配置我们来分析：</p><ul><li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li><li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的 <code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li></ul><h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：if (condition) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">上下文：server、location</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">if($http_user_agent ~ Chrome)&#123;</span><br><span class="line">  rewrite &#x2F;(.*)&#x2F;browser&#x2F;$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>condition</code> 判断条件：</p><ul><li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li><li><code>=</code> 或 <code>!=</code> 相等或不等；</li><li><code>~</code> 正则匹配；</li><li><code>! ~</code> 非正则匹配；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li><li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li><li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li><li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li></ul><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root html;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   if ( $uri &#x3D; &quot;&#x2F;images&#x2F;&quot; )&#123;</span><br><span class="line">     rewrite (.*) &#x2F;pics&#x2F; break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p><p><strong>autoindex</strong></p><p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p><p><code>autoindex.conf</code> 配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion-test.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;download&#x2F; &#123;</span><br><span class="line">    root &#x2F;opt&#x2F;source;</span><br><span class="line">    </span><br><span class="line">    autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx4.png" alt="图片"></p><p><strong>变量</strong></p><p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p><p>下面列举些项目中常用的变量：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx5.png" alt="图片"></p><p>实例演示 <code>var.conf</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"> listen 8081;</span><br><span class="line"> server_name var.lion-test.club;</span><br><span class="line"> root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  return 200 &quot;</span><br><span class="line">remote_addr: $remote_addr</span><br><span class="line">remote_port: $remote_port</span><br><span class="line">server_addr: $server_addr</span><br><span class="line">server_port: $server_port</span><br><span class="line">server_protocol: $server_protocol</span><br><span class="line">binary_remote_addr: $binary_remote_addr</span><br><span class="line">connection: $connection</span><br><span class="line">uri: $uri</span><br><span class="line">request_uri: $request_uri</span><br><span class="line">scheme: $scheme</span><br><span class="line">request_method: $request_method</span><br><span class="line">request_length: $request_length</span><br><span class="line">args: $args</span><br><span class="line">arg_pid: $arg_pid</span><br><span class="line">is_args: $is_args</span><br><span class="line">query_string: $query_string</span><br><span class="line">host: $host</span><br><span class="line">http_user_agent: $http_user_agent</span><br><span class="line">http_referer: $http_referer</span><br><span class="line">http_via: $http_via</span><br><span class="line">request_time: $request_time</span><br><span class="line">https: $https</span><br><span class="line">request_filename: $request_filename</span><br><span class="line">document_root: $document_root</span><br><span class="line">&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code> 中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">remote_addr: 27.16.220.84</span><br><span class="line">remote_port: 56838</span><br><span class="line">server_addr: 172.17.0.2</span><br><span class="line">server_port: 8081</span><br><span class="line">server_protocol: HTTP&#x2F;1.1</span><br><span class="line">binary_remote_addr: 茉</span><br><span class="line">connection: 126</span><br><span class="line">uri: &#x2F;test&#x2F;</span><br><span class="line">request_uri: &#x2F;test&#x2F;?pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">scheme: http</span><br><span class="line">request_method: GET</span><br><span class="line">request_length: 518</span><br><span class="line">args: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">arg_pid: 121414</span><br><span class="line">is_args: ?</span><br><span class="line">query_string: pid&#x3D;121414&amp;cid&#x3D;sadasd</span><br><span class="line">host: var.lion-test.club</span><br><span class="line">http_user_agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;88.0.4324.182 Safari&#x2F;537.36</span><br><span class="line">http_referer:</span><br><span class="line">http_via:</span><br><span class="line">request_time: 0.000</span><br><span class="line">https:</span><br><span class="line">request_filename: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;test&#x2F;</span><br><span class="line">document_root: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure><p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p><p><strong>Nginx 应用核心概念</strong></p><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p><p>不管是正向代理还是反向代理，实现的都是上面的功能。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx6.png" alt="图片"></p><p><strong>正向代理</strong></p><blockquote><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p></blockquote><p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p><p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p><p><strong>反向代理</strong></p><blockquote><ul><li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li></ul></blockquote><p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p><p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p><p>反向代理的优势：</p><ul><li>隐藏真实服务器；</li><li>负载均衡便于横向扩充后端动态服务；</li><li>动静分离，提升系统健壮性；</li></ul><p>那么“动静分离”是什么？负载均衡又是什么？</p><p><strong>动静分离</strong></p><p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx7.png" alt="图片"></p><p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p><p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p><p><strong>负载均衡</strong></p><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p><p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p><p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p><p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p><p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code> 口人少车空....”，这个工作人员的作用就是负载均衡。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx8.png" alt="图片"></p><p><code>Nginx</code> 实现负载均衡的策略：</p><ul><li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li><li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li><li>最快响应时间策略：优先分配给响应时间最短的服务器。</li><li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li></ul><p><strong>Nginx 实战配置</strong></p><p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p><p><strong>upstream</strong></p><p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx9.png" alt="图片"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：upstream name &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">upstream back_end_server&#123;</span><br><span class="line">  server 192.168.100.33:8081</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>upstream</code> 内可使用的指令：</p><ul><li><code>server</code> 定义上游服务器地址；</li><li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li><li><code>keepalive</code> 对上游服务启用长连接；</li><li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li><li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li><li><code>hash</code> 哈希负载均衡算法；</li><li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li><li><code>least_conn</code> 最少连接数负载均衡算法；</li><li><code>least_time</code> 最短响应时间负载均衡算法；</li><li><code>random</code> 随机负载均衡算法；</li></ul><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：server address [parameters]</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure><p><code>parameters</code> 可选值：</p><ul><li><code>weight=number</code> 权重值，默认为1；</li><li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li><li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li><li><code>max_fails=numer</code> 服务器不可用的检查次数；</li><li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li><li><code>down</code> 标记服务器长期不可用，离线维护；</li></ul><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keepalive connections;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br><span class="line"></span><br><span class="line">示例：keepalive 16;</span><br></pre></td></tr></table></figure><h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_requests number;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_requests 100;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure><p><strong>keepalive_timeout</strong></p><p>空闲长连接的最长保持时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：keepalive_timeout time;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_timeout 60s;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream back_end&#123;</span><br><span class="line"> server 127.0.0.1:8081 weight&#x3D;3 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;2;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 50;</span><br><span class="line">  keepalive_timeout 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_pass URL;</span><br><span class="line"></span><br><span class="line">上下文：location、if、limit_except</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;proxy</span><br></pre></td></tr></table></figure><p><code>URL</code> 参数原则</p><ol><li><p><code>URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p></li><li><p><code>URL</code> 中可以携带变量；</p></li><li><p><code>URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p></li></ol><p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p><ol><li><code>proxy_pass http://192.168.100.33:8081</code></li><li><code>proxy_pass http://192.168.100.33:8081/</code></li></ol><p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p><ul><li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li><li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li></ul><p>不带 <code>/</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p></li><li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p></li></ol><p> 3 . 请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p><p>带 <code>/</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;bbs&#x2F;&#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p></li><li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p></li><li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p></li></ol><p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p><p><strong>配置反向代理</strong></p><p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code> 与 <code>121.5.180.193</code> 。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">server&#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;proxy&#x2F; &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy&#x2F;index.html</span><br><span class="line">&lt;h1&gt; 121.42.11.34 proxy html &lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;proxy.conf</span><br><span class="line">upstream back_end &#123;</span><br><span class="line">  server 121.42.11.34:8080 weight&#x3D;2 max_conns&#x3D;1000 fail_timeout&#x3D;10s max_fails&#x3D;3;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 80;</span><br><span class="line">  keepalive_timeout 20s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name proxy.lion.club;</span><br><span class="line">  location &#x2F;proxy &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;back_end&#x2F;proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code> 进入配置文件，添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.5.180.193 proxy.lion.club</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx10.png" alt="图片"></p><p>分析：</p><p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p><p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p><p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p><p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p><h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8020 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8030;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8030 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8040;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   return 200 &#39;return 8040 \n&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后：</p><ol><li><p><code>nginx -t</code> 检测配置是否正确；</p></li><li><p><code>nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p></li><li><p>执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p></li></ol><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line">121.5.180.193 balance.lion.club</span><br></pre></td></tr></table></figure><p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx11.png" alt="图片"></p><p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p><p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p><p><strong>hash 算法</strong></p><p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p><p><strong>ip_hash</strong></p><p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：least_conn;</span><br><span class="line"></span><br><span class="line">上下文：upstream;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  zone test 10M; # zone可以设置共享内存空间的名字和大小</span><br><span class="line">  least_conn;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location &#x2F;balance&#x2F; &#123;</span><br><span class="line">   proxy_pass http:&#x2F;&#x2F;demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后你会发现，负载均衡的配置其实一点都不复杂。</p><p><strong>配置缓存</strong></p><p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习 <code>Nginx</code> 中如何设置缓存策略。</p><p><strong>proxy_cache</strong></p><p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache zone | off ; # zone 是共享内存的名称</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache off;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure><p><strong>proxy_cache_path</strong></p><p>设置缓存文件的存放路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_path path [level&#x3D;levels] ...可选参数省略，下面会详细列举</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_path off</span><br><span class="line"></span><br><span class="line">上下文：http</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li><code>path</code> 缓存文件的存放路径；</li><li><code>level path</code> 的目录层级；</li><li><code>keys_zone</code> 设置共享内存；</li><li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li></ul><h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_key</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_key $scheme$proxy_host$request_uri;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure><p><strong>proxy_cache_valid</strong></p><p>配置什么状态码可以被缓存，以及缓存时长。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_valid [code...] time;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span><br></pre></td></tr></table></figure><h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_no_cache string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_no_cache $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure><h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：proxy_cache_bypass string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_cache_bypass $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure><h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MISS: 未命中缓存</span><br><span class="line">HIT：命中缓存</span><br><span class="line">EXPIRED: 缓存过期</span><br><span class="line">STALE: 命中了陈旧缓存</span><br><span class="line">REVALIDDATED: Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING: 内容陈旧，但正在更新</span><br><span class="line">BYPASS: X响应从原始服务器获取</span><br></pre></td></tr></table></figure><h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 1010;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1010;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 1020;</span><br><span class="line">  root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;1020;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">   index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path &#x2F;etc&#x2F;nginx&#x2F;cache_temp levels&#x3D;2:2 keys_zone&#x3D;cache_zone:30m max_size&#x3D;2g inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line"></span><br><span class="line">upstream cache_server&#123;</span><br><span class="line">  server 121.42.11.34:1010;</span><br><span class="line">  server 121.42.11.34:1020;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p><p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span><br><span class="line">  if ($request_uri ~ \.(txt|text)$) &#123;</span><br><span class="line">   set $cache_name &quot;no cache&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HTTPS</strong>**</p><p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p><p><strong>HTTPS 工作流程</strong></p><ol><li><p>客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p></li><li><p>百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p></li><li><p>浏览器验证 <code>CA</code> 证书是否为合法证书；</p></li><li><p>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p></li><li><p>发送公钥加密后的随机数给百度服务器；</p></li><li><p>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p></li><li><p>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p></li><li><p>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p></li></ol><p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p><p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p><h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server; # SSL 访问端口号为 443</span><br><span class="line">  server_name lion.club; # 填写绑定证书的域名(我这里是随便写的)</span><br><span class="line">  ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club_bundle.crt; # 证书地址</span><br><span class="line">  ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;https&#x2F;lion.club.key; # 私钥地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span><br><span class="line"> </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p><p><strong>配置跨域 CORS</strong></p><p>先简单回顾下跨域究竟是怎么回事。</p><p><strong>跨域的定义</strong></p><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p><p><strong>同源的定义</strong></p><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p><p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;store.company.com&#x2F;dir2&#x2F;other.html 同源</span><br><span class="line">https:&#x2F;&#x2F;store.company.com&#x2F;secure.html 不同源，协议不同</span><br><span class="line">http:&#x2F;&#x2F;store.company.com:81&#x2F;dir&#x2F;etc.html 不同源，端口不同</span><br><span class="line">http:&#x2F;&#x2F;news.company.com&#x2F;dir&#x2F;other.html 不同源，主机不同</span><br></pre></td></tr></table></figure><p>不同源会有如下限制：</p><ul><li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、 <code>LocalStorage</code> 等数据。</li><li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li><li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ul><h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p><ul><li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li><li>后端服务的域名为：<code>dev.server.com</code></li></ul><p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p><p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen      80;</span><br><span class="line"> server_name  fe.server.com;</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">  proxy_pass dev.server.com;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p><p><strong>配置开启 gzip 压缩</strong></p><p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code> 、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p><p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p><p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx12.png" alt="图片"></p><p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx13.png" alt="图片"></p><p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># # 默认off，是否开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 要采用 gzip 压缩的 MIME 文件类型，其中 text&#x2F;html 被系统强制启用；</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><br><span class="line"></span><br><span class="line"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span><br><span class="line">gzip_static on;</span><br><span class="line"></span><br><span class="line"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure><p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p><p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p><p><strong>Nginx 架构</strong></p><p><strong>进程结构</strong></p><p>多进程结构 <code>Nginx</code> 的进程模型图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx14.png" alt="图片"></p><p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p><ul><li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p></li><li><ul><li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li><li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li></ul></li><li><p>子进程间是通过共享内存的方式进行通信的。</p></li></ul><h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p><ol><li>向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</li></ol><p><code>2. master</code> 进程检查配置语法是否正确；</p><p><code>3. master</code> 进程打开监听端口；</p><p><code>4. master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p><p><code>5. master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p><p>\6. 老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p><p>\7. 整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p><h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/nginx15.png" alt="图片"></p><p>转自： 掘金 - Lion</p><p><a href="https://juejin.cn/post/6942607113118023710">https://juejin.cn/post/6942607113118023710</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称二叉树</title>
      <link href="2021/04/23/LeetCode/easy/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/04/23/LeetCode/easy/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月23日</li><li>描述：周五，未加班。多云☁️</li></ul><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个二叉树，检查它是否是镜像对称的。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong> 你可以运用递归和迭代两种方法解决这个问题吗？</p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> search(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val == q.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> search(p.left, q.right) &amp;&amp; search(q.left, p.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.3 MB, 在所有 Java 提交中击败了87.45%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 这一题和相同的树有着很多相同之处，又有相同的树的基础，这一题就很简单。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  q.offer(u);</span><br><span class="line">  q.offer(v);</span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    u = q.poll();</span><br><span class="line">    v = q.poll();</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q.offer(u.left);</span><br><span class="line">    q.offer(v.right);</span><br><span class="line"></span><br><span class="line">    q.offer(u.right);</span><br><span class="line">    q.offer(v.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了6.17%的用户</span><br><span class="line">内存消耗：37.5 MB, 在所有 Java 提交中击败了20.26%的用户</span><br></pre></td></tr></table></figure><p>总结：迭代法。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> &amp;&amp; left.val == right.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.4 MB, 在所有 Java 提交中击败了67.93%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>其实思想相同，只不过是实现上面的优劣。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相同的树</title>
      <link href="2021/04/22/LeetCode/easy/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
      <url>2021/04/22/LeetCode/easy/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月22日</li><li>描述：阴☁️</li></ul><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/ex1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/ex2.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p &#x3D; [1,2], q &#x3D; [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/ex3.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提示</strong></li></ol><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36 MB, 在所有 Java 提交中击败了24.37%的用户</span><br></pre></td></tr></table></figure><p>总结：只有两个走完结尾都是null才说明两个相等，只要两个值其中一个先为null或者val值不相等就说明两个不相同。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">  queue1.offer(p);</span><br><span class="line">  queue2.offer(q);</span><br><span class="line">  <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">    TreeNode node1 = queue1.poll();</span><br><span class="line">    TreeNode node2 = queue2.poll();</span><br><span class="line">    <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left1 = node1.left, right1 = node1.right, left2 = node2.left, right2 = node2.right;</span><br><span class="line">    <span class="keyword">if</span> (left1 == <span class="keyword">null</span> ^ left2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right1 == <span class="keyword">null</span> ^ right2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue1.offer(left1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue1.offer(right1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue2.offer(left2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queue2.offer(right2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.8 MB, 在所有 Java 提交中击败了67.95%的用户</span><br></pre></td></tr></table></figure><p>总结：深度优先搜索</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p!=<span class="keyword">null</span> &amp;&amp; q!=<span class="keyword">null</span> &amp;&amp; p.val==q.val  )&#123;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36 MB, 在所有 Java 提交中击败了28.39%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>其实和官方解答1一致。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序数组</title>
      <link href="2021/04/21/LeetCode/easy/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>2021/04/21/LeetCode/easy/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月21日</li><li>描述：今日不加班，天气晴🌞</li></ul><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你两个有序整数数组 <code>nums1 </code>和 <code>nums2</code>，请你将 <code>nums2</code> 合并到<code>nums1</code>中，使<code>nums1</code>成为一个有序数组。</p><p>初始化<code>nums1</code>和 <code>nums2</code> 的元素数量分别为<code>m</code>和<code>n</code>。你可以假设 <code>nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 </code>nums2 `的元素。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li>nums1.length == m + n</li><li>nums2.length == n</li><li>0 &lt;= m, n &lt;= 200</li><li>1 &lt;= m + n &lt;= 200</li><li>-109 &lt;= nums1[i], nums2[i] &lt;= 109</li></ul><p><strong>进阶：</strong> </p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = m,j=<span class="number">0</span>; i &lt; m+n; i++,j++) &#123;</span><br><span class="line">    nums1[i] = nums2[j];</span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(nums1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了24.52%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了71.24%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 直接将数据添加到num1后面，然后再进行排序，简单粗暴。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">  <span class="keyword">int</span> nums1Len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> nums2Len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (nums1Len &lt; m || nums2Len &lt; n) &#123;</span><br><span class="line">    <span class="comment">//如果其中一个长度超过指定长度，则不在增长</span></span><br><span class="line">    <span class="keyword">if</span> (nums1Len==m) &#123;</span><br><span class="line">      ints[i++] = nums2[nums2Len++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2Len == n) &#123;</span><br><span class="line">      ints[i++] = nums1[nums1Len++];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[nums1Len] &lt;= nums2[nums2Len]) &#123;</span><br><span class="line">      ints[i] = nums1[nums1Len];</span><br><span class="line">      i++;</span><br><span class="line">      nums1Len++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[nums1Len]&gt;=nums2[nums2Len])&#123;</span><br><span class="line">      ints[i] = nums2[nums2Len];</span><br><span class="line">      i++;</span><br><span class="line">      nums2Len++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m+n; j++) &#123;</span><br><span class="line">    nums1[j] = ints[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.6 MB, 在所有 Java 提交中击败了58.05%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 先定一个temp数组，遍历两个数组，将遍历出来的数据从小到大排列放在另一个数组中，最终将这个零时数组放到nums1中。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">  <span class="keyword">int</span> cur;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">      cur = nums2[p2++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">      cur = nums1[p1++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">      cur = nums1[p1++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = nums2[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">    nums1[i] = sorted[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了87.19%的用户</span><br></pre></td></tr></table></figure><p>总结：思想和我的第二种相同</p><h5 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> cur;</span><br><span class="line">  <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == -<span class="number">1</span>) &#123;</span><br><span class="line">      cur = nums2[p2--];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == -<span class="number">1</span>) &#123;</span><br><span class="line">      cur = nums1[p1--];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">      cur = nums1[p1--];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = nums2[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    nums1[tail--] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.6 MB, 在所有 Java 提交中击败了47.09%的用户</span><br></pre></td></tr></table></figure><p>总结：思想和路人解答差不多</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//先将多余长度部分添加进入</span></span><br><span class="line">  <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//找到大值并赋值，然后将下标减1</span></span><br><span class="line">    nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果nums2中下标没有为-1那么继续存储</span></span><br><span class="line">  <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    nums1[p--] = nums2[n--];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了62.56%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>从最高位判断开始，将大的先放置，依次从大到小放置，减少了中间变量。强！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序链表中的重复元素</title>
      <link href="2021/04/20/LeetCode/easy/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>2021/04/20/LeetCode/easy/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月20日</li><li>描述：天气貌似要开始变热了☀️</li></ul><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p><ol><li><strong>问题描述：</strong></li></ol><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/list1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/list2.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><p><strong>进阶：</strong> </p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">var</span> = head.val;</span><br><span class="line">  <span class="comment">//定义链表</span></span><br><span class="line">  ListNode listNode = <span class="keyword">new</span> ListNode(<span class="keyword">var</span>);</span><br><span class="line">  <span class="comment">//记录第一个链表的地址</span></span><br><span class="line">  ListNode l = listNode;</span><br><span class="line">  ListNode next = head.next;</span><br><span class="line">  <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">var</span> == next.val) &#123;</span><br><span class="line">      <span class="comment">//相等就跳过</span></span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> = next.val;</span><br><span class="line">      <span class="comment">//创建下一级链表</span></span><br><span class="line">      ListNode listNode1 = <span class="keyword">new</span> ListNode(<span class="keyword">var</span>);</span><br><span class="line">      <span class="comment">//指向下一级链表</span></span><br><span class="line">      listNode.next = listNode1;</span><br><span class="line">      <span class="comment">//将下一级链表赋值给当前链表</span></span><br><span class="line">      listNode = listNode1;</span><br><span class="line">      next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了33.88%的用户</span><br><span class="line">内存消耗：37.7 MB, 在所有 Java 提交中击败了90.14%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 一开始想着使用递归，但是不知道怎么实现，改为该种方式实现，由于使用循环判断，并进行赋值交替，导致性能很低。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录头节点</span></span><br><span class="line">  ListNode l = head;</span><br><span class="line">  <span class="comment">//零时的链表，用于向后遍历</span></span><br><span class="line">  ListNode listNode = head;</span><br><span class="line">  <span class="comment">//用于比较值是否相同</span></span><br><span class="line">  <span class="keyword">int</span> val = listNode.val;</span><br><span class="line">  <span class="keyword">while</span> (listNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    listNode = listNode.next;</span><br><span class="line">    <span class="keyword">int</span> val1 = listNode.val;</span><br><span class="line">    <span class="keyword">if</span> (val != val1) &#123;</span><br><span class="line">      val = val1;</span><br><span class="line">      head.next = listNode;</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//记得将后一个值清空，否则可能会产生最后的链表重复的情况</span></span><br><span class="line">      head.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了49.00%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 由于方式一创建了新对象，我就想着能不能不创建新对象的方式，于是有了第二种方式，性能大幅度提升，但是内存消耗却是有所下降。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">      cur.next = cur.next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了54.06%的用户</span><br></pre></td></tr></table></figure><p>总结：没次向后推一位，判断他和他的下一位是否相等，如果相等则将他的下一位复制为他的下下一位，如果不想等，那么直接将本身赋值为他的下一位。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  head.next = deleteDuplicates(head.next);</span><br><span class="line">  <span class="keyword">if</span>(head.val == head.next.val) head = head.next;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了49.99%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>最终，我还是在评论区看到了我想用却不知道怎么下手的递归。果然满地都是大神呢。从倒数第二个和倒数第一个开始比较，如果相同，链表就取后一个，不相同，就取后两个。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="2021/04/19/LeetCode/easy/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>2021/04/19/LeetCode/easy/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月19日</li><li>描述：今天略微疲惫😫🌧️</li></ul><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></p><ol><li><strong>问题描述：</strong></li></ol><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>通过计算发现，爬楼梯的次数总是等于n-1的次数加上n-2的次数，于是可得递归方式。</p><p>然后通过分析复杂度发现，有大量重复性的计算，所以采用<code>记忆递归法</code>。</p><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//将所有前几步的计算结果记录在该素组中，之后就无需再次计算</span></span><br><span class="line">  <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> cli(n,ints);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cli</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] me)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (me[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> me[n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    me[n] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">    me[n] = <span class="number">2</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    me[n] = cli(n - <span class="number">1</span>, me) + cli(n - <span class="number">2</span>, me);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> me[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.4 MB, 在所有 Java 提交中击败了16.96%的用户</span><br></pre></td></tr></table></figure><p>总结：采用递归的方式，但是常规的递归会存在大量的冗余计算，导致运行内存大量消耗，所以采用<code>记忆递归法</code></p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>动态规划</p><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    p = q; </span><br><span class="line">    q = r; </span><br><span class="line">    r = p + q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.1 MB, 在所有 Java 提交中击败了74.27%的用户</span><br></pre></td></tr></table></figure><p>总结：本题为典型的动态规划问题。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p>搞笑时刻</p><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: result = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: result = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: result = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: result = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: result = <span class="number">8</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: result = <span class="number">13</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: result = <span class="number">21</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: result = <span class="number">34</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: result = <span class="number">55</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: result = <span class="number">89</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>: result = <span class="number">144</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: result = <span class="number">233</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13</span>: result = <span class="number">377</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: result = <span class="number">610</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">15</span>: result = <span class="number">987</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: result = <span class="number">1597</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">17</span>: result = <span class="number">2584</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">18</span>: result = <span class="number">4181</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">19</span>: result = <span class="number">6765</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span>: result = <span class="number">10946</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">21</span>: result = <span class="number">17711</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">22</span>: result = <span class="number">28657</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">23</span>: result = <span class="number">46368</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">24</span>: result = <span class="number">75025</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">25</span>: result = <span class="number">121393</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">26</span>: result = <span class="number">196418</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">27</span>: result = <span class="number">317811</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">28</span>: result = <span class="number">514229</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">29</span>: result = <span class="number">832040</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">30</span>: result = <span class="number">1346269</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">31</span>: result = <span class="number">2178309</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>: result = <span class="number">3524578</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">33</span>: result = <span class="number">5702887</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">34</span>: result = <span class="number">9227465</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">35</span>: result = <span class="number">14930352</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">36</span>: result = <span class="number">24157817</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">37</span>: result = <span class="number">39088169</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">38</span>: result = <span class="number">63245986</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">39</span>: result = <span class="number">102334155</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">40</span>: result = <span class="number">165580141</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">41</span>: result = <span class="number">267914296</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">42</span>: result = <span class="number">433494437</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">43</span>: result = <span class="number">701408733</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">44</span>: result = <span class="number">1134903170</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">45</span>: result = <span class="number">1836311903</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.1 MB, 在所有 Java 提交中击败了79.53%的用户</span><br></pre></td></tr></table></figure><p><code>他个人总结：</code>长度较短的有限集合的解，可直接返回值，自己学习算法最终的目的还是为了更好地解决问题。</p><p>警醒自己不要沉迷于算法的精妙而忽视实际情况，上了很好的一课。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x 的平方根</title>
      <link href="2021/04/18/LeetCode/easy/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>2021/04/18/LeetCode/easy/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月18日</li><li>描述：🐷大猪来找我，一个周没写了，惭愧，今天又要开始继续，一天不能落。</li></ul><h3 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p><ol><li><strong>问题描述：</strong></li></ol><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> indx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">double</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">double</span>) x; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> a = i * i;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; (<span class="keyword">double</span>) x) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    indx = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) indx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：62 ms, 在所有 Java 提交中击败了5.00%的用户</span><br><span class="line">内存消耗：35.3 MB, 在所有 Java 提交中击败了88.80%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 暴力法，从零开始循环依次平方，找到刚好大于目标值的那个值。这执行用时，实在是拉垮。</p><p><strong>注意：</strong>这个int会存在值溢出的情况，刚开始就一直不对一直没想到是int值超过最大值的问题。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">      ans = mid;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.4 MB, 在所有 Java 提交中击败了81.84%的用户</span><br></pre></td></tr></table></figure><p>总结：性能是真的好。（二分法查找法自己还得练一下）</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> C = x, x0 = x;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x0 = xi;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.7 MB, 在所有 Java 提交中击败了29.51%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>牛顿迭代。内存消耗有点小高，但是相对于二分法是更快的。没看懂。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p>思路：</p><p><code>( 4 + 2/ 4 ) / 2 = 2.25</code></p><p><code>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..</code></p><p><code>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..</code></p><p><code>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..</code></p><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s=x;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)(sqrts(x)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = (x + s / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sqrts(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.3 MB, 在所有 Java 提交中击败了95.22%的用户</span><br></pre></td></tr></table></figure><p>`总结：递归牛顿迭代。很巧妙，突然觉得我的数学白学了。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制求和</title>
      <link href="2021/04/11/LeetCode/easy/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
      <url>2021/04/11/LeetCode/easy/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月11日</li><li>描述：周末了，结果我还是荒废了！</li></ul><h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> aLength = a.length()-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> bLength = b.length()-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (aLength &gt;= bLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> getAdd(a, b,aLength,bLength);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getAdd(b, b,bLength,aLength);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getAdd</span><span class="params">(String a,String b,<span class="keyword">int</span> aLength,<span class="keyword">int</span> bLength)</span> </span>&#123;</span><br><span class="line">  StringBuilder bf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; aLength &gt;= <span class="number">0</span>; aLength--,bLength--) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = Integer.parseInt(a.charAt(aLength)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//如果b的长度还不为0，那么继续加</span></span><br><span class="line">    <span class="keyword">if</span> (bLength &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> c1 = Integer.parseInt(b.charAt(bLength)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">      c = c + c1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c+前一位的进位</span></span><br><span class="line">    c = c + temp;</span><br><span class="line">    <span class="keyword">int</span> f = c%<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//检查是否需要进位</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      temp = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      temp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bf.append(f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">    bf.append(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bf.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：7 ms, 在所有 Java 提交中击败了11.23%的用户</span><br><span class="line">内存消耗：38.2 MB, 在所有 Java 提交中击败了70.53%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 本想用二进制方式解答，但是想了一会不会，就采用加法逻辑，从后往前加，总算是拼凑出结果，但是运行结果就很不进仁义了。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Integer.toBinaryString(</span><br><span class="line">    Integer.parseInt(a, <span class="number">2</span>) + Integer.parseInt(b, <span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>总结：当输入二进制字符串过长抱错（NumberFormatException），总体思路就是先将二进制字符串转化为数字相加再转化为为二进制。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">  StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> aLen = a.length();</span><br><span class="line">  <span class="keyword">int</span> bLen = b.length();</span><br><span class="line">  <span class="keyword">int</span> max = Math.max(aLen, bLen);</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="comment">//由于char类型的1转化为int为49，所以为了得到1进行减&#x27;0&#x27;处理</span></span><br><span class="line">    temp += aLen &gt; i ? a.charAt(aLen - i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">    temp += bLen &gt; i ? b.charAt(bLen - i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">    stringBuilder.append((<span class="keyword">char</span>)(temp%<span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    temp /= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    stringBuilder.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stringBuilder.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了98.67%的用户</span><br><span class="line">内存消耗：37.8 MB, 在所有 Java 提交中击败了77.47%的用户</span><br></pre></td></tr></table></figure><p>总结：想法和我的一摸一样，但是不得不承认，在实现方面比我强太多了。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length() == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="keyword">null</span> || b.length() == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">  StringBuilder stb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a.charAt(i --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b.charAt(j --) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    stb.append(c % <span class="number">2</span>);</span><br><span class="line">    c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String res = stb.reverse().toString();</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> + res : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了54.49%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了48.37%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>整体思路来说差不多，但是，这里的话将位运算应用其中，之前采用的是求余的到下一个进位数，该处使用右移一位得到进位数。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reids传统五大基本类型与落地应用</title>
      <link href="2021/04/10/redis/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
      <url>2021/04/10/redis/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Reids传统五大基本类型与落地应用"><a href="#Reids传统五大基本类型与落地应用" class="headerlink" title="Reids传统五大基本类型与落地应用"></a>Reids传统五大基本类型与落地应用</h4><p><a href="http://www.redis.cn/commands.html">官网命令大全</a></p><p>八大基本数据类型分别为：</p><ul><li>String（字符串类型）</li><li>Hash（散列类型）</li><li>List（列表类型）</li><li>Set（集合类型）</li><li>SortedSet（有序集合类型，简称zset）</li><li>Bitmap（位图）</li><li>HyperLogLog（统计）</li><li>GEO（地理）</li></ul><p>注意：在使用命令时，<strong>命令不区分大小写，但是key是区分大小写的</strong></p><h5 id="一、-String（字符串类型）"><a href="#一、-String（字符串类型）" class="headerlink" title="一、 String（字符串类型）"></a>一、 String（字符串类型）</h5><h6 id="1-、基础命令"><a href="#1-、基础命令" class="headerlink" title="1 、基础命令"></a>1 、基础命令</h6><ol><li>基础</li></ol><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set key value #设置一个key和value</span><br><span class="line">get key  #通过key获取value</span><br></pre></td></tr></table></figure><ol start="2"><li>同时设置获取多个键值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ....]</span><br><span class="line">mget key [key ....]</span><br></pre></td></tr></table></figure><ol start="3"><li>数值增减</li></ol><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incr key  #递增数字</span><br><span class="line">incrby key increment  #递增指定的整数</span><br><span class="line">decr key  #递减数字</span><br><span class="line">decrby key decrement  #递减指定的整数</span><br></pre></td></tr></table></figure><ol start="4"><li>获取字符串长度</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key  #获取字符串长度</span><br></pre></td></tr></table></figure><ol start="5"><li>分布式锁</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value #简写形式</span><br></pre></td></tr></table></figure><p><code>set key value [EX seconds][PX milliseconds][NX|XX]</code></p><ul><li>EX:：key在多少秒后过期</li><li>PX：key在多少毫秒后过期</li><li>NX：当key不存在的时候才创建key，效果等同于<code>setnx</code></li><li>XX：当key存在的时候覆盖key</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> lock pay ex 20 NX</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get lock</span></span><br><span class="line">pay</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> lock order ex 20 NX</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> lock pay ex 20 NX</span></span><br><span class="line">null</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get lock</span></span><br><span class="line">order</span><br></pre></td></tr></table></figure><h6 id="2、-应用场景"><a href="#2、-应用场景" class="headerlink" title="2、 应用场景"></a>2、 应用场景</h6><ol><li>商品编号、订单编号采用incr自动生成</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> incr item:1</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incr item:1</span></span><br><span class="line">2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incr item:1</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>2、对于某一浏览次数的统计采用incr自动递增</p><p>如只要点击了rest地址，就直接使用incr key命令增加1，完成统计浏览次数的统计。</p><h5 id="二、Hash（散列类型）"><a href="#二、Hash（散列类型）" class="headerlink" title="二、Hash（散列类型）"></a>二、Hash（散列类型）</h5><p>hash其实就可以看成是一个<code>Map&lt;String,Map&lt;Object,Object&gt;&gt;</code></p><h6 id="1、基础命令"><a href="#1、基础命令" class="headerlink" title="1、基础命令"></a>1、基础命令</h6><ol><li>一次设置一个字段值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><ol start="2"><li>一次获取一个字段值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br></pre></td></tr></table></figure><ol start="3"><li>一次设置多个字段值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field value [field value ...]</span><br></pre></td></tr></table></figure><ol start="4"><li>一次获取多个字段值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ....]</span><br></pre></td></tr></table></figure><ol start="5"><li>获取所有字段值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure><ol start="6"><li>获取某个key内的全部数量</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen</span><br></pre></td></tr></table></figure><ol start="7"><li>删除一个key</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel</span><br></pre></td></tr></table></figure><h6 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h6><p>早期在购物车中中使用</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hset shopcar:uid1024 334488 1  #新增商品</span><br><span class="line">hset shopcar:uid1024 334477 1  #新增商品</span><br><span class="line">hincrby shopcar:uid1024 334477 1  #增加商品数量</span><br><span class="line">hlen shopcar:uid1024     #商品总数</span><br><span class="line">hgetall shopcar:uid1024   #全部选择</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/hash%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="hash应用场景" style="zoom:50%;" /><h5 id="三、List（列表类型）"><a href="#三、List（列表类型）" class="headerlink" title="三、List（列表类型）"></a>三、List（列表类型）</h5><h6 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h6><ol><li>向列表左边添加元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>向列表右边添加元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ....]</span><br></pre></td></tr></table></figure><ol start="3"><li>查看列表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop</span><br></pre></td></tr></table></figure><ol start="4"><li>获取列表中元素的个数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure><h6 id="2、应用场景-1"><a href="#2、应用场景-1" class="headerlink" title="2、应用场景"></a>2、应用场景</h6><p>例如微信文章订阅公众号</p><p>如果现在发布了两篇文章id分别为11和12，那么就会执行：<code>lpush likearticle:自己id 11 12</code>，如果想分页查看自己订阅的文章<code>lrange </code> likearticle:自己id  0 10</p><h5 id="四、Set（集合类型）"><a href="#四、Set（集合类型）" class="headerlink" title="四、Set（集合类型）"></a>四、Set（集合类型）</h5><h6 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h6><ol><li>添加元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member[member ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>删除元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member [member ...]</span><br></pre></td></tr></table></figure><ol start="3"><li>获取集合中的所有元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><ol start="4"><li>判断元素是否在集合中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><ol start="5"><li>获取集合中的元素个数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure><ol start="6"><li>从集合中随机弹出一个元素，元素不删除</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [数字]  </span><br></pre></td></tr></table></figure><ol start="7"><li>从集合中随机弹出一个元素，出一个删一个</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [数字]</span><br></pre></td></tr></table></figure><ol start="8"><li>集合运算</li></ol><ul><li>集合的差集运算A-B(<code>属于A但不属于B的元素构成的集合</code>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ...]</span><br></pre></td></tr></table></figure><ul><li>集合的交集运算A∩B(<code>属于A同时也属于B的共同拥有的元素构成的集合</code>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...]</span><br></pre></td></tr></table></figure><ul><li>集合的并集运算AUB(<code>属于A或者属于B的元素合并后的集合</code>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ...]</span><br></pre></td></tr></table></figure><h6 id="2、应用场景-2"><a href="#2、应用场景-2" class="headerlink" title="2、应用场景"></a>2、应用场景</h6><ol><li>微信抽奖小程序</li></ol><p><code>图示</code></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/set%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" style="zoom:50%;" /><table><thead><tr><th>操作</th><th>语句</th></tr></thead><tbody><tr><td>用户ID，立即参与按钮</td><td>sadd key 用户ID</td></tr><tr><td>显示已经有多少人参与了，上图23208人参加</td><td>scard key</td></tr><tr><td>抽奖(从set中任意选取N个中奖人)</td><td>srandmember key 2   随机抽奖2个人，元素不删除</td></tr></tbody></table><ol start="2"><li>微信朋友圈点赞</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/set%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF2.png" style="zoom:50%;" /><table><thead><tr><th>操作</th><th>语句</th></tr></thead><tbody><tr><td>新增点赞</td><td>sadd pub:msgID 点赞用户ID1 点赞用户ID2</td></tr><tr><td>取消点赞</td><td>srem pub:msgID 点赞用户ID</td></tr><tr><td>展现所有点赞的用户</td><td>smembers pub:msgID</td></tr><tr><td>点赞用户数统计</td><td>scard pub:msgID</td></tr><tr><td>判断某个朋友是否对楼主点过赞</td><td>sismember pub:msgID 用户ID</td></tr></tbody></table><ol start="3"><li>微博好友关注社交关系</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/set%E6%BC%94%E7%A4%BA%E5%9C%BA%E6%99%AF3.png" style="zoom:50%;" /><ul><li>共同关注的人</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;sadd s1 1 2 3 4 5</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sadd s2 3 4 5 6 7</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sinter s1 s2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;5&quot;</span><br></pre></td></tr></table></figure><p><strong>共同关注:</strong> <code>我去到局座张召忠的微博，马上获得我和局座共同关注的人</code></p><ul><li>我关注的人也关注他(大家爱好相同)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;sadd s1 1 2 3 4 5</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sadd s2 3 4 5 6 7</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sismember s1 3</span><br><span class="line">(intege)1</span><br><span class="line">127.0.0.1:6379&gt;sismember s2 3</span><br><span class="line">(intege)1</span><br></pre></td></tr></table></figure><p><strong>共同爱好：</strong> <code>我关注了华为余承东，余承东也关注了局座召忠，我和余总有共同的爱好</code></p><ul><li>QQ内推可能认识的人</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;sadd s1 1 2 3 4 5</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sadd s2 3 4 5 6 7</span><br><span class="line">(intege)5</span><br><span class="line">127.0.0.1:6379&gt;sdiff s1 s2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt;sdiff s2 s1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;7&quot;</span><br></pre></td></tr></table></figure><h5 id="五、SortedSet（有序集合类型，简称zset）"><a href="#五、SortedSet（有序集合类型，简称zset）" class="headerlink" title="五、SortedSet（有序集合类型，简称zset）"></a>五、SortedSet（有序集合类型，简称zset）</h5><h6 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h6><ol><li>添加元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>按照元素分数从小到大的顺序 返回索引从start到stop之间的所有元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><ol start="3"><li>获取元素的分数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure><ol start="4"><li>删除元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure><ol start="5"><li>获取指定分数范围的元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure><ol start="6"><li>增加某个元素的分数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure><ol start="7"><li>获取集合中元素的数量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure><ol start="8"><li>获得指定分数范围内的元素个数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><ol start="9"><li>按照排名范围删除元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br></pre></td></tr></table></figure><ol start="10"><li>获取元素的排名</li></ol><ul><li>从小到大</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br></pre></td></tr></table></figure><ul><li>从大到小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure><h6 id="2、应用场景-3"><a href="#2、应用场景-3" class="headerlink" title="2、应用场景"></a>2、应用场景</h6><ol><li>根据商品销售对商品进行排序显示</li></ol><p><strong>思路:</strong> 定义商品销售排行榜(sorted set集合)，key为goods:sellsort，分数为商品销售数量。</p><table><thead><tr><th>操作</th><th>语句</th></tr></thead><tbody><tr><td>商品编号1001的销量是9，商品编号1002的销量是15</td><td>zadd goods:sellsort 9 1001 15 1002</td></tr><tr><td>有一个客户又买了2件商品1001，商品编号1001销量加2</td><td>zincrby goods:sellsort 2 1001</td></tr><tr><td>求商品销量前10名</td><td>zrange goods:sellsort 0 10 withscores</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;zadd goods:sellsort 9 1001 15 1002</span><br><span class="line">(intege)2</span><br><span class="line">127.0.0.1:6379&gt;range goods:sellsort 0 10 withscores</span><br><span class="line">1) &quot;1001&quot;</span><br><span class="line">2) &quot;9&quot;</span><br><span class="line">3) &quot;1002&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line">127.0.0.1:6379&gt;zincrby goods:sellsort 2 1001</span><br><span class="line">&quot;11&quot;</span><br><span class="line">127.0.0.1:6379&gt;range goods:sellsort 0 10 withscores</span><br><span class="line">1) &quot;1001&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;1002&quot;</span><br><span class="line">4) &quot;15&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>抖音热搜</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/zset%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" style="zoom:50%;" /><table><thead><tr><th>操作</th><th>语句</th></tr></thead><tbody><tr><td>点击视频</td><td>zincrby hotvcr:20200919 1八佰 <br />zincrby hotvcr:20200919 15 八佰 2 花木兰</td></tr><tr><td>展示当日排行前10条</td><td>zrevrange hotvcr:20200919 0 9 withscores</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加一</title>
      <link href="2021/04/10/LeetCode/easy/%E5%8A%A0%E4%B8%80/"/>
      <url>2021/04/10/LeetCode/easy/%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月10日</li><li>描述：打了会球⚽️，有点儿疲惫，差点就忘记了。</li></ul><h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/plus-one/">加一</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits &#x3D; [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提示</strong></li></ol><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code> </li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">  test(digits,digits.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//判断后面是不是都是0，如果是，说明所有都加了一遍，那么首位也需要加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      b = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断第一位是不是9，如果是，那么说明数组长度不够，得扩容</span></span><br><span class="line">  <span class="keyword">if</span> (b  &amp;&amp; digits[<span class="number">0</span>] == <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="comment">//说明数组位数不够，得扩容</span></span><br><span class="line">    digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    digits[<span class="number">0</span>]++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b)&#123;</span><br><span class="line">    digits[<span class="number">0</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归从后面开始，使每个加一处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] digits,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="comment">//当长度为0时结束</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果等于9说明上一项依旧需要进行变化</span></span><br><span class="line">  <span class="keyword">if</span> (digits[len] == <span class="number">9</span>) &#123;</span><br><span class="line">    digits[len] = <span class="number">0</span>;</span><br><span class="line">    test(digits, --len);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    digits[len]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.5 MB, 在所有 Java 提交中击败了99.69%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 看到个for循环，想着效率应该很拉垮，但是没想到效果居然还很好。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>其实就是对方法一的改进</code></p><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">  <span class="keyword">int</span> len = test(digits,digits.length - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//通过返回的长度进行判断修改了多少个数字。</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>  &amp;&amp; digits[<span class="number">0</span>] == <span class="number">9</span>) &#123;</span><br><span class="line">    digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    digits[<span class="number">0</span>]++;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">    digits[<span class="number">0</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回长度，可进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] digits,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (digits[len] == <span class="number">9</span>) &#123;</span><br><span class="line">    digits[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> test(digits, --len);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    digits[len]++;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37 MB, 在所有 Java 提交中击败了48.27%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 由于有个for循环，就只是为了得到后面修改了几次，总感觉有些不妥，修改为现在版本，本想着代码量更少，还减少了一个for循环，谁知运行多次，内存消耗都远远高于之前的。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    digits[i]++;</span><br><span class="line">    digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">  &#125;</span><br><span class="line">  digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">  digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.8 MB, 在所有 Java 提交中击败了87.16%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>使用for从后面开始修改（修改方式是先加一，再求于赋值），然后判断刚刚赋值的是不是0，如果是，就需要进位，如果不是几句退出返回结果，如果循环结束都还是0，那么说明长度不够需要扩容。妙哉啊！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后一个单词的长度</title>
      <link href="2021/04/09/LeetCode/easy/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2021/04/09/LeetCode/easy/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月9日</li><li>描述：小雨🌧️，今天算是拿到正式工资的第一天，很开心，但是依旧还是要努力加油！</li></ul><h3 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p><strong>单词</strong>是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; &quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  String trim = s.trim();</span><br><span class="line">  <span class="keyword">if</span> (trim.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> s1[s1.length-<span class="number">1</span>].length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了38.58%的用户</span><br><span class="line">内存消耗：37 MB, 在所有 Java 提交中击败了30.20%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 去掉首尾空格后通过空格进行拆分，拿到最后一个便是最后一个单词然后得出长度，暴力法。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> num;</span><br><span class="line">           &#125;</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.5 MB, 在所有 Java 提交中击败了89.60%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 去掉首尾空格，然后从后面开始遍历，当拿到第一个空格，结束循环，得到长度。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> start = end;</span><br><span class="line">  <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">    start--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> end-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.6 MB, 在所有 Java 提交中击败了86.35%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>思路和我的相同，先截取后段的空串，得到截取后的长度，然后再得到最后一个空串的长度，得到最后的单词长度为去除末尾空格的长度减最后一个空格的长度。</p><h5 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.5 MB, 在所有 Java 提交中击败了89.35%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>想法和我一摸一样，但是，在去除末尾空串方面比我做的更精巧，很值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子序和</title>
      <link href="2021/04/08/LeetCode/easy/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>2021/04/08/LeetCode/easy/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月8日</li><li>描述：不辜负每一天！</li></ul><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 </span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><ol start="6"><li><p><strong>示例5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure></li><li><p><strong>提示</strong></p></li></ol><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong> 如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 = nums[i];</span><br><span class="line">    sum = Math.max(sum, sum1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      sum1 += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; sum1) &#123;</span><br><span class="line">        sum = sum1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：139 ms, 在所有 Java 提交中击败了5.01%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了34.69%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 双层for循环，将所有结果计算出来然后取最大值，虽然可行，但是纯属垃圾代码。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    pre = Math.max(pre + num, num);</span><br><span class="line">    sum = Math.max(pre, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了94.77%的用户</span><br><span class="line">内存消耗：38.1 MB, 在所有 Java 提交中击败了95.37%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 引入一个变量pre，用于记录累加过程中的最大值，也就是说，该pre起到一个记录的作用，如果pre加上后一个值如果大于后一个值的话，就说明连续先加在变大，并且继续将改pre的值记录到下下一个中进行同样的比较，甚是秒啊！</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Status</span><span class="params">(<span class="keyword">int</span> lSum, <span class="keyword">int</span> rSum, <span class="keyword">int</span> mSum, <span class="keyword">int</span> iSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lSum = lSum;</span><br><span class="line">    <span class="keyword">this</span>.rSum = rSum;</span><br><span class="line">    <span class="keyword">this</span>.mSum = mSum;</span><br><span class="line">    <span class="keyword">this</span>.iSum = iSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>).mSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(a[l], a[l], a[l], a[l]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  Status lSub = getInfo(a, l, m);</span><br><span class="line">  Status rSub = getInfo(a, m + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">  <span class="keyword">int</span> lSum = Math.max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">  <span class="keyword">int</span> rSum = Math.max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">  <span class="keyword">int</span> mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Status(lSum, rSum, mSum, iSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了12.24%的用户</span><br><span class="line">内存消耗：39.1 MB, 在所有 Java 提交中击败了5.22%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 分治法，看不懂，不敢多加评论！</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">      sum += num;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sum = num;</span><br><span class="line">    res = Math.max(res, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了94.77%的用户</span><br><span class="line">内存消耗：38.5 MB, 在所有 Java 提交中击败了27.95%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>其实思路的话和官方解答一的方式差不多，只不过，这里进行了一些其他操作，就是如果下一个值为负，是没有必要使用前一个去与之相加的，因为就算想加也一定会比前一个小。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观数列</title>
      <link href="2021/04/07/LeetCode/easy/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
      <url>2021/04/07/LeetCode/easy/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月7日</li><li>描述：第一页的简单题快刷完了，加油，坚持下去哦！</li></ul><h4 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h4><p>原文链接：<a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n) </code>是对<code> countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。<br>前五项如下：</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure><p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><p>例如，数字字符串 &quot;3322251&quot; 的描述如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/count-and-say.png"></p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; 读 &quot;1&quot; &#x3D; 一 个 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; 读 &quot;11&quot; &#x3D; 二 个 1 &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; 读 &quot;21&quot; &#x3D; 一 个 2 + 一 个 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String s = countAndSay(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 112111</span></span><br><span class="line">    <span class="comment">//对字符串进行计数</span></span><br><span class="line">    <span class="keyword">return</span> num(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">num</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> i = str.charAt(<span class="number">0</span>);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//统计出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//标识符，记录长度是否大于1   主要是用于最后一个字符的判断</span></span><br><span class="line">    <span class="keyword">int</span> indx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">        indx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (c == i) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(num).append(i);</span><br><span class="line">            <span class="comment">//将i替换</span></span><br><span class="line">            i = c;</span><br><span class="line">            <span class="comment">//出现次数回归</span></span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (indx == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//该处统计得到最后一个字符出现的次数</span></span><br><span class="line">        builder.append(num).append(str.charAt(str.length() - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//统计从长度为1的时候</span></span><br><span class="line">        builder.append(num).append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了97.30%的用户</span><br><span class="line">内存消耗：36 MB, 在所有 Java 提交中击败了75.10%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 想了很久，最后还是做出来了，但是总感觉哪里还是有些不完美，但是勉勉强强算是过来了。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     String s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">         s = describe(s);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">        res.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == s.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                res.append(num);</span><br><span class="line">                res.append(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(num);</span><br><span class="line">            res.append(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == s.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                res.append(<span class="number">1</span>);</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了97.30%的用户</span><br><span class="line">内存消耗：36.1 MB, 在所有 Java 提交中击败了61.31%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>整体来说，思路大体相同，但是只是在对字符串处理方向有些略微的差异，这也是引起内存消耗差异的主要原因。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (n) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;21&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;111221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;312211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;13112221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1113213211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;31131211131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;13211311123113112211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11131221133112132113212221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;3113112221232112111312211312113211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1321132132111213122112311311222113111221131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11131221131211131231121113112221121321132132211331222113112211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;311311222113111231131112132112311321322112111312211312111322212311322113212221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">28</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">29</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221&quot;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211&quot;</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.8 MB, 在所有 Java 提交中击败了95.34%的用户</span><br></pre></td></tr></table></figure><p><code>总结</code> 最牛方式，不用质疑。很明显是大佬做好运行出来结果后娱乐用，勿喷！</p><p>开心一下，优秀评论：</p><ul><li>看见没，这叫人工智能</li><li>大佬不妨找六片铁板把自己裹起来——次时代计算机诞生了</li><li>面向测试用例编程，果然大佬</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置</title>
      <link href="2021/04/06/LeetCode/easy/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>2021/04/06/LeetCode/easy/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月6日</li><li>描述：加油呀加油！</li></ul><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/search-insert-position/">合并两个有序链表</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><ol start="2"><li><strong>实例1</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例5：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></li></ol><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> indx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> indx;</span><br><span class="line">        &#125;</span><br><span class="line">        indx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.8 MB, 在所有 Java 提交中击败了96.99%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 该题确实有点简单，由于原数组已经排序好了，且保证不会重复，那么。我们只需要对其进行遍历，并对下标进行记录，得到刚刚好大于目标值的那个数组中的值，即直接取记录的下标即可。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.2 MB, 在所有 Java 提交中击败了37.46%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>二分法查找的方式，刚刚开始，我也打算使用二分法的方式进行查找，但是，后来不知如何计数的下标就没从这方面下手。官方二分法采用下标的方式进行遍历，再使用值进行比较，实属秒啊！</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了88.04%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>思想和我一样，只不过将我定义的多余的变量去掉，变得更加简洁</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩文件相关工具类</title>
      <link href="2021/04/05/Java/utils/%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/05/Java/utils/%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>日期：2021年4月5日</p></li><li><p>天气：☁️阴</p></li></ul><h2 id="压缩文件相关工具类"><a href="#压缩文件相关工具类" class="headerlink" title="压缩文件相关工具类"></a>压缩文件相关工具类</h2><blockquote><p>由于项目生产环境无法联网，然而项目启动又依赖于某些数据，故一些相应的数据（比如minio中存储的数据）必须做相应的导出之磁盘，然后再到相应的环境中进行导入，为方便数据传输，使用zip文件进行存储！为方便下次使用，故作此笔记。</p></blockquote><h4 id="1-压缩文件"><a href="#1-压缩文件" class="headerlink" title="1 压缩文件"></a>1 压缩文件</h4><p>以下为网上查找到相关的一些工具类，包括对多个文件压缩，文件夹压缩等多种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> sph</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/3/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 将文件保存为压缩包工具类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipMultiFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">2</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个文件流写成文件并打成zip包</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  key 存储在压缩包中的文件名字  value   要储存的文件流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFilePath  压缩包存储的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFilesByInputStream</span><span class="params">(Map&lt;String,InputStream&gt; map, String zipFilePath)</span></span>&#123;</span><br><span class="line">        File zipFile = <span class="keyword">new</span> File(zipFilePath);</span><br><span class="line">        <span class="comment">// 判断压缩后的文件存在不，不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span> (!zipFile.exists()) &#123;</span><br><span class="line">            <span class="comment">//先创建目录</span></span><br><span class="line">            File fileParent = zipFile.getParentFile();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!fileParent.exists())&#123;</span><br><span class="line">                    fileParent.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                zipFile.createNewFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 FileOutputStream 对象</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建 ZipOutputStream</span></span><br><span class="line">        ZipOutputStream zipOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建 FileInputStream 对象</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化 FileOutputStream 对象</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(zipFile);</span><br><span class="line">            <span class="comment">// 实例化 ZipOutputStream 对象</span></span><br><span class="line">            zipOutputStream = <span class="keyword">new</span> ZipOutputStream(fileOutputStream);</span><br><span class="line">            <span class="comment">// 创建 ZipEntry 对象</span></span><br><span class="line">            ZipEntry zipEntry = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 遍历源文件数组</span></span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String, InputStream&gt; entry : map.entrySet())&#123;</span><br><span class="line">                inputStream = entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.isEmpty(inputStream)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 实例化 ZipEntry 对象，源文件数组中的当前文件</span></span><br><span class="line">                zipEntry = <span class="keyword">new</span> ZipEntry(entry.getKey());</span><br><span class="line">                zipOutputStream.putNextEntry(zipEntry);</span><br><span class="line">                <span class="comment">// 该变量记录每次真正读的字节个数</span></span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="comment">// 定义每次读取的字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    zipOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.isNotEmpty(zipOutputStream)) &#123;</span><br><span class="line">                    zipOutputStream.closeEntry();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.isNotEmpty(zipOutputStream)) &#123;</span><br><span class="line">                    zipOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.isNotEmpty(inputStream)) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.isNotEmpty(fileOutputStream)) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩成ZIP 方法1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFile 压缩文件夹路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out  压缩文件输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> KeepDirStructure 是否保留原来的目录结构,true:保留目录结构;</span></span><br><span class="line"><span class="comment">     *             false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RuntimeException 压缩失败会抛出运行时异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toZip</span><span class="params">(File sourceFile, OutputStream out, <span class="keyword">boolean</span> KeepDirStructure)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RuntimeException</span>&#123;</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zos = <span class="keyword">new</span> ZipOutputStream(out);</span><br><span class="line">            compress(sourceFile,zos,sourceFile.getName(),KeepDirStructure);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;zip error from ZipUtils&quot;</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(zos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩成ZIP 方法2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFiles 需要压缩的文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out      压缩文件输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RuntimeException 压缩失败会抛出运行时异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toZip</span><span class="params">(List&lt;File&gt; srcFiles , OutputStream out)</span><span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ZipOutputStream zos = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zos = <span class="keyword">new</span> ZipOutputStream(out);</span><br><span class="line">            <span class="keyword">for</span> (File srcFile : srcFiles) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">                zos.putNextEntry(<span class="keyword">new</span> ZipEntry(srcFile.getName()));</span><br><span class="line">                zos.setMethod(ZipOutputStream.DEFLATED);</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                FileInputStream in = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">                <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    zos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;压缩完成，耗时：&quot;</span> + (end - start) +<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;zip error from ZipUtils&quot;</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(zos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归压缩方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFile 源文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zos    zip输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name    压缩后的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> KeepDirStructure 是否保留原来的目录结构,true:保留目录结构;</span></span><br><span class="line"><span class="comment">     *             false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(File sourceFile, ZipOutputStream zos, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> KeepDirStructure)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">if</span>(sourceFile.isFile())&#123;</span><br><span class="line">            <span class="comment">// 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字</span></span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name));</span><br><span class="line">            <span class="comment">// copy文件到zip输出流中</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                zos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Complete the entry</span></span><br><span class="line">            zos.closeEntry();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] listFiles = sourceFile.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(listFiles == <span class="keyword">null</span> || listFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 需要保留原来的文件结构时,需要对空文件夹进行处理</span></span><br><span class="line">                <span class="keyword">if</span>(KeepDirStructure)&#123;</span><br><span class="line">                    <span class="comment">// 空文件夹的处理</span></span><br><span class="line">                    zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name + <span class="string">&quot;/&quot;</span>));</span><br><span class="line">                    <span class="comment">// 没有文件，不需要文件的copy</span></span><br><span class="line">                    zos.closeEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : listFiles) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否需要保留原来的文件结构</span></span><br><span class="line">                    <span class="keyword">if</span> (KeepDirStructure) &#123;</span><br><span class="line">                        <span class="comment">// 注意：file.getName()前面需要带上父文件夹的名字加一斜杠,</span></span><br><span class="line">                        <span class="comment">// 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了</span></span><br><span class="line">                        compress(file, zos, name + <span class="string">&quot;/&quot;</span> + file.getName(),KeepDirStructure);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        compress(file, zos, file.getName(),KeepDirStructure);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/** 测试压缩方法1 */</span></span><br><span class="line">        FileOutputStream fos1 = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:/mytest01.zip&quot;</span>));</span><br><span class="line">        testZip.toZip(<span class="keyword">new</span> File(<span class="string">&quot;D:/FingerData&quot;</span>), fos1,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2 解压压缩包"></a>2 解压压缩包</h4><h5 id="2-1-对压缩文件进行解压"><a href="#2-1-对压缩文件进行解压" class="headerlink" title="2.1 对压缩文件进行解压"></a>2.1 对压缩文件进行解压</h5><p><a href="https://blog.csdn.net/superbeyone/article/details/88978842">参考</a></p><p><code>依赖</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-compress<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>解压工具类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件解压缩工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUnpackUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩tar以及tar.gz文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file tar以及tar.gz文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpackTarGz</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        unpackTarGz(file, file.getParentFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩tar以及tar.gz文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile  tar以及tar.gz文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destFile 目标文件保存地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpackTarGz</span><span class="params">(File srcFile, File destFile)</span> </span>&#123;</span><br><span class="line">        TarInputStream tarIn = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tarIn = <span class="keyword">new</span> TarInputStream(<span class="keyword">new</span> GZIPInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(srcFile))), <span class="number">1024</span> * <span class="number">2</span>);</span><br><span class="line">            createDirectory(destFile, <span class="keyword">null</span>);<span class="comment">//创建输出目录</span></span><br><span class="line">            TarEntry entry = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((entry = tarIn.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory()) &#123;<span class="comment">//是目录</span></span><br><span class="line">                    entry.getName();</span><br><span class="line">                    createDirectory(destFile, entry.getName());<span class="comment">//创建空目录</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//是文件</span></span><br><span class="line">                    File tmpFile = <span class="keyword">new</span> File(destFile, entry.getName());</span><br><span class="line">                    <span class="comment">//创建输出目录</span></span><br><span class="line">                    createDirectory(tmpFile.getParentFile(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    out = <span class="keyword">new</span> FileOutputStream(tmpFile);</span><br><span class="line">                    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                    <span class="keyword">while</span> ((length = tarIn.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        out.write(b, <span class="number">0</span>, length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tarIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tarIn.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩zip文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file    zip文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset 字符编码 window系统中文适用GB2312能解决乱码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpackZip</span><span class="params">(File file, String charset)</span> </span>&#123;</span><br><span class="line">        unpackZip(file, file.getParentFile(), charset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩zip文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile  zip文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destFile 解压缩后存放地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset  字符编码 window系统中文适用GB2312能解决乱码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpackZip</span><span class="params">(File srcFile, File destFile, String charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            destFile = <span class="keyword">new</span> File(srcFile.getParentFile(), srcFile.getName().substring(<span class="number">0</span>, srcFile.getName().lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        ZipFile zipFile = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Charset decoding = Charset.forName(charset);</span><br><span class="line">            zipFile = <span class="keyword">new</span> ZipFile(srcFile, decoding);</span><br><span class="line">            createDirectory(destFile);</span><br><span class="line">            Enumeration&lt;?&gt; enums = zipFile.entries();</span><br><span class="line">            <span class="keyword">while</span> (enums.hasMoreElements()) &#123;</span><br><span class="line">                ZipEntry entry = (ZipEntry) enums.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (entry.isDirectory()) &#123;<span class="comment">//是目录</span></span><br><span class="line">                    createDirectory(destFile, entry.getName());<span class="comment">//创建空目录</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//是文件</span></span><br><span class="line">                    File tmpFile = <span class="keyword">new</span> File(destFile, entry.getName());</span><br><span class="line">                    <span class="keyword">if</span> (!tmpFile.getParentFile().exists()) &#123;</span><br><span class="line">                        tmpFile.getParentFile().mkdirs();</span><br><span class="line">                    &#125;</span><br><span class="line">                    in = zipFile.getInputStream(entry);</span><br><span class="line">                    out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmpFile));</span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                    <span class="keyword">while</span> ((len = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDirectory</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        createDirectory(file, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDirectory</span><span class="params">(File file, String subDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(subDir == <span class="keyword">null</span> || subDir.trim().equals(<span class="string">&quot;&quot;</span>))) &#123;<span class="comment">//子目录不为空  </span></span><br><span class="line">            file = <span class="keyword">new</span> File(file, subDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">                file.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-MultipartFile转化为File工具类"><a href="#2-2-MultipartFile转化为File工具类" class="headerlink" title="2.2 MultipartFile转化为File工具类"></a>2.2 MultipartFile转化为File工具类</h5><p>由于使用SpringBoot上传压缩包，并且需要上传过程中解析得到里面的内容，由于需要解析就需要用到File对象或者文件地址，但是由于MultipartFile 无法直接获得File对象和文件地址，故将文件先保存为一个临时文件，用完后直接删除该零时文件</p><p><a href="https://blog.csdn.net/u012279452/article/details/92840583">参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将MultipartFile转化为File工具类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipartFileToFile</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MultipartFile 转 File</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">multipartFileToFile</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        File toFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.equals(<span class="string">&quot;&quot;</span>) || file.getSize() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            file = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">null</span>;</span><br><span class="line">            ins = file.getInputStream();</span><br><span class="line">            toFile = <span class="keyword">new</span> File(file.getOriginalFilename());</span><br><span class="line">            inputStreamToFile(ins, toFile);</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toFile;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取流文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputStreamToFile</span><span class="params">(InputStream ins, File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = ins.read(buffer, <span class="number">0</span>, <span class="number">8192</span>)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除本地临时文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delteTempFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">        File del = <span class="keyword">new</span> File(file.toURI());</span><br><span class="line">        del.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> util </category>
          
          <category> zip文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现strStr()</title>
      <link href="2021/04/04/LeetCode/easy/%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>2021/04/04/LeetCode/easy/%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年4月4日</li><li>描述：好几天没写了，今天可不能再休息了</li></ul><h4 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h4><p>原文链接：<a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p><ol><li><strong>问题描述：</strong></li></ol><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p></li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (needle == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(needle)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!haystack.contains(needle)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> length = needle.length();</span><br><span class="line">  <span class="keyword">char</span> c = needle.charAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= haystack.length() - length; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> c1 = haystack.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c == c1) &#123;</span><br><span class="line">      String substring = haystack.substring(i, i + length);</span><br><span class="line">      <span class="keyword">if</span> (needle.equals(substring)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.8 MB, 在所有 Java 提交中击败了94.71%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 刚开始想了很久，但是总是没有好的思路，休息了一会回来，突然想到并不是所有都需要判断，所以加上了contains的语句，然后，接下来判断原语句中必然存在相等的代码块，只需要找出位置即可，但是，由于可以走到下面的，必然会至少存在一个，所以直接取出第一个，只有第一个相等了在进行截取，可以很大程度的剔除不满足的目标。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = needle.length();</span><br><span class="line">  <span class="keyword">int</span> n = haystack.length();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; start++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.6 MB, 在所有 Java 提交中击败了17.15%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>和我的想法差不多，只不过我添加相应的执行条件，而他直接不管什么时候都是直接执行的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除有序数组中的重复项</title>
      <link href="2021/03/30/LeetCode/easy/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2021/03/30/LeetCode/easy/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月25日</li><li>描述：虽然博客坏了，但是不影响我继续开发的动力</li></ul><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><code>说明:</code></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><code>0 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="comment">//记录当前位置的值</span></span><br><span class="line">    <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">    str.append(temp);</span><br><span class="line">    <span class="comment">//记录有几位是相同的</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录长度</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记录当前执行到的长度</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length &amp;&amp; ++s &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (temp == num) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                nums[j-count] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            i = i - count;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            str.append(<span class="string">&quot;,&quot;</span>).append(temp);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    System.out.println(str.toString());</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：186 ms, 在所有 Java 提交中击败了5.00%的用户</span><br><span class="line">内存消耗：39.9 MB, 在所有 Java 提交中击败了95.86%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 不是我想吐槽什么，说实话，现在写出来了，可能两天后来看就不知道我写的是什么了。如此拉跨的执行用时。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：40.3 MB, 在所有 Java 提交中击败了45.07%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>采用双指针的方式，代码简单易懂，很值得学习。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用双指针</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了80.99%的用户</span><br><span class="line">内存消耗：40.1 MB, 在所有 Java 提交中击败了89.14%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>采用while循环的双指针，i记录不重复的数组下标，j记录执行的次数。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="2021/03/30/LeetCode/easy/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>2021/03/30/LeetCode/easy/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月31日</li><li>描述：今天也是要努力的一天</li></ul><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><code>说明:</code></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3</span><br><span class="line">输出：2, nums &#x3D; [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2</span><br><span class="line">输出：5, nums &#x3D; [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != val) &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.9 MB, 在所有 Java 提交中击败了84.26%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 有了<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a>的灵感之后，学会了使用双指针的方法进行结题，也算是一种提升。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.8 MB, 在所有 Java 提交中击败了93.27%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>另一种双指针发，说实话，有点小难懂。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.9 MB, 在所有 Java 提交中击败了81.03%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>仔细一看，其实就是和我们写的一样，没啥区别。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序链表</title>
      <link href="2021/03/29/LeetCode/easy/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>2021/03/29/LeetCode/easy/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月29日</li><li>描述：努力，只为遇见最美好的一天</li></ul><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><ol><li><strong>问题描述：</strong></li></ol><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/merge_ex1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提示</strong></li></ol><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode result = listNode;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            result.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        result = result.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.next = l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了37.39%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 对链表使用不熟悉，想了很久还是没做出来，最后看了答案，发现思路相同，但是链表实现有误。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：37.9 MB, 在所有 Java 提交中击败了41.53%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>采用递归的方式，思路新颖，值得学习。说实话，还真有点看不懂。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode res = l1.val &lt; l2.val ? l1 : l2;</span><br><span class="line">    res.next = mergeTwoLists(res.next, l1.val &gt;= l2.val ? l1 : l2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了25.36%的用户</span><br><span class="line">内存消耗：37.7 MB, 在所有 Java 提交中击败了88.30%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>依旧采用递归思想，相对而言，内存损耗较少。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共前缀</title>
      <link href="2021/03/28/LeetCode/easy/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>2021/03/28/LeetCode/easy/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月27日</li><li>描述：加油！加油！加油！！！！</li></ul><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p><ol><li><strong>问题描述：</strong></li></ol><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示</strong></li></ol><ul><li><code>0 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String str = strs[<span class="number">0</span>];</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt; strs.length; i1++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(strs[i1]) || i &gt;= strs[i1].length() || c != strs[i1].charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> builder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了84.12%的用户</span><br><span class="line">内存消耗：36.7 MB, 在所有 Java 提交中击败了30.08%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 执行用时算是还可以接受，但是内存损耗依旧还是有点大</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String pre = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        pre = longestCommonPrefix(pre, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (pre.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; min &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了84.12%的用户</span><br><span class="line">内存消耗：36.6 MB, 在所有 Java 提交中击败了39.26%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>两两比较先找到相同前缀，再用相同的前缀去和接下来的比拿到继续相同的部分</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = strs[<span class="number">0</span>].length();</span><br><span class="line">    <span class="keyword">int</span> count = strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了84.12%的用户</span><br><span class="line">内存消耗：36.6 MB, 在所有 Java 提交中击败了40.32%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>该方式和我的方式思维一致，但是比我的更简洁，在我的基础上内存损耗更少</p><h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[start];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        String lcpLeft = longestCommonPrefix(strs, start, mid);</span><br><span class="line">        String lcpRight = longestCommonPrefix(strs, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">commonPrefix</span><span class="params">(String lcpLeft, String lcpRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minLength = Math.min(lcpLeft.length(), lcpRight.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lcpLeft.charAt(i) != lcpRight.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lcpLeft.substring(<span class="number">0</span>, minLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了84.12%的用户</span><br><span class="line">内存消耗：36 MB, 在所有 Java 提交中击败了99.87%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>分治法，可以使用分治法得到字符串数组中的最长公共前缀 。对两个子问题分别求解，然后对两个子问题的解计算最长公共前缀，即为原问题的解。</p><h5 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">         minLength = Math.min(minLength, str.length());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> low = <span class="number">0</span>, high = minLength;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">         <span class="keyword">if</span> (isCommonPrefix(strs, mid)) &#123;</span><br><span class="line">             low = mid;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             high = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, low);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">int</span> count = strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        String str = strs[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str0.charAt(j) != str.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了84.12%的用户</span><br><span class="line">内存消耗：36.8 MB, 在所有 Java 提交中击败了22.21%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>二分法方式，，貌似效率没上面一种的效果好</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//公共前缀比所有字符串都短，随便选一个先</span></span><br><span class="line">    String s=strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (String string : strs) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!string.startsWith(s))&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//公共前缀不匹配就让它变短！</span></span><br><span class="line">            s=s.substring(<span class="number">0</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：36.3 MB, 在所有 Java 提交中击败了93.67%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>真的全是人才，大佬所作，甚是佩服！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找两个正序数组的中位数</title>
      <link href="2021/03/27/LeetCode/difficulty/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>2021/03/27/LeetCode/difficulty/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月27日</li><li>描述：晴🌞，每日不可或缺的加油打气</li></ul><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>示例5:</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><ol><li><strong>提示</strong></li></ol><ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li></ul><p><strong>进阶：</strong> 你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] ints = addArray(nums1, nums2);</span><br><span class="line">  <span class="keyword">int</span> length = ints.length;</span><br><span class="line">  <span class="keyword">if</span> (length % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (ints[i]+ints[i-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ints[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] addArray(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)&#123;</span><br><span class="line">  <span class="keyword">int</span> length = nums1.length;</span><br><span class="line">  <span class="keyword">int</span> length1 = nums2.length;</span><br><span class="line">  <span class="keyword">int</span> l2 = length-- +length1--;</span><br><span class="line">  <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[l2--];</span><br><span class="line">  <span class="keyword">while</span> (length &gt;= <span class="number">0</span> &amp;&amp; length1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ints[l2--] = nums1[length] &gt; nums2[length1] ? nums1[length--] : nums2[length1--];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (length &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    ints[l2--] = nums1[length--];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (length1 &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    ints[l2--] = nums2[length1--];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了82.32%的用户</span><br><span class="line">内存消耗：39.6 MB, 在所有 Java 提交中击败了73.37%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 首先，学习了合并了两个有序数组的合并方式，使用了较好的一种方式将两个数组合并，然后合并了之后就简单了，直接寻找中位数即可。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">  <span class="keyword">int</span> totalLength = length1 + length2;</span><br><span class="line">  <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> median = getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> midIndex1 = totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">  <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> kthElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">int</span> half = k / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">    <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">      k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">      index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">      index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了82.32%的用户</span><br><span class="line">内存消耗：39.9 MB, 在所有 Java 提交中击败了21.53%的用户</span><br></pre></td></tr></table></figure><p>总结：不当人</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">  <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line">  <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">  <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">  <span class="keyword">int</span> median1 = <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">    <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">    <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">    <span class="keyword">int</span> nums_im1 = (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">    <span class="keyword">int</span> nums_jm1 = (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">      median1 = Math.max(nums_im1, nums_jm1);</span><br><span class="line">      median2 = Math.min(nums_i, nums_j);</span><br><span class="line">      left = i + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：3 ms, 在所有 Java 提交中击败了82.32%的用户</span><br><span class="line">内存消耗：39.3 MB, 在所有 Java 提交中击败了97.13%的用户</span><br></pre></td></tr></table></figure><p>总结：不当人</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">  <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">  <span class="keyword">int</span> left = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> right = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i: nums1的起始位置 j: nums2的起始位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> i, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( i &gt;= nums1.length) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];<span class="comment">//nums1为空数组</span></span><br><span class="line">  <span class="keyword">if</span>( j &gt;= nums2.length) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];<span class="comment">//nums2为空数组</span></span><br><span class="line">  <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> midVal1 = (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">int</span> midVal2 = (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span>(midVal1 &lt; midVal2)&#123;</span><br><span class="line">    <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：39.8 MB, 在所有 Java 提交中击败了43.65%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>看来这个难度还是不适合我。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux相关命令</title>
      <link href="2021/03/27/Linux/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
      <url>2021/03/27/Linux/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于任何一个程序员来说，linux都是非常重要的。</p><h4 id="1、文件管理"><a href="#1、文件管理" class="headerlink" title="1、文件管理"></a>1、文件管理</h4><ol><li><code>ls</code>    </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l     #该目录下面的文件</span><br><span class="line">ls -l /   #/目录下面的文件</span><br><span class="line">ll        #ls -l 的简写</span><br></pre></td></tr></table></figure><ol start="2"><li><code>cd</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr   #切换目录至usr</span><br></pre></td></tr></table></figure><ol start="3"><li><code>cp</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 1.text /usr/2.txt   #拷贝文件</span><br></pre></td></tr></table></figure><ol start="4"><li><code>mv</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 1.txt /usr/2.txt   #将1.txt移动到/usr下面并改名为2.txt</span><br></pre></td></tr></table></figure><ol start="5"><li><code>rm</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 1.txt      # -r说明是目录或者文件  f说明不提示确定信息</span><br></pre></td></tr></table></figure><ol start="6"><li><code>pwd</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd     # 显示当前所在目录</span><br></pre></td></tr></table></figure><ol start="7"><li><code>clean</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean      #清除屏幕信息</span><br></pre></td></tr></table></figure><ol start="8"><li><code>mkdir</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir d     #创建d目录</span><br></pre></td></tr></table></figure><ol start="9"><li><code>touch</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 1.txt     #创建1.txt文件</span><br></pre></td></tr></table></figure><h4 id="2、系统"><a href="#2、系统" class="headerlink" title="2、系统"></a>2、系统</h4><ol><li><code>passwd</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root   #用于设置用户密码</span><br></pre></td></tr></table></figure><ol start="2"><li><code>su</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -      #q切换至超级用户</span><br></pre></td></tr></table></figure><ol start="3"><li><code>man</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls      #显示帮助命令</span><br></pre></td></tr></table></figure><ol start="4"><li><code>who</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">who -r       #显示当前的运行级别</span><br><span class="line">who -buT     #显示当前登录的系统用户</span><br></pre></td></tr></table></figure><h4 id="3、文件查看"><a href="#3、文件查看" class="headerlink" title="3、文件查看"></a>3、文件查看</h4><p>1.<code>vim和vi</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim 1.txt    #查看编辑1.txt文件</span><br><span class="line">vi 1.txt</span><br></pre></td></tr></table></figure><p>进入后常用操作：i进行插入    esc退出插入     :wq保存并退出   :!q强制退出</p><ul><li>跳到最后一行     :$</li><li>查找    /zhansan     n    向下查找。    N   向上查找    </li></ul><ol start="2"><li><code>cat</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -Ab /var/log/boot.log     #用于查看文件，例如查看Linux启动日志文件文件，并标明行号,只能显示最后一屏内容</span><br></pre></td></tr></table></figure><ol start="3"><li><code>more</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -c -10 /var/log/boot.log    #用于分页查看文件，例如每页10行查看boot.log文件,可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br></pre></td></tr></table></figure><ol start="4"><li><code>less</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /var/log/boot.log    #可以使用键盘上的PgUp和PgDn向上和向下翻页，q结束查看</span><br></pre></td></tr></table></figure><ol start="5"><li><code>tail</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f ../log/catalina.log     #实时查看文件加载内容，例如查看tomcat启动日志，实时监测是否成功</span><br><span class="line">tail -10 /etc/sudo.conf         #查看文件的后10行，Ctrl+C结束</span><br></pre></td></tr></table></figure><h4 id="4、解压与压缩"><a href="#4、解压与压缩" class="headerlink" title="4、解压与压缩"></a>4、解压与压缩</h4><h5 id="4-1、tar类型"><a href="#4-1、tar类型" class="headerlink" title="4.1、tar类型"></a>4.1、tar类型</h5><ol><li>分页查看压缩包中内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf /demo.tar.gz |more -c -10</span><br></pre></td></tr></table></figure><ol start="2"><li>用``gzip<code>压缩文件夹</code>/etc<code>中的文件到文件</code>etc.tar.gz`</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf /demo.tar.gz /home</span><br></pre></td></tr></table></figure><ol start="3"><li>用<code>bzip2</code>压缩文件夹<code>/etc</code>到文件<code>/etc.tar.bz2</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf /demo.tar.bz2 /home</span><br></pre></td></tr></table></figure><ol start="4"><li>解压文件到当前目录（gzip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /demo.tar.gz</span><br></pre></td></tr></table></figure><ol start="5"><li>解压文件到指定目录（gzip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /demo.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h5 id="4-2、zip类型"><a href="#4-2、zip类型" class="headerlink" title="4.2、zip类型"></a>4.2、zip类型</h5><p>1、查看zip文件中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipinfo -1 -M  filename.zip</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-1 只列出文件名称。</li><li>-2 此参数的效果和指定&quot;-1&quot;参数类似，但可搭配&quot;-h&quot;,&quot;-t&quot;和&quot;-z&quot;参数使用。</li><li>-h 只列出压缩文件的文件名称。</li><li>-l 此参数的效果和指定&quot;-m&quot;参数类似，但会列出原始文件的大小而非每个文件的压缩率。</li><li>-m 此参数的效果和指定&quot;-s&quot;参数类似，但多会列出每个文件的压缩率。</li><li>-M 若信息内容超过一个画</li></ul><ol start="2"><li>解压zip文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure><ol start="3"><li>对文件进行zip压缩</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip filename.zip filename.jar   #将filename.jar压缩为文件名为filename.zip的压缩文件</span><br></pre></td></tr></table></figure><h4 id="5、系统服务管理"><a href="#5、系统服务管理" class="headerlink" title="5、系统服务管理"></a>5、系统服务管理</h4><p>拿达梦服务做演示</p><ol><li>输出系统中各个服务的状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type=service</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/systemctl_see_service.png" alt="输出各个服务状态"></p><ol start="2"><li>查看服务运行状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/systemctl_status.png" alt="查看服务运行状态"></p><ol start="3"><li>关闭服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><ol start="4"><li>启动服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><ol start="5"><li>重新启动服务（不管当前服务是启动还是关闭）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><ol start="6"><li>重新载入配置信息而不中断服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><ol start="7"><li>禁止服务开机自启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><ol start="8"><li>设置服务开机自启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable DmServiceDMSERVER.service</span><br></pre></td></tr></table></figure><h4 id="6、内存与磁盘相关命令"><a href="#6、内存与磁盘相关命令" class="headerlink" title="6、内存与磁盘相关命令"></a>6、内存与磁盘相关命令</h4><h5 id="6-1、free"><a href="#6-1、free" class="headerlink" title="6.1、free"></a>6.1、free</h5><p> <strong>free命令用以显示当前系统内存使用情况，其数据取自/proc/meminfo文件。</strong></p><ol><li>使用方式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br><span class="line">free -m   #是快速查看上一个命令的方法</span><br><span class="line">free -h -s 3   #表示每隔三秒输出一次内存情况</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/free.png" alt="free命令"></p><p>参数：</p><ul><li> <code>-b, –bytes</code>， 以Byte为单位显示内存使用情况</li><li></li><li> <code>-k, –kilo</code>， 以KB为单位， 这也是默认值</li><li><code>-m, –mega</code>， 以MB为单位显示内容使用情况</li><li><code>-g, –giga</code>， 以GB为单位显示内存使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h    # human    换为人类可以读懂的方式</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/free_h.png" alt="free命令"></p><ol start="2"><li>内容解读</li></ol><ul><li><strong>第一列</strong><br> <code>Mem</code> 内存的使用信息<br> <code>Swap</code> 交换空间的使用信息</li><li><strong>第一行</strong><br> <code>total</code> 系统总的可用物理内存和交换空间大小。<br> <code>used</code> 已经被使用的物理内存和交换空间。<br> <code>free</code> 还有多少物理内存和交换空间可用使用，是真正尚未被使用的物理内存数量。<br> <code>shared</code> 被共享使用的物理内存大小<br> <code>buff/cache</code> 被 buffer（缓冲区） 和 cache（缓存） 使用的物理内存大小。<br> <code>available</code> 还可以被 *<strong>应用程序*</strong> 使用的物理内存大小</li></ul><p><code>free</code> 是真正尚未被使用的物理内存数量。<br><code>available</code> 是应用程序认为可用内存数量，<code>available = free + buffer + cache</code> (注：只是大概的计算方法)</p><p><strong>如何判断系统内存不足：</strong> 如果Swap used值大于0，代表服务器物理内存已经遇到内存瓶颈了，已开始使用虚拟内存了，要么优化代码，要么加内存</p><ul><li><strong>什么是交换空间？</strong></li></ul><p>​       swap space 是磁盘上的一块区域，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p><h5 id="6-2、ps"><a href="#6-2、ps" class="headerlink" title="6.2、ps"></a>6.2、ps</h5><ul><li>显示系统进程运行动态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li>查看<code>java</code>进程的运行动态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><ul><li>查看特定进程的数量</li></ul><p>如查看java进程的数量,<code>ps -ef | grep java| wc -l</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java| wc -l</span><br></pre></td></tr></table></figure><ul><li>查看线程是否存在死锁</li></ul><p>查看线程是否存在死锁，<code>jstack -l pid</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack -l 124146</span><br><span class="line">2020-05-02 10:13:38</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os_prio=0 tid=0x00007f27f013c000 nid=0x1e4f9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=0 tid=0x00007f27f012d000 nid=0x1e4f8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f27f004b800 nid=0x1e4f3 waiting on condition [0x00007f27f7274000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>查看某个进程的线程数</li></ul><p><code>ps -efL | grep [PID] | wc -l</code>，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -efL | grep 124146 | wc -l</span><br><span class="line">12</span><br></pre></td></tr></table></figure><ul><li>查看具体有哪些线程用<code>ps -Lp [pid] cu</code>:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 124146 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     124146 124146  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 java</span><br><span class="line">root     124146 124147  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:01 java</span><br><span class="line">root     124146 124148  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 VM Thread</span><br><span class="line">root     124146 124149  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Reference Handl</span><br><span class="line">root     124146 124150  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Finalizer</span><br><span class="line">root     124146 124151  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Signal Dispatch</span><br><span class="line">root     124146 124152  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C2 CompilerThre</span><br><span class="line">root     124146 124153  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C1 CompilerThre</span><br><span class="line">root     124146 124154  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Service Thread</span><br><span class="line">root     124146 124155  0.1   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:05 VM Periodic Tas</span><br><span class="line">root     124146 125362  0.0   11  2.5 2489116 35724 pts/0   Sl+  10:13   0:00 Attach Listener</span><br></pre></td></tr></table></figure><ul><li>统计所有的log文件中，包含Error字符的行</li></ul><p><code>find / -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;</code>，这个在排查问题过程中比较有用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file &#x27;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&#x27; error: &#x27;[Errno 19] No such device&#x27;</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file &#x27;/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor&#x27; error: &#x27;[Errno 19] No such device&#x27;</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,857 ERROR    tuned.utils.commands: Writing to file &#x27;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&#x27; error: &#x27;[Errno 19] No such device&#x27;</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,859 ERROR    tuned.utils.commands: Writing to file &#x27;/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor&#x27; error: &#x27;[Errno 19] No such device&#x27;</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 15:23:19,037 ERROR    tuned.utils.commands: Writing to file &#x27;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&#x27; error: &#x27;[Errno 19] No such device&#x27;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="6-3、top"><a href="#6-3、top" class="headerlink" title="6.3、top"></a>6.3、top</h5><p>查看即时活跃的进程，类似Windows的任务管理器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/top.png" alt="top"></p><p>内容及参数说明：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/top_info.png"></p><p>第一行：<code>22:07:24 up 110 days,  9:19,  1 user,  load average: 4.01, 4.07, 4.06</code> ：22:07:24 系统时间，up 110 days 运行时间，1 user 当前登录用户数，load average 负载均衡情况，分别表示1分钟，5分钟，15分钟负载情况。</p><p>第二行：<code>Tasks: 315 total,1 running, 313 sleeping, 0 stopped,1 zombie</code>：总进程数315，运行数1，休眠 313，停止0，僵尸进程0。</p><p>第三行：<code>%Cpu(s): 50.8 us, 0.5 sy, 0.0 ni, 48.6 id, 0.0 wa,0.0 hi,0.0 si,0.0 st</code>：用户空间CPU占比50.8%，内核空间CPU占比0.5%，改变过优先级的进程CPU占比0。0%，空闲CPU占比48.6%，IO等待占用CPU占比0.0%，硬中断占用CPU占比0。0%，软中断占用CPU占比0.0%,当前VM中的cpu 时钟被虚拟化偷走的比例0.0%。</p><p>第四和第五行表示内存和swap区域的使用情况。</p><p>第七行表示：</p><ul><li><code>PID</code>: 进程id</li><li><code>USER</code>:进程所有者</li><li><code>PR</code>:进程优先级</li><li><code>NI</code>:nice值。负值表示高优先级，正值表示低优先级</li><li><code>VIRT</code>:虚拟内存，进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li><code>RES</code>:常驻内存，进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li><code>SHR</code>:共享内存，共享内存大小，单位kb</li><li><code>S</code>:进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li><code>%CPU</code>:上次更新到现在的CPU时间占用百分比</li><li><code>%MEM</code>:进程使用的物理内存百分比</li><li><code>TIME+</code>:进程使用的CPU时间总计，单位1/100秒</li><li><code>COMMAND</code>:进程名称（命令名/命令行）</li></ul><h5 id="6-4、uptime"><a href="#6-4、uptime" class="headerlink" title="6.4、uptime"></a>6.4、uptime</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/uptime.png"></p><p>参数分别为：当前时间  系统运行天数   当前登录用户个数   系统负载（即任务队列的平均长度）：1mim   5mim  15mim到现在的平均值  </p><h5 id="6-5、df"><a href="#6-5、df" class="headerlink" title="6.5、df"></a>6.5、df</h5><p>查看磁盘空间占用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -hT</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/df.png"></p><h5 id="6-6、du"><a href="#6-6、du" class="headerlink" title="6.6、du"></a>6.6、du</h5><p><code>du -sh</code>命令是查看磁盘已使用空间的情况，这里的“已使用的磁盘空间”意思是指定的文件下的整个文件层次结构所使用的空间，在没给定参数的情况下，<code>du</code>报告当前目录所使用的磁盘空间。其实就是显示文件或目录所占用的磁盘空间的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure><ul><li><code>-h</code>：输出文件系统分区使用的情况，例如：10KB，10MB，10GB等。</li><li><code>-s</code>：显示文件或整个目录的大小，默认单位是KB。</li></ul><blockquote><p><strong>!!</strong> <code>du</code>的详细信息可以通过 <code>man du</code>查看。</p></blockquote><p>查看当前目录下的文件及文件夹所占大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1 ./*</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/du.png"></p><h5 id="6-7、vastat（重要）"><a href="#6-7、vastat（重要）" class="headerlink" title="6.7、vastat（重要）"></a>6.7、vastat（重要）</h5><p>虚拟内存统计，是Linux中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视，推荐使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmstat</span><br><span class="line">vmstat 5 3   # 表示每隔5秒统计一次，一共统计三次。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/phshi/phshi_picture/raw/master/img/vmstat.png"></p><p> <strong>procs</strong></p><ul><li><code>r</code>：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU。</li><li><code>b</code>：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</li></ul><p><strong>memory</strong></p><ul><li><code>swpd</code>：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。</li><li><code>free</code>：表示当前空闲的物理内存。</li><li><code>buff</code>：表示缓冲大小，一般对块设备的读写才需要缓冲</li><li> <code>Cache</code>：表示缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好。</li></ul><p><strong>swap</strong></p><ul><li><code>si</code>：表示数据由磁盘读入内存；通俗的讲就是每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。</li><li><code>so</code>：表示由内存写入磁盘，也就是由内存交换区进入内存的数据大小。</li></ul><blockquote><p><strong>!!</strong> 注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</p></blockquote><p><strong>io</strong></p><ul><li><code>bi</code>：表示由块设备读入数据的总量，即读磁盘，单位kb/s <code>bo</code>：表示写到块设备数据的总量，即写磁盘，单位kb/s</li></ul><blockquote><p><strong>!!</strong> 注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈。</p></blockquote><p><strong>system</strong></p><ul><li><code>in</code>：表示某一时间间隔内观测到的每秒设备终端数。</li><li><code>cs</code>：表示每秒产生的上下文切换次数，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</li></ul><blockquote><p><strong>!!</strong> 注意：这两个值越大，则由内核消耗的CPU就越多。</p></blockquote><p><strong>CPU</strong></p><ul><li><code>us</code>：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法。</li><li><code>sy</code>：表示系统内核进程消耗的CPU时间百分比，一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈。</li><li><code>id</code>：表示CPU处在空间状态的时间百分比。</li><li><code>wa</code>：表示IP等待所占用的CPU时间百分比，wa值越高，说明I/O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I/O等待严重，引起I/O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的。</li></ul><h5 id="6-8、定位线上最耗CPU的线程"><a href="#6-8、定位线上最耗CPU的线程" class="headerlink" title="6.8、定位线上最耗CPU的线程"></a>6.8、定位线上最耗CPU的线程</h5><p><strong>准备工作</strong></p><p>启动一个程序。<code>arthas-demo</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br><span class="line">[root@localhost ~]# curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  3743  100  3743    0     0   3022      0  0:00:01  0:00:01 --:--:--  3023</span><br><span class="line">[root@localhost ~]# java -jar arthas-demo.jar</span><br><span class="line">1813=7*7*37</span><br><span class="line">illegalArgumentCount:  1, number is: -180005, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -111175, need &gt;= 2</span><br><span class="line">18505=5*3701</span><br><span class="line">166691=7*23813</span><br><span class="line">105787=11*59*163</span><br><span class="line">60148=2*2*11*1367</span><br><span class="line">196983=3*3*43*509</span><br><span class="line">illegalArgumentCount:  3, number is: -173479, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  4, number is: -112840, need &gt;= 2</span><br><span class="line">39502=2*19751</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>通过<code>top</code>命令找到最耗时的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 11:11:05 up 20:02,  3 users,  load average: 0.09, 0.07, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.0 us,  0.7 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  1421760 total,   135868 free,   758508 used,   527384 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2070640 free,    26508 used.   475852 avail Mem</span><br><span class="line">Change delay from 3.0 to</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 98344 root      20   0 2422552  23508  12108 S   0.7  1.7   0:00.32 java</span><br><span class="line">     1 root      20   0  194100   6244   3184 S   0.0  0.4   0:20.41 systemd</span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kthreadd</span><br><span class="line">     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">     6 root      20   0       0      0      0 S   0.0  0.0   0:20.25 ksoftirqd/0</span><br></pre></td></tr></table></figure><p>找到进程号是98344。</p><p><strong>找到进程中最耗CUP的线程</strong></p><p>使用<code>ps -Lp #pid cu</code>命令，查看某个进程中的线程CPU消耗排序：</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 98344 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      98344  98344  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 java</span><br><span class="line">root      98344  98345  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:04 java</span><br><span class="line">root      98344  98346  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:01 VM Thread</span><br><span class="line">root      98344  98347  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Reference Handl</span><br><span class="line">root      98344  98348  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Finalizer</span><br><span class="line">root      98344  98349  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Signal Dispatch</span><br><span class="line">root      98344  98350  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:05 C2 CompilerThre</span><br><span class="line">root      98344  98351  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 C1 CompilerThre</span><br><span class="line">root      98344  98352  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Service Thread</span><br><span class="line">root      98344  98353  0.1   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:19 VM Periodic Tas</span><br></pre></td></tr></table></figure><p>看<code>TIME</code>列可以看出那个线程耗费CUP多，根据<code>LWP</code>列可以看到线程的ID号，但是需要转换成16进制才可以查询线程堆栈信息。</p><p><strong>获取线程id的十六进制码</strong></p><p>使用<code>printf &#39;%x\n&#39; 98345</code>命令做进制转换：</p><figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%x\n&#x27; 98345</span><br><span class="line">18029</span><br></pre></td></tr></table></figure><p><strong>查看线程堆栈信息</strong></p><p>使用jstack获取堆栈信息<code>jstack 98344 | grep -A 10 18029</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack 98344 | grep -A 10 18029</span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007fb88404b800 nid=0x18029 waiting on condition [0x00007fb88caab000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=0 tid=0x00007fb8840f2800 nid=0x1802a runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007fb884154000 nid=0x18031 waiting on condition</span><br></pre></td></tr></table></figure><p>通过命令我们可以看到这个线程的对应的耗时代码是在<code>demo.MathGame.main(MathGame.java:17)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">grep -B 5 foo file 显示foo及前5行</span><br><span class="line">grep -A 5 foo file 显示foo及后5行</span><br></pre></td></tr></table></figure><h4 id="7、查看磁盘读写情况"><a href="#7、查看磁盘读写情况" class="headerlink" title="7、查看磁盘读写情况"></a>7、查看磁盘读写情况</h4><h5 id="7-1、查看磁盘总体读写情况"><a href="#7-1、查看磁盘总体读写情况" class="headerlink" title="7.1、查看磁盘总体读写情况"></a>7.1、查看磁盘总体读写情况</h5><p>通<code>iostat</code>查看磁盘总体的读写情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.17</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda               1.56        30.45        39.61    4659620    6060644</span><br><span class="line">scd0              0.00         0.02         0.00       3102          0</span><br><span class="line">dm-0              1.96        30.01        38.42    4591998    5878155</span><br><span class="line">dm-1              0.09         0.09         0.30      13840      45328</span><br></pre></td></tr></table></figure><ul><li><code>tps</code>：该设备每秒的传输次数。</li><li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li><li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li><li><code>kB_read</code>：读取的总数据量；</li><li><code>kB_wrtn</code>：写入的总数量数据量；</li></ul><h5 id="7-2、查看磁盘详细读写情况"><a href="#7-2、查看磁盘详细读写情况" class="headerlink" title="7.2、查看磁盘详细读写情况"></a>7.2、查看磁盘详细读写情况</h5><p>通过<code>iostat -x 1 3</code>可以看到磁盘详细读写情况，没隔一秒输出一次一共输出3次，当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注<code>iowait</code>占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注<code>await</code>，表示磁盘的响应时间以便小于5ms：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat -x 1 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.16</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01     0.49    0.63    0.95    30.59    39.78    89.58     0.34  214.23   49.16  323.48   8.55   1.34</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.02     0.00    98.48     0.00    1.21    1.21    0.00   0.95   0.00</span><br><span class="line">dm-0              0.00     0.00    0.62    1.35    30.15    38.59    69.70     0.91  460.67   49.12  648.54   6.66   1.31</span><br><span class="line">dm-1              0.00     0.00    0.02    0.07     0.09     0.30     8.52     0.04  442.74   95.43  521.17   6.91   0.06</span><br></pre></td></tr></table></figure><p><code>avg-cpu</code>表示总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值：</p><ul><li><code>%user</code>：CPU处在用户模式下的时间百分比。</li><li><code>%nice</code>：CPU处在带NICE值的用户模式下的时间百分比。</li><li><code>%system</code>：CPU处在系统模式下的时间百分比。</li><li><code>%iowait</code>：CPU等待输入输出完成时间的百分比，如果%iowait的值过高，表示硬盘存在I/O瓶颈。</li><li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li><code>%idle</code>：CPU空闲时间百分比，如果%idle值高，表示CPU较空闲；如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量；如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。。</li></ul><p><code>Device</code>表示设备信息：</p><ul><li><code>rrqm/s</code>：每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li><li><code>wrqm/s</code>：每秒对该设备的写请求被合并次数</li><li><code>r/s</code>：每秒完成的读次数</li><li><code>w/s</code>：每秒完成的写次数</li><li><code>rkB/s</code>：每秒读数据量(kB为单位)</li><li><code>wkB/s</code>：每秒写数据量(kB为单位)</li><li><code>avgrq-sz</code>：平均每次IO操作的数据量(扇区数为单位)</li><li><code>avgqu-sz</code>：平均等待处理的IO请求队列长度</li><li><code>await</code>：平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li><li><code>svctm</code>：平均每次IO请求的处理时间(毫秒为单位)</li><li><code>%util</code>：一秒中有百分之多少的时间用于 I/O如果%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷。<code>idle</code>小于70% IO压力就较大了，一般读取速度有较多的wait。</li></ul><blockquote><p><strong>!!</strong> <code>iostat -xmd 1 3</code>：新增<code>m</code>选项可以在输出是使用<code>M</code>为单位。</p></blockquote><h4 id="8、查看最耗IO的进程"><a href="#8、查看最耗IO的进程" class="headerlink" title="8、查看最耗IO的进程"></a>8、查看最耗IO的进程</h4><p>一般先通过<code>iostat</code>查看是否存在io瓶颈，再使用<code>iotop</code>命令来定位那个进程最耗费IO：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">123931 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.02 % [kworker/1:30]</span><br><span class="line"> 94208 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % nautilus-desktop --force [gmain]</span><br><span class="line">     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --system --deserialize 62</span><br><span class="line">     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line"> 94211 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % gvfsd-trash --spawner :1.4 /org/gtk/gvfs/exec_spaw/0</span><br><span class="line">     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line">     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">     7 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]</span><br><span class="line">     9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]</span><br><span class="line">    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过<code>iotop -p pid</code>可以查看单个进程的IO情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop -p 124146</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">124146 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><h4 id="9、网络"><a href="#9、网络" class="headerlink" title="9、网络"></a>9、网络</h4><h5 id="9-1、netstat"><a href="#9-1、netstat" class="headerlink" title="9.1、netstat"></a>9.1、<code>netstat</code></h5><ul><li>查看当前路由信息：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -rn</span><br></pre></td></tr></table></figure><ul><li>查看所有有效TCP连接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li>查看系统中启动的监听服务：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br></pre></td></tr></table></figure><ul><li>查看处于连接状态的系统资源信息：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -atunp</span><br></pre></td></tr></table></figure><h5 id="9-2、定位丢包，错包情况"><a href="#9-2、定位丢包，错包情况" class="headerlink" title="9.2、定位丢包，错包情况"></a>9.2、定位丢包，错包情况</h5><p><code>watch more /proc/net/dev</code>用于定位丢包，错包情况，以便看网络瓶颈，重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# watch -n 2 more /proc/net/dev</span><br><span class="line">Every 2.0s: more /proc/net/dev                                                                                                                                                   Fri May  1 17:16:55 2020</span><br><span class="line"></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   10025     130    0    0    0     0          0         0    10025     130    0    0    0     0       0          0</span><br><span class="line"> ens33: 759098071  569661    0    0    0     0          0         0 19335572  225551    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><ul><li>最左边的表示接口的名字，Receive表示收包，Transmit表示发送包；</li><li><code>bytes</code>：表示收发的字节数；</li><li><code>packets</code>：表示收发正确的包量；</li><li><code>errs</code>：表示收发错误的包量；</li><li><code>drop</code>：表示收发丢弃的包量；</li></ul><h5 id="9-3、查看网络错误"><a href="#9-3、查看网络错误" class="headerlink" title="9.3、查看网络错误"></a>9.3、查看网络错误</h5><p><code>netstat -i</code>可以查看网络错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33            1500   570291      0      0 0        225897      0      0      0 BMRU</span><br><span class="line">lo              65536      130      0      0 0           130      0      0      0 LRU</span><br></pre></td></tr></table></figure><ul><li><code>Iface</code>: 网络接口名称;</li><li><code>MTU</code>: 最大传输单元，它限制了数据帧的最大长度，不同的网络类型都有一个上限值，如：以太网的MTU是1500；</li><li><code>RX-OK</code>：接收时，正确的数据包数。</li><li><code>RX-ERR</code>：接收时，产生错误的数据包数。</li><li><code>RX-DRP</code>：接收时，丢弃的数据包数。</li><li><code>RX-OVR</code>：接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</li><li><code>TX-OK</code>：发送时，正确的数据包数。</li><li><code>TX-ERR</code>：发送时，产生错误的数据包数。</li><li><code>TX-DRP</code>：发送时，丢弃的数据包数。</li><li><code>TX-OVR</code>：发送时，由于过速而丢失的数据包数。</li><li><code>Flg</code>：标志，B 已经设置了一个广播地址。L 该接口是一个回送设备。M 接收所有数据包（混乱模式）。N 避免跟踪。O 在该接口上，禁用ARP。P 这是一个点到点链接。R 接口正在运行。U 接口处于“活动”状态。</li></ul><h5 id="9-4、包的重传率"><a href="#9-4、包的重传率" class="headerlink" title="9.4、包的重传率"></a>9.4、包的重传率</h5><p><code>cat /proc/net/snmp</code>用来查看和分析240秒内网络包量，流量，错包，丢包。通过<code>RetransSegs</code>和<code>OutSegs</code>来计算重传率<code>tcpetr=RetransSegs/OutSegs</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/net/snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 241708 0 0 0 0 0 238724 225517 15 0 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 149 0 0 50 99 0 0 0 0 0 0 0 0 0 147 0 147 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType11 OutType3</span><br><span class="line">IcmpMsg: 50 99 147</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 376 6 0 0 4 236711 223186 292 0 4 0</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">Udp: 1405 438 0 1896 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>重传率=292/223186≈0.13%</p><ul><li>平均每秒新增TCP连接数：通过/proc/net/snmp文件得到最近240秒内PassiveOpens的增量，除以240得到每秒的平均增量；</li><li>机器的TCP连接数 ：通过/proc/net/snmp文件的CurrEstab得到TCP连接数；</li><li>平均每秒的UDP接收数据报：通过/proc/net/snmp文件得到最近240秒内InDatagrams的增量，除以240得到平均每秒的UDP接收数据报；</li><li>平均每秒的UDP发送数据报：通过/proc/net/snmp文件得到最近240秒内OutDatagrams的增量，除以240得到平均每秒的UDP发送数据报；</li></ul><h4 id="10、文件上传下载"><a href="#10、文件上传下载" class="headerlink" title="10、文件上传下载"></a>10、文件上传下载</h4><ul><li>安装上传下载工具<code>lrzsz</code>；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure><ul><li>上传文件，输入以下命令<code>XShell</code>会弹出文件上传框；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><ul><li>下载文件，输入以下命令<code>XShell</code>会弹出文件保存框；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz fileName</span><br></pre></td></tr></table></figure><h4 id="11、rpm"><a href="#11、rpm" class="headerlink" title="11、rpm"></a>11、rpm</h4><blockquote><p>RPM是<code>Red-Hat Package Manager</code>的缩写，一种Linux下通用的软件包管理方式，可用于安装和管理<code>.rpm</code>结尾的软件包。</p></blockquote><ul><li>安装软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh nginx-1.12.2-2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li>模糊搜索软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep nginx</span><br></pre></td></tr></table></figure><ul><li>精确查找软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa nginx</span><br></pre></td></tr></table></figure><ul><li>查询软件包的安装路径：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>查看软件包的概要信息：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>验证软件包内容和安装文件是否一致：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>更新软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>删除软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e nginx-1.12.2-2.el7.x86_64</span><br></pre></td></tr></table></figure><h4 id="12、yum"><a href="#12、yum" class="headerlink" title="12、yum"></a>12、yum</h4><blockquote><p>Yum是<code>Yellow dog Updater, Modified</code>的缩写，能够在线自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，非常方便！</p></blockquote><ul><li>安装软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><ul><li>检查可以更新的软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure><ul><li>更新指定的软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update nginx</span><br></pre></td></tr></table></figure><ul><li>在资源库中查找软件包信息：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info nginx*</span><br></pre></td></tr></table></figure><ul><li>列出已经安装的所有软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info installed</span><br></pre></td></tr></table></figure><ul><li>列出软件包名称：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list nginx*</span><br></pre></td></tr></table></figure><ul><li>模糊搜索软件包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search nginx</span><br></pre></td></tr></table></figure><h4 id="13、其他命令"><a href="#13、其他命令" class="headerlink" title="13、其他命令"></a>13、其他命令</h4><ul><li>杀死进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid     #pid是进程的id</span><br></pre></td></tr></table></figure><ul><li>关机开机</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot     #重启命令</span><br><span class="line">halt       #立即关机</span><br></pre></td></tr></table></figure><ul><li>修改某一个文件的权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rw,o=r aaa.txt   #修改下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，其他用户只有读的权限</span><br><span class="line">chmod 764 aaa.txt     #也可以表示为</span><br></pre></td></tr></table></figure><ul><li>用户相关</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd test               #添加test用户</span><br><span class="line">useradd test -d /home/t1   #指定用户home目录</span><br><span class="line">passwd                     #设置、修改密码</span><br><span class="line">passwd  test               #为test用户设置密码</span><br><span class="line">su – 用户名                 #切换登录</span><br><span class="line">userdel test               #删除test用户(不会删除home目录)</span><br><span class="line">userdel –r test            #删除用户以及home目录</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/48Z_niFVb2AVk2zDWkK-WA">部分参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS 7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数字转化为数字</title>
      <link href="2021/03/27/LeetCode/easy/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/"/>
      <url>2021/03/27/LeetCode/easy/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月25日</li><li>描述：努力，不辜负每一天</li></ul><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转化为整数</a></p><ol><li><strong>问题描述：</strong></li></ol><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>1</td><td>I</td></tr><tr><td>5</td><td>V</td></tr><tr><td>10</td><td>X</td></tr><tr><td>50</td><td>L</td></tr><tr><td>100</td><td>C</td></tr><tr><td>500</td><td>D</td></tr><tr><td>1000</td><td>M</td></tr></tbody></table><p><code>例如：</code>  罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</p></li><li><p>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </p></li><li><p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></li></ul><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>示例5</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>提示</strong></li></ol><ul><li>`1 &lt;= s.length &lt;= 15</li><li>s 仅含字符 (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</li><li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics</a> 。</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; roman = roman();</span><br><span class="line">        <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Integer integer = roman.get(s.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            Integer integer1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//获取下一位的值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; (s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                 integer1 = roman.get(s.charAt(i + <span class="number">1</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果该位为1 10 100，而下一位的值大于该位的值，则有可能是减法</span></span><br><span class="line">            <span class="keyword">if</span> ((integer == <span class="number">1</span> || integer == <span class="number">10</span> || integer == <span class="number">100</span>)</span><br><span class="line">                    &amp;&amp; (i &lt; (s.length() - <span class="number">1</span>) &amp;&amp; !integer.equals(integer1))) &#123;</span><br><span class="line">                <span class="comment">//判断只有相邻的才可以相减  如10和5只可以减1   100和50只可以减10    1000和500只可以减1000</span></span><br><span class="line">                <span class="keyword">if</span> ((integer1 / <span class="number">5</span> == integer) || (integer1 / <span class="number">10</span> == integer)) &#123;</span><br><span class="line">                    tar = tar - integer;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tar += integer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tar += integer;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">roman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;V&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;X&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&quot;C&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&quot;D&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：14 ms, 在所有 Java 提交中击败了6.87%的用户</span><br><span class="line">内存消耗：39.1 MB, 在所有 Java 提交中击败了12.89%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 对罗马数字不熟，拼拼凑凑得到结果，在用时和内存方面都很拉跨。</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Integer integer = roman(s.charAt(i));</span><br><span class="line">            Integer integer1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//获取下一位的值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; (s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                 integer1 = roman(s.charAt(i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (integer&lt;integer1) &#123;</span><br><span class="line">                tar -= integer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tar += integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roman</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span> : <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span> : <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span> : <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：6 ms, 在所有 Java 提交中击败了51.65%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了86.84%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 看了官方解答对我自己的进行改进，由于看了官方的阿拉伯数字组成，导致其中有两点问题，第一：思考问题时将问题复杂化了，以为在前面的可能还会存在不是1、10、100这种情况，甚至还加上了相邻只能相差一位的判断条件。第二：使用了map进行数据存储，没想到使用Swatch可以大幅度减少内存损耗与执行用时。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：4 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.4 MB, 在所有 Java 提交中击败了90.07%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>精选就是精选，一如既往的优秀，将我每次去取下一次结果进行优化，大幅度提升效率</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.replace(<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s = s.replace(<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        s = s.replace(<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        s = s.replace(<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        s = s.replace(<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        s = s.replace(<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;f&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            result += which(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="keyword">return</span> <span class="number">400</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="keyword">return</span> <span class="number">900</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：6 ms, 在所有 Java 提交中击败了51.65%的用户</span><br><span class="line">内存消耗：38.2 MB, 在所有 Java 提交中击败了97.80%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>投机取巧，但是却是开放式思维，值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="2021/03/25/LeetCode/easy/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>2021/03/25/LeetCode/easy/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月25日</li><li>描述：努力，只为遇见最美好的一天</li></ul><h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -101</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>提示</strong></li></ol><ul><li><code>-2^31^&lt;=x&lt;=2^31^ - 1</code></li></ul><p><strong>进阶：</strong> 你能不将整数转为字符串来解决这个问题吗？</p><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小于0说明不是回文数</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String str = x + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) != str.charAt(len - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：22 ms, 在所有 Java 提交中击败了5.75%的用户</span><br><span class="line">内存消耗：38.3 MB, 在所有 Java 提交中击败了11.08%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 使用字符串方式实现，但是运行效率低，并且消耗内存</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//其实就是将前半截与后半截拆出来</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; rev) &#123;</span><br><span class="line">        rev = rev*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev == x || rev/<span class="number">10</span> == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：9 ms, 在所有 Java 提交中击败了99.06%的用户</span><br><span class="line">内存消耗：38 MB, 在所有 Java 提交中击败了35.91%的用户</span><br></pre></td></tr></table></figure><p>总结：其实就是将一个回文数中间拆开，将后半截反转进行比较，如果相同说明是回文数，如果不同说明不是，性能大幅度提升，但是还是小耗内存</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> StringBuilder(x + <span class="string">&quot;&quot;</span>).reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> (x+<span class="string">&quot;&quot;</span>).equals(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：21 ms, 在所有 Java 提交中击败了5.75%的用户</span><br><span class="line">内存消耗：38.9 MB, 在所有 Java 提交中击败了5.00%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>语言简洁明了，但是性能和效率都不可取</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小于0说明不是回文数</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = x;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//字符串反转</span></span><br><span class="line">        rev = rev * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：10 ms, 在所有 Java 提交中击败了73.84%的用户</span><br><span class="line">内存消耗：37.8 MB, 在所有 Java 提交中击败了76.26%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 采用反转后与原数字相等的方法，此种方式值得推荐</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="2021/03/25/LeetCode/easy/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>2021/03/25/LeetCode/easy/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月28日</li><li>描述：努力，只为遇见最美好的一天</li></ul><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p><strong>示例 1：</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>示例5：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>提示</strong></li></ol><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里修改s.length() % == 1   内存消耗直接大幅度提升</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        Character par = getPar(c);</span><br><span class="line">        <span class="comment">//判断是否是前括号，是前括号就存入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (par == <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止进入就是后括号的形式</span></span><br><span class="line">        <span class="keyword">if</span> (stack.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断栈中弹出的与现在的是否一致</span></span><br><span class="line">        Character pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (!pop.equals(par)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//防止全部是前括号的形式</span></span><br><span class="line">    <span class="keyword">if</span> (stack.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">getPar</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了76.00%的用户</span><br><span class="line">内存消耗：36.6 MB, 在所有 Java 提交中击败了50.41%的用户</span><br></pre></td></tr></table></figure><p><code>总结:</code> 性能一般，但是总感觉有些纰漏，应该略微修改。看了官方，突然发现将第一排的判断变为<code>s.length() %2 == 1</code>则内存消耗直接提升至36.3M，可击败95.61的用户。</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：2 ms, 在所有 Java 提交中击败了76.00%的用户</span><br><span class="line">内存消耗：36.4 MB, 在所有 Java 提交中击败了93.04%的用户</span><br></pre></td></tr></table></figure><p>总结：其实思想大致相同，刚开始我也打算使用Map实现，，但是之前做过使用Map比使用Swatch更耗性能，所以我将其修改为Swatch方式。</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式一-2"><a href="#方式一-2" class="headerlink" title="方式一"></a>方式一</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了99.17%的用户</span><br><span class="line">内存消耗：36.3 MB, 在所有 Java 提交中击败了97.41%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code>大神的做法依旧很巧妙，但是原本大神的没有第一部对<code>s.length % 2 == 1</code>这一步的判断，相当于在奇数没有必要判断的时候也走逻辑判断，如不加上，内存损耗就是<code>36.8M</code>,击败<code>24.12%</code>的用户，但是加上该句话性能大幅度提升哦。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="2021/03/23/LeetCode/easy/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/03/23/LeetCode/easy/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月23日</li><li>描述：这才是第一天，一定要坚持下去</li></ul><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示：</strong></li></ol><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><code>**只会存在一个有效答案**</code></li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己书写代码1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; nums.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target - nums[i1] == nums[i]) &#123;</span><br><span class="line">                    arr[<span class="number">0</span>] = i;</span><br><span class="line">                    arr[<span class="number">1</span>] = i1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：16 ms, 在所有 Java 提交中击败了5.02%的用户</span><br><span class="line">内存消耗：38.8 MB, 在所有 Java 提交中击败了19.42%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 最垃圾的方式，没有之一</p><h5 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己书写代码2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                arr[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：38.6 MB, 在所有 Java 提交中击败了57.81%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 总体来说，虽然不算是最优化，但是相比第一中方式，减少了循环次数，性能大幅度提升</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式1-1"><a href="#方式1-1" class="headerlink" title="方式1"></a>方式1</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        hashtable.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结：</code> 总体来说，和我自己的第一中思想相同，只不过当没有匹配数据时返回一个长度为0的数组，比我的返回长度为2的性能更好更完美。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="2021/03/23/LeetCode/easy/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>2021/03/23/LeetCode/easy/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>日期：2021年3月24日</li><li>描述：加油！加油！加油！！</li></ul><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>原文链接：<a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><ol><li><strong>问题描述：</strong></li></ol><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−2^31^,  2^31^ − 1] ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><ol start="2"><li><strong>示例 1：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>示例 2：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例 3：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>示例 4：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>提示：</strong></li></ol><ul><li><code>-2^31^ &lt;= x &lt;= 2^31^ - 1</code></li></ul><h4 id="自己思考"><a href="#自己思考" class="headerlink" title="自己思考"></a>自己思考</h4><h5 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h5><p><code>代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = x &gt; <span class="number">0</span>;</span><br><span class="line">        String value = Math.abs(x)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuilder reverse = <span class="keyword">new</span> StringBuilder(value).reverse();</span><br><span class="line">        <span class="keyword">int</span> integer;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            integer = flag?Integer.parseInt(reverse.toString()):Integer.parseInt(reverse.toString())*-<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            integer = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> integer;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：9 ms, 在所有 Java 提交中击败了7.17%的用户</span><br><span class="line">内存消耗：35.8 MB, 在所有 Java 提交中击败了20.33%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 但是想不到更好的办法，就很拉跨</p><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><h5 id="方式1-1"><a href="#方式1-1" class="headerlink" title="方式1"></a>方式1</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rev = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (Integer.MAX_VALUE / <span class="number">10</span> &lt; value || (value == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; rev &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.MIN_VALUE / <span class="number">10</span> &gt; value || (value == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; rev &lt; -<span class="number">8</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = value*<span class="number">10</span> + rev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.5 MB, 在所有 Java 提交中击败了59.65%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 和我想的差别很大，性能很大提升</p><h4 id="路人解答"><a href="#路人解答" class="headerlink" title="路人解答"></a>路人解答</h4><h5 id="方式1-2"><a href="#方式1-2" class="headerlink" title="方式1"></a>方式1</h5><p><code>代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        value = value * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value == value? (<span class="keyword">int</span>) value :<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>提交结果:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：35.5 MB, 在所有 Java 提交中击败了64.71%的用户</span><br></pre></td></tr></table></figure><p><code>总结：</code> 其实就是官方的进阶版，内存消耗提升比官方解答好 ，虽有些地方难以理解，但是语言更简洁</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
